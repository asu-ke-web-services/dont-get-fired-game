{"version":3,"sources":["meteor://ðŸ’»app/packages/babel-runtime/babel-runtime.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iH","file":"/packages/babel-runtime.js","sourcesContent":["var hasOwn = Object.prototype.hasOwnProperty;\n\nfunction canDefineNonEnumerableProperties() {\n  var testObj = {};\n  var testPropName = \"t\";\n\n  try {\n    Object.defineProperty(testObj, testPropName, {\n      enumerable: false,\n      value: testObj\n    });\n\n    for (var k in testObj) {\n      if (k === testPropName) {\n        return false;\n      }\n    }\n  } catch (e) {\n    return false;\n  }\n\n  return testObj[testPropName] === testObj;\n}\n\n// The name `babelHelpers` is hard-coded in Babel.  Otherwise we would make it\n// something capitalized and more descriptive, like `BabelRuntime`.\nbabelHelpers = {\n  // Meteor-specific runtime helper for wrapping the object of for-in\n  // loops, so that inherited Array methods defined by es5-shim can be\n  // ignored in browsers where they cannot be defined as non-enumerable.\n  sanitizeForInObject: canDefineNonEnumerableProperties()\n    ? function (value) { return value; }\n    : function (obj) {\n      if (Array.isArray(obj)) {\n        var newObj = {};\n        var keys = Object.keys(obj);\n        var keyCount = keys.length;\n        for (var i = 0; i < keyCount; ++i) {\n          var key = keys[i];\n          newObj[key] = obj[key];\n        }\n        return newObj;\n      }\n\n      return obj;\n    },\n\n  // es6.templateLiterals\n  // Constructs the object passed to the tag function in a tagged\n  // template literal.\n  taggedTemplateLiteralLoose: function (strings, raw) {\n    // Babel's own version of this calls Object.freeze on `strings` and\n    // `strings.raw`, but it doesn't seem worth the compatibility and\n    // performance concerns.  If you're writing code against this helper,\n    // don't add properties to these objects.\n    strings.raw = raw;\n    return strings;\n  },\n\n  // es6.classes\n  // Checks that a class constructor is being called with `new`, and throws\n  // an error if it is not.\n  classCallCheck: function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  },\n\n  // es6.classes\n  inherits: function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    if (superClass) {\n      if (Object.create) {\n        // All but IE 8\n        subClass.prototype = Object.create(superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n      } else {\n        // IE 8 path.  Slightly worse for modern browsers, because `constructor`\n        // is enumerable and shows up in the inspector unnecessarily.\n        // It's not an \"own\" property of any instance though.\n        //\n        // For correctness when writing code,\n        // don't enumerate all the own-and-inherited properties of an instance\n        // of a class and expect not to find `constructor` (but who does that?).\n        var F = function () {\n          this.constructor = subClass;\n        };\n        F.prototype = superClass.prototype;\n        subClass.prototype = new F();\n      }\n\n      // For modern browsers, this would be `subClass.__proto__ = superClass`,\n      // but IE <=10 don't support `__proto__`, and in this case the difference\n      // would be detectable; code that works in modern browsers could easily\n      // fail on IE 8 if we ever used the `__proto__` trick.\n      //\n      // There's no perfect way to make static methods inherited if they are\n      // assigned after declaration of the classes.  The best we can do is\n      // to copy them.  In other words, when you write `class Foo\n      // extends Bar`, we copy the static methods from Bar onto Foo, but future\n      // ones are not copied.\n      //\n      // For correctness when writing code, don't add static methods to a class\n      // after you subclass it.\n\n      // The ecmascript-runtime package provides adequate polyfills for\n      // all of these Object.* functions (and Array#forEach), and anyone\n      // using babel-runtime is almost certainly using it because of the\n      // ecmascript package, which also implies ecmascript-runtime.\n      Object.getOwnPropertyNames(superClass).forEach(function (k) {\n        // This property descriptor dance preserves getter/setter behavior\n        // in browsers that support accessor properties (all except\n        // IE8). In IE8, the superClass can't have accessor properties\n        // anyway, so this code is still safe.\n        var descriptor = Object.getOwnPropertyDescriptor(superClass, k);\n        if (descriptor && typeof descriptor === \"object\") {\n          if (Object.getOwnPropertyDescriptor(subClass, k)) {\n            // If subClass already has a property by this name, then it\n            // would not be inherited, so it should not be copied. This\n            // notably excludes properties like .prototype and .name.\n            return;\n          }\n\n          Object.defineProperty(subClass, k, descriptor);\n        }\n      });\n    }\n  },\n\n  createClass: (function () {\n    var hasDefineProperty = false;\n    try {\n      // IE 8 has a broken Object.defineProperty, so feature-test by\n      // trying to call it.\n      Object.defineProperty({}, 'x', {});\n      hasDefineProperty = true;\n    } catch (e) {}\n\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (! hasDefineProperty) {\n        // e.g. `class Foo { get bar() {} }`.  If you try to use getters and\n        // setters in IE 8, you will get a big nasty error, with or without\n        // Babel.  I don't know of any other syntax features besides getters\n        // and setters that will trigger this error.\n        throw new Error(\n          \"Your browser does not support this type of class property.  \" +\n            \"For example, Internet Explorer 8 does not support getters and \" +\n            \"setters.\");\n      }\n\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  })(),\n\n  interopRequireDefault: function (obj) {\n    return obj && obj.__esModule ? obj : { 'default': obj };\n  },\n\n  // es7.objectRestSpread and react (JSX)\n  _extends: Object.assign || (function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (hasOwn.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  }),\n\n  // es6.destructuring\n  objectWithoutProperties: function (obj, keys) {\n    var target = {};\n    outer: for (var i in obj) {\n      if (! hasOwn.call(obj, i)) continue;\n      for (var j = 0; j < keys.length; j++) {\n        if (keys[j] === i) continue outer;\n      }\n      target[i] = obj[i];\n    }\n    return target;\n  },\n\n  // es6.destructuring\n  objectDestructuringEmpty: function (obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  },\n\n  // es6.spread\n  bind: Function.prototype.bind || (function () {\n    var isCallable = function (value) { return typeof value === 'function'; };\n    var $Object = Object;\n    var to_string = Object.prototype.toString;\n    var array_slice = Array.prototype.slice;\n    var array_concat = Array.prototype.concat;\n    var array_push = Array.prototype.push;\n    var max = Math.max;\n    var Empty = function Empty() {};\n\n    // Copied from es5-shim.js (3ac7942).  See original for more comments.\n    return function bind(that) {\n      var target = this;\n      if (!isCallable(target)) {\n        throw new TypeError('Function.prototype.bind called on incompatible ' + target);\n      }\n\n      var args = array_slice.call(arguments, 1);\n\n      var bound;\n      var binder = function () {\n\n        if (this instanceof bound) {\n          var result = target.apply(\n            this,\n            array_concat.call(args, array_slice.call(arguments))\n          );\n          if ($Object(result) === result) {\n            return result;\n          }\n          return this;\n        } else {\n          return target.apply(\n            that,\n            array_concat.call(args, array_slice.call(arguments))\n          );\n        }\n      };\n\n      var boundLength = max(0, target.length - args.length);\n\n      var boundArgs = [];\n      for (var i = 0; i < boundLength; i++) {\n        array_push.call(boundArgs, '$' + i);\n      }\n\n      // Create a Function from source code so that it has the right `.length`.\n      // Probably not important for Babel.  This code violates CSPs that ban\n      // `eval`, but the browsers that need this polyfill don't have CSP!\n      bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n\n      if (target.prototype) {\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n      }\n\n      return bound;\n    };\n\n  })(),\n\n  slice: Array.prototype.slice\n};\n"]}