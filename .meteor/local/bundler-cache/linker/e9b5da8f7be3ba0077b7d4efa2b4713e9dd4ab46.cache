[{"type":"js","data":"(function () {\n\n/* Imports */\nvar process = Package.meteor.process;\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar Random = Package.random.Random;\nvar EJSON = Package.ejson.EJSON;\nvar _ = Package.underscore._;\nvar Tracker = Package.tracker.Tracker;\nvar Deps = Package.tracker.Deps;\nvar Retry = Package.retry.Retry;\nvar IdMap = Package['id-map'].IdMap;\nvar DDPCommon = Package['ddp-common'].DDPCommon;\nvar DiffSequence = Package['diff-sequence'].DiffSequence;\nvar MongoID = Package['mongo-id'].MongoID;\n\n/* Package-scope variables */\nvar DDP, LivedataTest, MongoIDMap, toSockjsUrl, toWebsocketUrl, allConnections, Ledger, objectsWithUsers, errorThrownWhenCallingSetUserIdDirectlyOnServer, One, Two, SockJS, StubStream;\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/namespace.js                                                                                  //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n/**                                                                                                                  // 1\n * @namespace DDP                                                                                                    // 2\n * @summary Namespace for DDP-related methods/classes.                                                               // 3\n */                                                                                                                  // 4\nDDP          = {};                                                                                                   // 5\nLivedataTest = {};                                                                                                   // 6\n                                                                                                                     // 7\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/id_map.js                                                                                     //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nMongoIDMap = function () {                                                                                           // 1\n  var self = this;                                                                                                   // 2\n  IdMap.call(self, MongoID.idStringify, MongoID.idParse);                                                            // 3\n};                                                                                                                   // 4\n                                                                                                                     // 5\nMeteor._inherits(MongoIDMap, IdMap);                                                                                 // 6\n                                                                                                                     // 7\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/stream_client_nodejs.js                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// @param endpoint {String} URL to Meteor app                                                                        // 1\n//   \"http://subdomain.meteor.com/\" or \"/\" or                                                                        // 2\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"                                                                         // 3\n//                                                                                                                   // 4\n// We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",                                        // 5\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns                                     // 6\n// us should work.                                                                                                   // 7\n//                                                                                                                   // 8\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,                                     // 9\n// because it used a built-in sockjs mechanism. We could do it with WebSocket                                        // 10\n// ping frames or with DDP-level messages.)                                                                          // 11\nLivedataTest.ClientStream = function (endpoint, options) {                                                           // 12\n  var self = this;                                                                                                   // 13\n  options = options || {};                                                                                           // 14\n                                                                                                                     // 15\n  self.options = _.extend({                                                                                          // 16\n    retry: true                                                                                                      // 17\n  }, options);                                                                                                       // 18\n                                                                                                                     // 19\n  self.client = null;  // created in _launchConnection                                                               // 20\n  self.endpoint = endpoint;                                                                                          // 21\n                                                                                                                     // 22\n  self.headers = self.options.headers || {};                                                                         // 23\n  self.npmFayeOptions = self.options.npmFayeOptions || {};                                                           // 24\n                                                                                                                     // 25\n  self._initCommon(self.options);                                                                                    // 26\n                                                                                                                     // 27\n  //// Kickoff!                                                                                                      // 28\n  self._launchConnection();                                                                                          // 29\n};                                                                                                                   // 30\n                                                                                                                     // 31\n_.extend(LivedataTest.ClientStream.prototype, {                                                                      // 32\n                                                                                                                     // 33\n  // data is a utf8 string. Data sent while not connected is dropped on                                              // 34\n  // the floor, and it is up the user of this API to retransmit lost                                                 // 35\n  // messages on 'reset'                                                                                             // 36\n  send: function (data) {                                                                                            // 37\n    var self = this;                                                                                                 // 38\n    if (self.currentStatus.connected) {                                                                              // 39\n      self.client.send(data);                                                                                        // 40\n    }                                                                                                                // 41\n  },                                                                                                                 // 42\n                                                                                                                     // 43\n  // Changes where this connection points                                                                            // 44\n  _changeUrl: function (url) {                                                                                       // 45\n    var self = this;                                                                                                 // 46\n    self.endpoint = url;                                                                                             // 47\n  },                                                                                                                 // 48\n                                                                                                                     // 49\n  _onConnect: function (client) {                                                                                    // 50\n    var self = this;                                                                                                 // 51\n                                                                                                                     // 52\n    if (client !== self.client) {                                                                                    // 53\n      // This connection is not from the last call to _launchConnection.                                             // 54\n      // But _launchConnection calls _cleanup which closes previous connections.                                     // 55\n      // It's our belief that this stifles future 'open' events, but maybe                                           // 56\n      // we are wrong?                                                                                               // 57\n      throw new Error(\"Got open from inactive client \" + !!self.client);                                             // 58\n    }                                                                                                                // 59\n                                                                                                                     // 60\n    if (self._forcedToDisconnect) {                                                                                  // 61\n      // We were asked to disconnect between trying to open the connection and                                       // 62\n      // actually opening it. Let's just pretend this never happened.                                                // 63\n      self.client.close();                                                                                           // 64\n      self.client = null;                                                                                            // 65\n      return;                                                                                                        // 66\n    }                                                                                                                // 67\n                                                                                                                     // 68\n    if (self.currentStatus.connected) {                                                                              // 69\n      // We already have a connection. It must have been the case that we                                            // 70\n      // started two parallel connection attempts (because we wanted to                                              // 71\n      // 'reconnect now' on a hanging connection and we had no way to cancel the                                     // 72\n      // connection attempt.) But this shouldn't happen (similarly to the client                                     // 73\n      // !== self.client check above).                                                                               // 74\n      throw new Error(\"Two parallel connections?\");                                                                  // 75\n    }                                                                                                                // 76\n                                                                                                                     // 77\n    self._clearConnectionTimer();                                                                                    // 78\n                                                                                                                     // 79\n    // update status                                                                                                 // 80\n    self.currentStatus.status = \"connected\";                                                                         // 81\n    self.currentStatus.connected = true;                                                                             // 82\n    self.currentStatus.retryCount = 0;                                                                               // 83\n    self.statusChanged();                                                                                            // 84\n                                                                                                                     // 85\n    // fire resets. This must come after status change so that clients                                               // 86\n    // can call send from within a reset callback.                                                                   // 87\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });                                          // 88\n  },                                                                                                                 // 89\n                                                                                                                     // 90\n  _cleanup: function (maybeError) {                                                                                  // 91\n    var self = this;                                                                                                 // 92\n                                                                                                                     // 93\n    self._clearConnectionTimer();                                                                                    // 94\n    if (self.client) {                                                                                               // 95\n      var client = self.client;                                                                                      // 96\n      self.client = null;                                                                                            // 97\n      client.close();                                                                                                // 98\n                                                                                                                     // 99\n      _.each(self.eventCallbacks.disconnect, function (callback) {                                                   // 100\n        callback(maybeError);                                                                                        // 101\n      });                                                                                                            // 102\n    }                                                                                                                // 103\n  },                                                                                                                 // 104\n                                                                                                                     // 105\n  _clearConnectionTimer: function () {                                                                               // 106\n    var self = this;                                                                                                 // 107\n                                                                                                                     // 108\n    if (self.connectionTimer) {                                                                                      // 109\n      clearTimeout(self.connectionTimer);                                                                            // 110\n      self.connectionTimer = null;                                                                                   // 111\n    }                                                                                                                // 112\n  },                                                                                                                 // 113\n                                                                                                                     // 114\n  _getProxyUrl: function (targetUrl) {                                                                               // 115\n    var self = this;                                                                                                 // 116\n    // Similar to code in tools/http-helpers.js.                                                                     // 117\n    var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null;                                            // 118\n    // if we're going to a secure url, try the https_proxy env variable first.                                       // 119\n    if (targetUrl.match(/^wss:/)) {                                                                                  // 120\n      proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;                                           // 121\n    }                                                                                                                // 122\n    return proxy;                                                                                                    // 123\n  },                                                                                                                 // 124\n                                                                                                                     // 125\n  _launchConnection: function () {                                                                                   // 126\n    var self = this;                                                                                                 // 127\n    self._cleanup(); // cleanup the old socket, if there was one.                                                    // 128\n                                                                                                                     // 129\n    // Since server-to-server DDP is still an experimental feature, we only                                          // 130\n    // require the module if we actually create a server-to-server                                                   // 131\n    // connection.                                                                                                   // 132\n    var FayeWebSocket = Npm.require('faye-websocket');                                                               // 133\n    var deflate = Npm.require('permessage-deflate');                                                                 // 134\n                                                                                                                     // 135\n    var targetUrl = toWebsocketUrl(self.endpoint);                                                                   // 136\n    var fayeOptions = {                                                                                              // 137\n      headers: self.headers,                                                                                         // 138\n      extensions: [deflate]                                                                                          // 139\n    };                                                                                                               // 140\n    fayeOptions = _.extend(fayeOptions, self.npmFayeOptions);                                                        // 141\n    var proxyUrl = self._getProxyUrl(targetUrl);                                                                     // 142\n    if (proxyUrl) {                                                                                                  // 143\n      fayeOptions.proxy = { origin: proxyUrl };                                                                      // 144\n    };                                                                                                               // 145\n                                                                                                                     // 146\n    // We would like to specify 'ddp' as the subprotocol here. The npm module we                                     // 147\n    // used to use as a client would fail the handshake if we ask for a                                              // 148\n    // subprotocol and the server doesn't send one back (and sockjs doesn't).                                        // 149\n    // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if                                        // 150\n    // Faye is erroneous or not.  So for now, we don't specify protocols.                                            // 151\n    var subprotocols = [];                                                                                           // 152\n                                                                                                                     // 153\n    var client = self.client = new FayeWebSocket.Client(                                                             // 154\n      targetUrl, subprotocols, fayeOptions);                                                                         // 155\n                                                                                                                     // 156\n    self._clearConnectionTimer();                                                                                    // 157\n    self.connectionTimer = Meteor.setTimeout(                                                                        // 158\n      function () {                                                                                                  // 159\n        self._lostConnection(                                                                                        // 160\n          new DDP.ConnectionError(\"DDP connection timed out\"));                                                      // 161\n      },                                                                                                             // 162\n      self.CONNECT_TIMEOUT);                                                                                         // 163\n                                                                                                                     // 164\n    self.client.on('open', Meteor.bindEnvironment(function () {                                                      // 165\n      return self._onConnect(client);                                                                                // 166\n    }, \"stream connect callback\"));                                                                                  // 167\n                                                                                                                     // 168\n    var clientOnIfCurrent = function (event, description, f) {                                                       // 169\n      self.client.on(event, Meteor.bindEnvironment(function () {                                                     // 170\n        // Ignore events from any connection we've already cleaned up.                                               // 171\n        if (client !== self.client)                                                                                  // 172\n          return;                                                                                                    // 173\n        f.apply(this, arguments);                                                                                    // 174\n      }, description));                                                                                              // 175\n    };                                                                                                               // 176\n                                                                                                                     // 177\n    clientOnIfCurrent('error', 'stream error callback', function (error) {                                           // 178\n      if (!self.options._dontPrintErrors)                                                                            // 179\n        Meteor._debug(\"stream error\", error.message);                                                                // 180\n                                                                                                                     // 181\n      // Faye's 'error' object is not a JS error (and among other things,                                            // 182\n      // doesn't stringify well). Convert it to one.                                                                 // 183\n      self._lostConnection(new DDP.ConnectionError(error.message));                                                  // 184\n    });                                                                                                              // 185\n                                                                                                                     // 186\n                                                                                                                     // 187\n    clientOnIfCurrent('close', 'stream close callback', function () {                                                // 188\n      self._lostConnection();                                                                                        // 189\n    });                                                                                                              // 190\n                                                                                                                     // 191\n                                                                                                                     // 192\n    clientOnIfCurrent('message', 'stream message callback', function (message) {                                     // 193\n      // Ignore binary frames, where message.data is a Buffer                                                        // 194\n      if (typeof message.data !== \"string\")                                                                          // 195\n        return;                                                                                                      // 196\n                                                                                                                     // 197\n      _.each(self.eventCallbacks.message, function (callback) {                                                      // 198\n        callback(message.data);                                                                                      // 199\n      });                                                                                                            // 200\n    });                                                                                                              // 201\n  }                                                                                                                  // 202\n});                                                                                                                  // 203\n                                                                                                                     // 204\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/stream_client_common.js                                                                       //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// XXX from Underscore.String (http://epeli.github.com/underscore.string/)                                           // 1\nvar startsWith = function(str, starts) {                                                                             // 2\n  return str.length >= starts.length &&                                                                              // 3\n    str.substring(0, starts.length) === starts;                                                                      // 4\n};                                                                                                                   // 5\nvar endsWith = function(str, ends) {                                                                                 // 6\n  return str.length >= ends.length &&                                                                                // 7\n    str.substring(str.length - ends.length) === ends;                                                                // 8\n};                                                                                                                   // 9\n                                                                                                                     // 10\n// @param url {String} URL to Meteor app, eg:                                                                        // 11\n//   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"                                                        // 12\n//   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                               // 13\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.                                  // 14\n// for scheme \"http\" and subPath \"sockjs\"                                                                            // 15\n//   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"                                                               // 16\n//   or \"https://ddp--1234-foo.meteor.com/sockjs\"                                                                    // 17\nvar translateUrl =  function(url, newSchemeBase, subPath) {                                                          // 18\n  if (! newSchemeBase) {                                                                                             // 19\n    newSchemeBase = \"http\";                                                                                          // 20\n  }                                                                                                                  // 21\n                                                                                                                     // 22\n  var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);                                                              // 23\n  var httpUrlMatch = url.match(/^http(s?):\\/\\//);                                                                    // 24\n  var newScheme;                                                                                                     // 25\n  if (ddpUrlMatch) {                                                                                                 // 26\n    // Remove scheme and split off the host.                                                                         // 27\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);                                                             // 28\n    newScheme = ddpUrlMatch[1] === \"i\" ? newSchemeBase : newSchemeBase + \"s\";                                        // 29\n    var slashPos = urlAfterDDP.indexOf('/');                                                                         // 30\n    var host =                                                                                                       // 31\n          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);                                           // 32\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);                                                  // 33\n                                                                                                                     // 34\n    // In the host (ONLY!), change '*' characters into random digits. This                                           // 35\n    // allows different stream connections to connect to different hostnames                                         // 36\n    // and avoid browser per-hostname connection limits.                                                             // 37\n    host = host.replace(/\\*/g, function () {                                                                         // 38\n      return Math.floor(Random.fraction()*10);                                                                       // 39\n    });                                                                                                              // 40\n                                                                                                                     // 41\n    return newScheme + '://' + host + rest;                                                                          // 42\n  } else if (httpUrlMatch) {                                                                                         // 43\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \"s\";                                              // 44\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);                                                           // 45\n    url = newScheme + \"://\" + urlAfterHttp;                                                                          // 46\n  }                                                                                                                  // 47\n                                                                                                                     // 48\n  // Prefix FQDNs but not relative URLs                                                                              // 49\n  if (url.indexOf(\"://\") === -1 && !startsWith(url, \"/\")) {                                                          // 50\n    url = newSchemeBase + \"://\" + url;                                                                               // 51\n  }                                                                                                                  // 52\n                                                                                                                     // 53\n  // XXX This is not what we should be doing: if I have a site                                                       // 54\n  // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect                                               // 55\n  // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if                                                   // 56\n  // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")                                               // 57\n  // to connect to \"/foo/bar\").                                                                                      // 58\n  //                                                                                                                 // 59\n  // We should make this properly honor absolute paths rather than                                                   // 60\n  // forcing the path to be relative to the site root. Simultaneously,                                               // 61\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site                                                    // 62\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs                                              // 63\n  url = Meteor._relativeToSiteRootUrl(url);                                                                          // 64\n                                                                                                                     // 65\n  if (endsWith(url, \"/\"))                                                                                            // 66\n    return url + subPath;                                                                                            // 67\n  else                                                                                                               // 68\n    return url + \"/\" + subPath;                                                                                      // 69\n};                                                                                                                   // 70\n                                                                                                                     // 71\ntoSockjsUrl = function (url) {                                                                                       // 72\n  return translateUrl(url, \"http\", \"sockjs\");                                                                        // 73\n};                                                                                                                   // 74\n                                                                                                                     // 75\ntoWebsocketUrl = function (url) {                                                                                    // 76\n  var ret = translateUrl(url, \"ws\", \"websocket\");                                                                    // 77\n  return ret;                                                                                                        // 78\n};                                                                                                                   // 79\n                                                                                                                     // 80\nLivedataTest.toSockjsUrl = toSockjsUrl;                                                                              // 81\n                                                                                                                     // 82\n                                                                                                                     // 83\n_.extend(LivedataTest.ClientStream.prototype, {                                                                      // 84\n                                                                                                                     // 85\n  // Register for callbacks.                                                                                         // 86\n  on: function (name, callback) {                                                                                    // 87\n    var self = this;                                                                                                 // 88\n                                                                                                                     // 89\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')                                             // 90\n      throw new Error(\"unknown event type: \" + name);                                                                // 91\n                                                                                                                     // 92\n    if (!self.eventCallbacks[name])                                                                                  // 93\n      self.eventCallbacks[name] = [];                                                                                // 94\n    self.eventCallbacks[name].push(callback);                                                                        // 95\n  },                                                                                                                 // 96\n                                                                                                                     // 97\n                                                                                                                     // 98\n  _initCommon: function (options) {                                                                                  // 99\n    var self = this;                                                                                                 // 100\n    options = options || {};                                                                                         // 101\n                                                                                                                     // 102\n    //// Constants                                                                                                   // 103\n                                                                                                                     // 104\n    // how long to wait until we declare the connection attempt                                                      // 105\n    // failed.                                                                                                       // 106\n    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;                                                        // 107\n                                                                                                                     // 108\n    self.eventCallbacks = {}; // name -> [callback]                                                                  // 109\n                                                                                                                     // 110\n    self._forcedToDisconnect = false;                                                                                // 111\n                                                                                                                     // 112\n    //// Reactive status                                                                                             // 113\n    self.currentStatus = {                                                                                           // 114\n      status: \"connecting\",                                                                                          // 115\n      connected: false,                                                                                              // 116\n      retryCount: 0                                                                                                  // 117\n    };                                                                                                               // 118\n                                                                                                                     // 119\n                                                                                                                     // 120\n    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency;                                 // 121\n    self.statusChanged = function () {                                                                               // 122\n      if (self.statusListeners)                                                                                      // 123\n        self.statusListeners.changed();                                                                              // 124\n    };                                                                                                               // 125\n                                                                                                                     // 126\n    //// Retry logic                                                                                                 // 127\n    self._retry = new Retry;                                                                                         // 128\n    self.connectionTimer = null;                                                                                     // 129\n                                                                                                                     // 130\n  },                                                                                                                 // 131\n                                                                                                                     // 132\n  // Trigger a reconnect.                                                                                            // 133\n  reconnect: function (options) {                                                                                    // 134\n    var self = this;                                                                                                 // 135\n    options = options || {};                                                                                         // 136\n                                                                                                                     // 137\n    if (options.url) {                                                                                               // 138\n      self._changeUrl(options.url);                                                                                  // 139\n    }                                                                                                                // 140\n                                                                                                                     // 141\n    if (options._sockjsOptions) {                                                                                    // 142\n      self.options._sockjsOptions = options._sockjsOptions;                                                          // 143\n    }                                                                                                                // 144\n                                                                                                                     // 145\n    if (self.currentStatus.connected) {                                                                              // 146\n      if (options._force || options.url) {                                                                           // 147\n        // force reconnect.                                                                                          // 148\n        self._lostConnection(new DDP.ForcedReconnectError);                                                          // 149\n      } // else, noop.                                                                                               // 150\n      return;                                                                                                        // 151\n    }                                                                                                                // 152\n                                                                                                                     // 153\n    // if we're mid-connection, stop it.                                                                             // 154\n    if (self.currentStatus.status === \"connecting\") {                                                                // 155\n      // Pretend it's a clean close.                                                                                 // 156\n      self._lostConnection();                                                                                        // 157\n    }                                                                                                                // 158\n                                                                                                                     // 159\n    self._retry.clear();                                                                                             // 160\n    self.currentStatus.retryCount -= 1; // don't count manual retries                                                // 161\n    self._retryNow();                                                                                                // 162\n  },                                                                                                                 // 163\n                                                                                                                     // 164\n  disconnect: function (options) {                                                                                   // 165\n    var self = this;                                                                                                 // 166\n    options = options || {};                                                                                         // 167\n                                                                                                                     // 168\n    // Failed is permanent. If we're failed, don't let people go back                                                // 169\n    // online by calling 'disconnect' then 'reconnect'.                                                              // 170\n    if (self._forcedToDisconnect)                                                                                    // 171\n      return;                                                                                                        // 172\n                                                                                                                     // 173\n    // If _permanent is set, permanently disconnect a stream. Once a stream                                          // 174\n    // is forced to disconnect, it can never reconnect. This is for                                                  // 175\n    // error cases such as ddp version mismatch, where trying again                                                  // 176\n    // won't fix the problem.                                                                                        // 177\n    if (options._permanent) {                                                                                        // 178\n      self._forcedToDisconnect = true;                                                                               // 179\n    }                                                                                                                // 180\n                                                                                                                     // 181\n    self._cleanup();                                                                                                 // 182\n    self._retry.clear();                                                                                             // 183\n                                                                                                                     // 184\n    self.currentStatus = {                                                                                           // 185\n      status: (options._permanent ? \"failed\" : \"offline\"),                                                           // 186\n      connected: false,                                                                                              // 187\n      retryCount: 0                                                                                                  // 188\n    };                                                                                                               // 189\n                                                                                                                     // 190\n    if (options._permanent && options._error)                                                                        // 191\n      self.currentStatus.reason = options._error;                                                                    // 192\n                                                                                                                     // 193\n    self.statusChanged();                                                                                            // 194\n  },                                                                                                                 // 195\n                                                                                                                     // 196\n  // maybeError is set unless it's a clean protocol-level close.                                                     // 197\n  _lostConnection: function (maybeError) {                                                                           // 198\n    var self = this;                                                                                                 // 199\n                                                                                                                     // 200\n    self._cleanup(maybeError);                                                                                       // 201\n    self._retryLater(maybeError); // sets status. no need to do it here.                                             // 202\n  },                                                                                                                 // 203\n                                                                                                                     // 204\n  // fired when we detect that we've gone online. try to reconnect                                                   // 205\n  // immediately.                                                                                                    // 206\n  _online: function () {                                                                                             // 207\n    // if we've requested to be offline by disconnecting, don't reconnect.                                           // 208\n    if (this.currentStatus.status != \"offline\")                                                                      // 209\n      this.reconnect();                                                                                              // 210\n  },                                                                                                                 // 211\n                                                                                                                     // 212\n  _retryLater: function (maybeError) {                                                                               // 213\n    var self = this;                                                                                                 // 214\n                                                                                                                     // 215\n    var timeout = 0;                                                                                                 // 216\n    if (self.options.retry ||                                                                                        // 217\n        (maybeError && maybeError.errorType === \"DDP.ForcedReconnectError\")) {                                       // 218\n      timeout = self._retry.retryLater(                                                                              // 219\n        self.currentStatus.retryCount,                                                                               // 220\n        _.bind(self._retryNow, self)                                                                                 // 221\n      );                                                                                                             // 222\n      self.currentStatus.status = \"waiting\";                                                                         // 223\n      self.currentStatus.retryTime = (new Date()).getTime() + timeout;                                               // 224\n    } else {                                                                                                         // 225\n      self.currentStatus.status = \"failed\";                                                                          // 226\n      delete self.currentStatus.retryTime;                                                                           // 227\n    }                                                                                                                // 228\n                                                                                                                     // 229\n    self.currentStatus.connected = false;                                                                            // 230\n    self.statusChanged();                                                                                            // 231\n  },                                                                                                                 // 232\n                                                                                                                     // 233\n  _retryNow: function () {                                                                                           // 234\n    var self = this;                                                                                                 // 235\n                                                                                                                     // 236\n    if (self._forcedToDisconnect)                                                                                    // 237\n      return;                                                                                                        // 238\n                                                                                                                     // 239\n    self.currentStatus.retryCount += 1;                                                                              // 240\n    self.currentStatus.status = \"connecting\";                                                                        // 241\n    self.currentStatus.connected = false;                                                                            // 242\n    delete self.currentStatus.retryTime;                                                                             // 243\n    self.statusChanged();                                                                                            // 244\n                                                                                                                     // 245\n    self._launchConnection();                                                                                        // 246\n  },                                                                                                                 // 247\n                                                                                                                     // 248\n                                                                                                                     // 249\n  // Get current status. Reactive.                                                                                   // 250\n  status: function () {                                                                                              // 251\n    var self = this;                                                                                                 // 252\n    if (self.statusListeners)                                                                                        // 253\n      self.statusListeners.depend();                                                                                 // 254\n    return self.currentStatus;                                                                                       // 255\n  }                                                                                                                  // 256\n});                                                                                                                  // 257\n                                                                                                                     // 258\nDDP.ConnectionError = Meteor.makeErrorType(                                                                          // 259\n  \"DDP.ConnectionError\", function (message) {                                                                        // 260\n    var self = this;                                                                                                 // 261\n    self.message = message;                                                                                          // 262\n});                                                                                                                  // 263\n                                                                                                                     // 264\nDDP.ForcedReconnectError = Meteor.makeErrorType(                                                                     // 265\n  \"DDP.ForcedReconnectError\", function () {});                                                                       // 266\n                                                                                                                     // 267\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/livedata_common.js                                                                            //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nLivedataTest.SUPPORTED_DDP_VERSIONS = DDPCommon.SUPPORTED_DDP_VERSIONS;                                              // 1\n                                                                                                                     // 2\n// This is private but it's used in a few places. accounts-base uses                                                 // 3\n// it to get the current user. Meteor.setTimeout and friends clear                                                   // 4\n// it. We can probably find a better way to factor this.                                                             // 5\nDDP._CurrentInvocation = new Meteor.EnvironmentVariable;                                                             // 6\n                                                                                                                     // 7\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/random_stream.js                                                                              //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\n// Returns the named sequence of pseudo-random values.                                                               // 1\n// The scope will be DDP._CurrentInvocation.get(), so the stream will produce                                        // 2\n// consistent values for method calls on the client and server.                                                      // 3\nDDP.randomStream = function (name) {                                                                                 // 4\n  var scope = DDP._CurrentInvocation.get();                                                                          // 5\n  return DDPCommon.RandomStream.get(scope, name);                                                                    // 6\n};                                                                                                                   // 7\n                                                                                                                     // 8\n                                                                                                                     // 9\n                                                                                                                     // 10\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                   //\n// packages/ddp-client/livedata_connection.js                                                                        //\n//                                                                                                                   //\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                     //\nif (Meteor.isServer) {                                                                                               // 1\n  var path = Npm.require('path');                                                                                    // 2\n  var Fiber = Npm.require('fibers');                                                                                 // 3\n  var Future = Npm.require(path.join('fibers', 'future'));                                                           // 4\n}                                                                                                                    // 5\n                                                                                                                     // 6\n// @param url {String|Object} URL to Meteor app,                                                                     // 7\n//   or an object as a test hook (see code)                                                                          // 8\n// Options:                                                                                                          // 9\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?                                     // 10\n//   headers: extra headers to send on the websockets connection, for                                                // 11\n//     server-to-server DDP only                                                                                     // 12\n//   _sockjsOptions: Specifies options to pass through to the sockjs client                                          // 13\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.                                        // 14\n//                                                                                                                   // 15\n// XXX There should be a way to destroy a DDP connection, causing all                                                // 16\n// outstanding method calls to fail.                                                                                 // 17\n//                                                                                                                   // 18\n// XXX Our current way of handling failure and reconnection is great                                                 // 19\n// for an app (where we want to tolerate being disconnected as an                                                    // 20\n// expect state, and keep trying forever to reconnect) but cumbersome                                                // 21\n// for something like a command line tool that wants to make a                                                       // 22\n// connection, call a method, and print an error if connection                                                       // 23\n// fails. We should have better usability in the latter case (while                                                  // 24\n// still transparently reconnecting if it's just a transient failure                                                 // 25\n// or the server migrating us).                                                                                      // 26\nvar Connection = function (url, options) {                                                                           // 27\n  var self = this;                                                                                                   // 28\n  options = _.extend({                                                                                               // 29\n    onConnected: function () {},                                                                                     // 30\n    onDDPVersionNegotiationFailure: function (description) {                                                         // 31\n      Meteor._debug(description);                                                                                    // 32\n    },                                                                                                               // 33\n    heartbeatInterval: 17500,                                                                                        // 34\n    heartbeatTimeout: 15000,                                                                                         // 35\n    npmFayeOptions: {},                                                                                              // 36\n    // These options are only for testing.                                                                           // 37\n    reloadWithOutstanding: false,                                                                                    // 38\n    supportedDDPVersions: DDPCommon.SUPPORTED_DDP_VERSIONS,                                                          // 39\n    retry: true,                                                                                                     // 40\n    respondToPings: true                                                                                             // 41\n  }, options);                                                                                                       // 42\n                                                                                                                     // 43\n  // If set, called when we reconnect, queuing method calls _before_ the                                             // 44\n  // existing outstanding ones. This is the only data member that is part of the                                     // 45\n  // public API!                                                                                                     // 46\n  self.onReconnect = null;                                                                                           // 47\n                                                                                                                     // 48\n  // as a test hook, allow passing a stream instead of a url.                                                        // 49\n  if (typeof url === \"object\") {                                                                                     // 50\n    self._stream = url;                                                                                              // 51\n  } else {                                                                                                           // 52\n    self._stream = new LivedataTest.ClientStream(url, {                                                              // 53\n      retry: options.retry,                                                                                          // 54\n      headers: options.headers,                                                                                      // 55\n      _sockjsOptions: options._sockjsOptions,                                                                        // 56\n      // Used to keep some tests quiet, or for other cases in which                                                  // 57\n      // the right thing to do with connection errors is to silently                                                 // 58\n      // fail (e.g. sending package usage stats). At some point we                                                   // 59\n      // should have a real API for handling client-stream-level                                                     // 60\n      // errors.                                                                                                     // 61\n      _dontPrintErrors: options._dontPrintErrors,                                                                    // 62\n      connectTimeoutMs: options.connectTimeoutMs,                                                                    // 63\n      npmFayeOptions: options.npmFayeOptions                                                                         // 64\n    });                                                                                                              // 65\n  }                                                                                                                  // 66\n                                                                                                                     // 67\n  self._lastSessionId = null;                                                                                        // 68\n  self._versionSuggestion = null;  // The last proposed DDP version.                                                 // 69\n  self._version = null;   // The DDP version agreed on by client and server.                                         // 70\n  self._stores = {}; // name -> object with methods                                                                  // 71\n  self._methodHandlers = {}; // name -> func                                                                         // 72\n  self._nextMethodId = 1;                                                                                            // 73\n  self._supportedDDPVersions = options.supportedDDPVersions;                                                         // 74\n                                                                                                                     // 75\n  self._heartbeatInterval = options.heartbeatInterval;                                                               // 76\n  self._heartbeatTimeout = options.heartbeatTimeout;                                                                 // 77\n                                                                                                                     // 78\n  // Tracks methods which the user has tried to call but which have not yet                                          // 79\n  // called their user callback (ie, they are waiting on their result or for all                                     // 80\n  // of their writes to be written to the local cache). Map from method ID to                                        // 81\n  // MethodInvoker object.                                                                                           // 82\n  self._methodInvokers = {};                                                                                         // 83\n                                                                                                                     // 84\n  // Tracks methods which the user has called but whose result messages have not                                     // 85\n  // arrived yet.                                                                                                    // 86\n  //                                                                                                                 // 87\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block                                           // 88\n  // represents a set of methods that can run at the same time. The first block                                      // 89\n  // represents the methods which are currently in flight; subsequent blocks                                         // 90\n  // must wait for previous blocks to be fully finished before they can be sent                                      // 91\n  // to the server.                                                                                                  // 92\n  //                                                                                                                 // 93\n  // Each block is an object with the following fields:                                                              // 94\n  // - methods: a list of MethodInvoker objects                                                                      // 95\n  // - wait: a boolean; if true, this block had a single method invoked with                                         // 96\n  //         the \"wait\" option                                                                                       // 97\n  //                                                                                                                 // 98\n  // There will never be adjacent blocks with wait=false, because the only thing                                     // 99\n  // that makes methods need to be serialized is a wait method.                                                      // 100\n  //                                                                                                                 // 101\n  // Methods are removed from the first block when their \"result\" is                                                 // 102\n  // received. The entire first block is only removed when all of the in-flight                                      // 103\n  // methods have received their results (so the \"methods\" list is empty) *AND*                                      // 104\n  // all of the data written by those methods are visible in the local cache. So                                     // 105\n  // it is possible for the first block's methods list to be empty, if we are                                        // 106\n  // still waiting for some objects to quiesce.                                                                      // 107\n  //                                                                                                                 // 108\n  // Example:                                                                                                        // 109\n  //  _outstandingMethodBlocks = [                                                                                   // 110\n  //    {wait: false, methods: []},                                                                                  // 111\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},                                                        // 112\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,                                                           // 113\n  //                            <MethodInvoker for 'bar'>]}]                                                         // 114\n  // This means that there were some methods which were sent to the server and                                       // 115\n  // which have returned their results, but some of the data written by                                              // 116\n  // the methods may not be visible in the local cache. Once all that data is                                        // 117\n  // visible, we will send a 'login' method. Once the login method has returned                                      // 118\n  // and all the data is visible (including re-running subs if userId changes),                                      // 119\n  // we will send the 'foo' and 'bar' methods in parallel.                                                           // 120\n  self._outstandingMethodBlocks = [];                                                                                // 121\n                                                                                                                     // 122\n  // method ID -> array of objects with keys 'collection' and 'id', listing                                          // 123\n  // documents written by a given method's stub. keys are associated with                                            // 124\n  // methods whose stub wrote at least one document, and whose data-done message                                     // 125\n  // has not yet been received.                                                                                      // 126\n  self._documentsWrittenByStub = {};                                                                                 // 127\n  // collection -> IdMap of \"server document\" object. A \"server document\" has:                                       // 128\n  // - \"document\": the version of the document according the                                                         // 129\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes                                       // 130\n  //   received from the server)                                                                                     // 131\n  //   It is undefined if we think the document does not exist                                                       // 132\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document                                       // 133\n  //   whose \"data done\" messages have not yet been processed                                                        // 134\n  self._serverDocuments = {};                                                                                        // 135\n                                                                                                                     // 136\n  // Array of callbacks to be called after the next update of the local                                              // 137\n  // cache. Used for:                                                                                                // 138\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after                                              // 139\n  //    the relevant data is flushed.                                                                                // 140\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect                                            // 141\n  //    quiescence. Specifically, methods whose result was received over the old                                     // 142\n  //    connection (so we don't re-send it) but whose data had not been made                                         // 143\n  //    visible.                                                                                                     // 144\n  self._afterUpdateCallbacks = [];                                                                                   // 145\n                                                                                                                     // 146\n  // In two contexts, we buffer all incoming data messages and then process them                                     // 147\n  // all at once in a single update:                                                                                 // 148\n  //   - During reconnect, we buffer all data messages until all subs that had                                       // 149\n  //     been ready before reconnect are ready again, and all methods that are                                       // 150\n  //     active have returned their \"data done message\"; then                                                        // 151\n  //   - During the execution of a \"wait\" method, we buffer all data messages                                        // 152\n  //     until the wait method gets its \"data done\" message. (If the wait method                                     // 153\n  //     occurs during reconnect, it doesn't get any special handling.)                                              // 154\n  // all data messages are processed in one update.                                                                  // 155\n  //                                                                                                                 // 156\n  // The following fields are used for this \"quiescence\" process.                                                    // 157\n                                                                                                                     // 158\n  // This buffers the messages that aren't being processed yet.                                                      // 159\n  self._messagesBufferedUntilQuiescence = [];                                                                        // 160\n  // Map from method ID -> true. Methods are removed from this when their                                            // 161\n  // \"data done\" message is received, and we will not quiesce until it is                                            // 162\n  // empty.                                                                                                          // 163\n  self._methodsBlockingQuiescence = {};                                                                              // 164\n  // map from sub ID -> true for subs that were ready (ie, called the sub                                            // 165\n  // ready callback) before reconnect but haven't become ready again yet                                             // 166\n  self._subsBeingRevived = {}; // map from sub._id -> true                                                           // 167\n  // if true, the next data update should reset all stores. (set during                                              // 168\n  // reconnect.)                                                                                                     // 169\n  self._resetStores = false;                                                                                         // 170\n                                                                                                                     // 171\n  // name -> array of updates for (yet to be created) collections                                                    // 172\n  self._updatesForUnknownStores = {};                                                                                // 173\n  // if we're blocking a migration, the retry func                                                                   // 174\n  self._retryMigrate = null;                                                                                         // 175\n                                                                                                                     // 176\n  // metadata for subscriptions.  Map from sub ID to object with keys:                                               // 177\n  //   - id                                                                                                          // 178\n  //   - name                                                                                                        // 179\n  //   - params                                                                                                      // 180\n  //   - inactive (if true, will be cleaned up if not reused in re-run)                                              // 181\n  //   - ready (has the 'ready' message been received?)                                                              // 182\n  //   - readyCallback (an optional callback to call when ready)                                                     // 183\n  //   - errorCallback (an optional callback to call if the sub terminates with                                      // 184\n  //                    an error, XXX COMPAT WITH 1.0.3.1)                                                           // 185\n  //   - stopCallback (an optional callback to call when the sub terminates                                          // 186\n  //     for any reason, with an error argument if an error triggered the stop)                                      // 187\n  self._subscriptions = {};                                                                                          // 188\n                                                                                                                     // 189\n  // Reactive userId.                                                                                                // 190\n  self._userId = null;                                                                                               // 191\n  self._userIdDeps = new Tracker.Dependency;                                                                         // 192\n                                                                                                                     // 193\n  // Block auto-reload while we're waiting for method responses.                                                     // 194\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {                                         // 195\n    Package.reload.Reload._onMigrate(function (retry) {                                                              // 196\n      if (!self._readyToMigrate()) {                                                                                 // 197\n        if (self._retryMigrate)                                                                                      // 198\n          throw new Error(\"Two migrations in progress?\");                                                            // 199\n        self._retryMigrate = retry;                                                                                  // 200\n        return false;                                                                                                // 201\n      } else {                                                                                                       // 202\n        return [true];                                                                                               // 203\n      }                                                                                                              // 204\n    });                                                                                                              // 205\n  }                                                                                                                  // 206\n                                                                                                                     // 207\n  var onMessage = function (raw_msg) {                                                                               // 208\n    try {                                                                                                            // 209\n      var msg = DDPCommon.parseDDP(raw_msg);                                                                         // 210\n    } catch (e) {                                                                                                    // 211\n      Meteor._debug(\"Exception while parsing DDP\", e);                                                               // 212\n      return;                                                                                                        // 213\n    }                                                                                                                // 214\n                                                                                                                     // 215\n    // Any message counts as receiving a pong, as it demonstrates that                                               // 216\n    // the server is still alive.                                                                                    // 217\n    if (self._heartbeat) {                                                                                           // 218\n      self._heartbeat.messageReceived();                                                                             // 219\n    }                                                                                                                // 220\n                                                                                                                     // 221\n    if (msg === null || !msg.msg) {                                                                                  // 222\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back                                              // 223\n      // compat.  Remove this 'if' once the server stops sending welcome                                             // 224\n      // messages (stream_server.js).                                                                                // 225\n      if (! (msg && msg.server_id))                                                                                  // 226\n        Meteor._debug(\"discarding invalid livedata message\", msg);                                                   // 227\n      return;                                                                                                        // 228\n    }                                                                                                                // 229\n                                                                                                                     // 230\n    if (msg.msg === 'connected') {                                                                                   // 231\n      self._version = self._versionSuggestion;                                                                       // 232\n      self._livedata_connected(msg);                                                                                 // 233\n      options.onConnected();                                                                                         // 234\n    }                                                                                                                // 235\n    else if (msg.msg === 'failed') {                                                                                 // 236\n      if (_.contains(self._supportedDDPVersions, msg.version)) {                                                     // 237\n        self._versionSuggestion = msg.version;                                                                       // 238\n        self._stream.reconnect({_force: true});                                                                      // 239\n      } else {                                                                                                       // 240\n        var description =                                                                                            // 241\n              \"DDP version negotiation failed; server requested version \" + msg.version;                             // 242\n        self._stream.disconnect({_permanent: true, _error: description});                                            // 243\n        options.onDDPVersionNegotiationFailure(description);                                                         // 244\n      }                                                                                                              // 245\n    }                                                                                                                // 246\n    else if (msg.msg === 'ping' && options.respondToPings) {                                                         // 247\n      self._send({msg: \"pong\", id: msg.id});                                                                         // 248\n    }                                                                                                                // 249\n    else if (msg.msg === 'pong') {                                                                                   // 250\n      // noop, as we assume everything's a pong                                                                      // 251\n    }                                                                                                                // 252\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))                                // 253\n      self._livedata_data(msg);                                                                                      // 254\n    else if (msg.msg === 'nosub')                                                                                    // 255\n      self._livedata_nosub(msg);                                                                                     // 256\n    else if (msg.msg === 'result')                                                                                   // 257\n      self._livedata_result(msg);                                                                                    // 258\n    else if (msg.msg === 'error')                                                                                    // 259\n      self._livedata_error(msg);                                                                                     // 260\n    else                                                                                                             // 261\n      Meteor._debug(\"discarding unknown livedata message type\", msg);                                                // 262\n  };                                                                                                                 // 263\n                                                                                                                     // 264\n  var onReset = function () {                                                                                        // 265\n    // Send a connect message at the beginning of the stream.                                                        // 266\n    // NOTE: reset is called even on the first connection, so this is                                                // 267\n    // the only place we send this message.                                                                          // 268\n    var msg = {msg: 'connect'};                                                                                      // 269\n    if (self._lastSessionId)                                                                                         // 270\n      msg.session = self._lastSessionId;                                                                             // 271\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];                                          // 272\n    self._versionSuggestion = msg.version;                                                                           // 273\n    msg.support = self._supportedDDPVersions;                                                                        // 274\n    self._send(msg);                                                                                                 // 275\n                                                                                                                     // 276\n    // Now, to minimize setup latency, go ahead and blast out all of                                                 // 277\n    // our pending methods ands subscriptions before we've even taken                                                // 278\n    // the necessary RTT to know if we successfully reconnected. (1)                                                 // 279\n    // They're supposed to be idempotent; (2) even if we did                                                         // 280\n    // reconnect, we're not sure what messages might have gotten lost                                                // 281\n    // (in either direction) since we were disconnected (TCP being                                                   // 282\n    // sloppy about that.)                                                                                           // 283\n                                                                                                                     // 284\n    // If the current block of methods all got their results (but didn't all get                                     // 285\n    // their data visible), discard the empty block now.                                                             // 286\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&                                                                // 287\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {                                                       // 288\n      self._outstandingMethodBlocks.shift();                                                                         // 289\n    }                                                                                                                // 290\n                                                                                                                     // 291\n    // Mark all messages as unsent, they have not yet been sent on this                                              // 292\n    // connection.                                                                                                   // 293\n    _.each(self._methodInvokers, function (m) {                                                                      // 294\n      m.sentMessage = false;                                                                                         // 295\n    });                                                                                                              // 296\n                                                                                                                     // 297\n    // If an `onReconnect` handler is set, call it first. Go through                                                 // 298\n    // some hoops to ensure that methods that are called from within                                                 // 299\n    // `onReconnect` get executed _before_ ones that were originally                                                 // 300\n    // outstanding (since `onReconnect` is used to re-establish auth                                                 // 301\n    // certificates)                                                                                                 // 302\n    if (self.onReconnect)                                                                                            // 303\n      self._callOnReconnectAndSendAppropriateOutstandingMethods();                                                   // 304\n    else                                                                                                             // 305\n      self._sendOutstandingMethods();                                                                                // 306\n                                                                                                                     // 307\n    // add new subscriptions at the end. this way they take effect after                                             // 308\n    // the handlers and we don't see flicker.                                                                        // 309\n    _.each(self._subscriptions, function (sub, id) {                                                                 // 310\n      self._send({                                                                                                   // 311\n        msg: 'sub',                                                                                                  // 312\n        id: id,                                                                                                      // 313\n        name: sub.name,                                                                                              // 314\n        params: sub.params                                                                                           // 315\n      });                                                                                                            // 316\n    });                                                                                                              // 317\n  };                                                                                                                 // 318\n                                                                                                                     // 319\n  var onDisconnect = function () {                                                                                   // 320\n    if (self._heartbeat) {                                                                                           // 321\n      self._heartbeat.stop();                                                                                        // 322\n      self._heartbeat = null;                                                                                        // 323\n    }                                                                                                                // 324\n  };                                                                                                                 // 325\n                                                                                                                     // 326\n  if (Meteor.isServer) {                                                                                             // 327\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, \"handling DDP message\"));                           // 328\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, \"handling DDP reset\"));                                 // 329\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, \"handling DDP disconnect\"));                  // 330\n  } else {                                                                                                           // 331\n    self._stream.on('message', onMessage);                                                                           // 332\n    self._stream.on('reset', onReset);                                                                               // 333\n    self._stream.on('disconnect', onDisconnect);                                                                     // 334\n  }                                                                                                                  // 335\n};                                                                                                                   // 336\n                                                                                                                     // 337\n// A MethodInvoker manages sending a method to the server and calling the user's                                     // 338\n// callbacks. On construction, it registers itself in the connection's                                               // 339\n// _methodInvokers map; it removes itself once the method is fully finished and                                      // 340\n// the callback is invoked. This occurs when it has both received a result,                                          // 341\n// and the data written by it is fully visible.                                                                      // 342\nvar MethodInvoker = function (options) {                                                                             // 343\n  var self = this;                                                                                                   // 344\n                                                                                                                     // 345\n  // Public (within this file) fields.                                                                               // 346\n  self.methodId = options.methodId;                                                                                  // 347\n  self.sentMessage = false;                                                                                          // 348\n                                                                                                                     // 349\n  self._callback = options.callback;                                                                                 // 350\n  self._connection = options.connection;                                                                             // 351\n  self._message = options.message;                                                                                   // 352\n  self._onResultReceived = options.onResultReceived || function () {};                                               // 353\n  self._wait = options.wait;                                                                                         // 354\n  self._methodResult = null;                                                                                         // 355\n  self._dataVisible = false;                                                                                         // 356\n                                                                                                                     // 357\n  // Register with the connection.                                                                                   // 358\n  self._connection._methodInvokers[self.methodId] = self;                                                            // 359\n};                                                                                                                   // 360\n_.extend(MethodInvoker.prototype, {                                                                                  // 361\n  // Sends the method message to the server. May be called additional times if                                       // 362\n  // we lose the connection and reconnect before receiving a result.                                                 // 363\n  sendMessage: function () {                                                                                         // 364\n    var self = this;                                                                                                 // 365\n    // This function is called before sending a method (including resending on                                       // 366\n    // reconnect). We should only (re)send methods where we don't already have a                                     // 367\n    // result!                                                                                                       // 368\n    if (self.gotResult())                                                                                            // 369\n      throw new Error(\"sendingMethod is called on method with result\");                                              // 370\n                                                                                                                     // 371\n    // If we're re-sending it, it doesn't matter if data was written the first                                       // 372\n    // time.                                                                                                         // 373\n    self._dataVisible = false;                                                                                       // 374\n                                                                                                                     // 375\n    self.sentMessage = true;                                                                                         // 376\n                                                                                                                     // 377\n    // If this is a wait method, make all data messages be buffered until it is                                      // 378\n    // done.                                                                                                         // 379\n    if (self._wait)                                                                                                  // 380\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;                                             // 381\n                                                                                                                     // 382\n    // Actually send the message.                                                                                    // 383\n    self._connection._send(self._message);                                                                           // 384\n  },                                                                                                                 // 385\n  // Invoke the callback, if we have both a result and know that all data has                                        // 386\n  // been written to the local cache.                                                                                // 387\n  _maybeInvokeCallback: function () {                                                                                // 388\n    var self = this;                                                                                                 // 389\n    if (self._methodResult && self._dataVisible) {                                                                   // 390\n      // Call the callback. (This won't throw: the callback was wrapped with                                         // 391\n      // bindEnvironment.)                                                                                           // 392\n      self._callback(self._methodResult[0], self._methodResult[1]);                                                  // 393\n                                                                                                                     // 394\n      // Forget about this method.                                                                                   // 395\n      delete self._connection._methodInvokers[self.methodId];                                                        // 396\n                                                                                                                     // 397\n      // Let the connection know that this method is finished, so it can try to                                      // 398\n      // move on to the next block of methods.                                                                       // 399\n      self._connection._outstandingMethodFinished();                                                                 // 400\n    }                                                                                                                // 401\n  },                                                                                                                 // 402\n  // Call with the result of the method from the server. Only may be called                                          // 403\n  // once; once it is called, you should not call sendMessage again.                                                 // 404\n  // If the user provided an onResultReceived callback, call it immediately.                                         // 405\n  // Then invoke the main callback if data is also visible.                                                          // 406\n  receiveResult: function (err, result) {                                                                            // 407\n    var self = this;                                                                                                 // 408\n    if (self.gotResult())                                                                                            // 409\n      throw new Error(\"Methods should only receive results once\");                                                   // 410\n    self._methodResult = [err, result];                                                                              // 411\n    self._onResultReceived(err, result);                                                                             // 412\n    self._maybeInvokeCallback();                                                                                     // 413\n  },                                                                                                                 // 414\n  // Call this when all data written by the method is visible. This means that                                       // 415\n  // the method has returns its \"data is done\" message *AND* all server                                              // 416\n  // documents that are buffered at that time have been written to the local                                         // 417\n  // cache. Invokes the main callback if the result has been received.                                               // 418\n  dataVisible: function () {                                                                                         // 419\n    var self = this;                                                                                                 // 420\n    self._dataVisible = true;                                                                                        // 421\n    self._maybeInvokeCallback();                                                                                     // 422\n  },                                                                                                                 // 423\n  // True if receiveResult has been called.                                                                          // 424\n  gotResult: function () {                                                                                           // 425\n    var self = this;                                                                                                 // 426\n    return !!self._methodResult;                                                                                     // 427\n  }                                                                                                                  // 428\n});                                                                                                                  // 429\n                                                                                                                     // 430\n_.extend(Connection.prototype, {                                                                                     // 431\n  // 'name' is the name of the data on the wire that should go in the                                                // 432\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,                                     // 433\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.                                     // 434\n  registerStore: function (name, wrappedStore) {                                                                     // 435\n    var self = this;                                                                                                 // 436\n                                                                                                                     // 437\n    if (name in self._stores)                                                                                        // 438\n      return false;                                                                                                  // 439\n                                                                                                                     // 440\n    // Wrap the input object in an object which makes any store method not                                           // 441\n    // implemented by 'store' into a no-op.                                                                          // 442\n    var store = {};                                                                                                  // 443\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',                                                   // 444\n            'retrieveOriginals', 'getDoc'], function (method) {                                                      // 445\n              store[method] = function () {                                                                          // 446\n                return (wrappedStore[method]                                                                         // 447\n                        ? wrappedStore[method].apply(wrappedStore, arguments)                                        // 448\n                        : undefined);                                                                                // 449\n              };                                                                                                     // 450\n            });                                                                                                      // 451\n                                                                                                                     // 452\n    self._stores[name] = store;                                                                                      // 453\n                                                                                                                     // 454\n    var queued = self._updatesForUnknownStores[name];                                                                // 455\n    if (queued) {                                                                                                    // 456\n      store.beginUpdate(queued.length, false);                                                                       // 457\n      _.each(queued, function (msg) {                                                                                // 458\n        store.update(msg);                                                                                           // 459\n      });                                                                                                            // 460\n      store.endUpdate();                                                                                             // 461\n      delete self._updatesForUnknownStores[name];                                                                    // 462\n    }                                                                                                                // 463\n                                                                                                                     // 464\n    return true;                                                                                                     // 465\n  },                                                                                                                 // 466\n                                                                                                                     // 467\n  /**                                                                                                                // 468\n   * @memberOf Meteor                                                                                                // 469\n   * @summary Subscribe to a record set.  Returns a handle that provides                                             // 470\n   * `stop()` and `ready()` methods.                                                                                 // 471\n   * @locus Client                                                                                                   // 472\n   * @param {String} name Name of the subscription.  Matches the name of the                                         // 473\n   * server's `publish()` call.                                                                                      // 474\n   * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher                                        // 475\n   * function on server.                                                                                             // 476\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`                                             // 477\n   * and `onReady` callbacks. If there is an error, it is passed as an                                               // 478\n   * argument to `onStop`. If a function is passed instead of an object, it                                          // 479\n   * is interpreted as an `onReady` callback.                                                                        // 480\n   */                                                                                                                // 481\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {                                          // 482\n    var self = this;                                                                                                 // 483\n                                                                                                                     // 484\n    var params = Array.prototype.slice.call(arguments, 1);                                                           // 485\n    var callbacks = {};                                                                                              // 486\n    if (params.length) {                                                                                             // 487\n      var lastParam = params[params.length - 1];                                                                     // 488\n      if (_.isFunction(lastParam)) {                                                                                 // 489\n        callbacks.onReady = params.pop();                                                                            // 490\n      } else if (lastParam &&                                                                                        // 491\n        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use                                             // 492\n        // onStop with an error callback instead.                                                                    // 493\n        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],                                              // 494\n          _.isFunction)) {                                                                                           // 495\n        callbacks = params.pop();                                                                                    // 496\n      }                                                                                                              // 497\n    }                                                                                                                // 498\n                                                                                                                     // 499\n    // Is there an existing sub with the same name and param, run in an                                              // 500\n    // invalidated Computation? This will happen if we are rerunning an                                              // 501\n    // existing computation.                                                                                         // 502\n    //                                                                                                               // 503\n    // For example, consider a rerun of:                                                                             // 504\n    //                                                                                                               // 505\n    //     Tracker.autorun(function () {                                                                             // 506\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));                                                            // 507\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));                                                            // 508\n    //     });                                                                                                       // 509\n    //                                                                                                               // 510\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"                                               // 511\n    // subcribe to an existing inactive subscription in order to not                                                 // 512\n    // unsub and resub the subscription unnecessarily.                                                               // 513\n    //                                                                                                               // 514\n    // We only look for one such sub; if there are N apparently-identical subs                                       // 515\n    // being invalidated, we will require N matching subscribe calls to keep                                         // 516\n    // them all active.                                                                                              // 517\n    var existing = _.find(self._subscriptions, function (sub) {                                                      // 518\n      return sub.inactive && sub.name === name &&                                                                    // 519\n        EJSON.equals(sub.params, params);                                                                            // 520\n    });                                                                                                              // 521\n                                                                                                                     // 522\n    var id;                                                                                                          // 523\n    if (existing) {                                                                                                  // 524\n      id = existing.id;                                                                                              // 525\n      existing.inactive = false; // reactivate                                                                       // 526\n                                                                                                                     // 527\n      if (callbacks.onReady) {                                                                                       // 528\n        // If the sub is not already ready, replace any ready callback with the                                      // 529\n        // one provided now. (It's not really clear what users would expect for                                      // 530\n        // an onReady callback inside an autorun; the semantics we provide is                                        // 531\n        // that at the time the sub first becomes ready, we call the last                                            // 532\n        // onReady callback provided, if any.)                                                                       // 533\n        if (!existing.ready)                                                                                         // 534\n          existing.readyCallback = callbacks.onReady;                                                                // 535\n      }                                                                                                              // 536\n                                                                                                                     // 537\n      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call                                             // 538\n      // onStop with an optional error argument                                                                      // 539\n      if (callbacks.onError) {                                                                                       // 540\n        // Replace existing callback if any, so that errors aren't                                                   // 541\n        // double-reported.                                                                                          // 542\n        existing.errorCallback = callbacks.onError;                                                                  // 543\n      }                                                                                                              // 544\n                                                                                                                     // 545\n      if (callbacks.onStop) {                                                                                        // 546\n        existing.stopCallback = callbacks.onStop;                                                                    // 547\n      }                                                                                                              // 548\n    } else {                                                                                                         // 549\n      // New sub! Generate an id, save it locally, and send message.                                                 // 550\n      id = Random.id();                                                                                              // 551\n      self._subscriptions[id] = {                                                                                    // 552\n        id: id,                                                                                                      // 553\n        name: name,                                                                                                  // 554\n        params: EJSON.clone(params),                                                                                 // 555\n        inactive: false,                                                                                             // 556\n        ready: false,                                                                                                // 557\n        readyDeps: new Tracker.Dependency,                                                                           // 558\n        readyCallback: callbacks.onReady,                                                                            // 559\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                    // 560\n        errorCallback: callbacks.onError,                                                                            // 561\n        stopCallback: callbacks.onStop,                                                                              // 562\n        connection: self,                                                                                            // 563\n        remove: function() {                                                                                         // 564\n          delete this.connection._subscriptions[this.id];                                                            // 565\n          this.ready && this.readyDeps.changed();                                                                    // 566\n        },                                                                                                           // 567\n        stop: function() {                                                                                           // 568\n          this.connection._send({msg: 'unsub', id: id});                                                             // 569\n          this.remove();                                                                                             // 570\n                                                                                                                     // 571\n          if (callbacks.onStop) {                                                                                    // 572\n            callbacks.onStop();                                                                                      // 573\n          }                                                                                                          // 574\n        }                                                                                                            // 575\n      };                                                                                                             // 576\n      self._send({msg: 'sub', id: id, name: name, params: params});                                                  // 577\n    }                                                                                                                // 578\n                                                                                                                     // 579\n    // return a handle to the application.                                                                           // 580\n    var handle = {                                                                                                   // 581\n      stop: function () {                                                                                            // 582\n        if (!_.has(self._subscriptions, id))                                                                         // 583\n          return;                                                                                                    // 584\n                                                                                                                     // 585\n        self._subscriptions[id].stop();                                                                              // 586\n      },                                                                                                             // 587\n      ready: function () {                                                                                           // 588\n        // return false if we've unsubscribed.                                                                       // 589\n        if (!_.has(self._subscriptions, id))                                                                         // 590\n          return false;                                                                                              // 591\n        var record = self._subscriptions[id];                                                                        // 592\n        record.readyDeps.depend();                                                                                   // 593\n        return record.ready;                                                                                         // 594\n      },                                                                                                             // 595\n      subscriptionId: id                                                                                             // 596\n    };                                                                                                               // 597\n                                                                                                                     // 598\n    if (Tracker.active) {                                                                                            // 599\n      // We're in a reactive computation, so we'd like to unsubscribe when the                                       // 600\n      // computation is invalidated... but not if the rerun just re-subscribes                                       // 601\n      // to the same subscription!  When a rerun happens, we use onInvalidate                                        // 602\n      // as a change to mark the subscription \"inactive\" so that it can                                              // 603\n      // be reused from the rerun.  If it isn't reused, it's killed from                                             // 604\n      // an afterFlush.                                                                                              // 605\n      Tracker.onInvalidate(function (c) {                                                                            // 606\n        if (_.has(self._subscriptions, id))                                                                          // 607\n          self._subscriptions[id].inactive = true;                                                                   // 608\n                                                                                                                     // 609\n        Tracker.afterFlush(function () {                                                                             // 610\n          if (_.has(self._subscriptions, id) &&                                                                      // 611\n              self._subscriptions[id].inactive)                                                                      // 612\n            handle.stop();                                                                                           // 613\n        });                                                                                                          // 614\n      });                                                                                                            // 615\n    }                                                                                                                // 616\n                                                                                                                     // 617\n    return handle;                                                                                                   // 618\n  },                                                                                                                 // 619\n                                                                                                                     // 620\n  // options:                                                                                                        // 621\n  // - onLateError {Function(error)} called if an error was received after the ready event.                          // 622\n  //     (errors received before ready cause an error to be thrown)                                                  // 623\n  _subscribeAndWait: function (name, args, options) {                                                                // 624\n    var self = this;                                                                                                 // 625\n    var f = new Future();                                                                                            // 626\n    var ready = false;                                                                                               // 627\n    var handle;                                                                                                      // 628\n    args = args || [];                                                                                               // 629\n    args.push({                                                                                                      // 630\n      onReady: function () {                                                                                         // 631\n        ready = true;                                                                                                // 632\n        f['return']();                                                                                               // 633\n      },                                                                                                             // 634\n      onError: function (e) {                                                                                        // 635\n        if (!ready)                                                                                                  // 636\n          f['throw'](e);                                                                                             // 637\n        else                                                                                                         // 638\n          options && options.onLateError && options.onLateError(e);                                                  // 639\n      }                                                                                                              // 640\n    });                                                                                                              // 641\n                                                                                                                     // 642\n    handle = self.subscribe.apply(self, [name].concat(args));                                                        // 643\n    f.wait();                                                                                                        // 644\n    return handle;                                                                                                   // 645\n  },                                                                                                                 // 646\n                                                                                                                     // 647\n  methods: function (methods) {                                                                                      // 648\n    var self = this;                                                                                                 // 649\n    _.each(methods, function (func, name) {                                                                          // 650\n      if (typeof func !== 'function')                                                                                // 651\n        throw new Error(\"Method '\" + name + \"' must be a function\");                                                 // 652\n      if (self._methodHandlers[name])                                                                                // 653\n        throw new Error(\"A method named '\" + name + \"' is already defined\");                                         // 654\n      self._methodHandlers[name] = func;                                                                             // 655\n    });                                                                                                              // 656\n  },                                                                                                                 // 657\n                                                                                                                     // 658\n  /**                                                                                                                // 659\n   * @memberOf Meteor                                                                                                // 660\n   * @summary Invokes a method passing any number of arguments.                                                      // 661\n   * @locus Anywhere                                                                                                 // 662\n   * @param {String} name Name of method to invoke                                                                   // 663\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments                                                     // 664\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n   */                                                                                                                // 666\n  call: function (name /* .. [arguments] .. callback */) {                                                           // 667\n    // if it's a function, the last argument is the result callback,                                                 // 668\n    // not a parameter to the remote method.                                                                         // 669\n    var args = Array.prototype.slice.call(arguments, 1);                                                             // 670\n    if (args.length && typeof args[args.length - 1] === \"function\")                                                  // 671\n      var callback = args.pop();                                                                                     // 672\n    return this.apply(name, args, callback);                                                                         // 673\n  },                                                                                                                 // 674\n                                                                                                                     // 675\n  // @param options {Optional Object}                                                                                // 676\n  //   wait: Boolean - Should we wait to call this until all current methods                                         // 677\n  //                   are fully finished, and block subsequent method calls                                         // 678\n  //                   until this method is fully finished?                                                          // 679\n  //                   (does not affect methods called from within this method)                                      // 680\n  //   onResultReceived: Function - a callback to call as soon as the method                                         // 681\n  //                                result is received. the data written by                                          // 682\n  //                                the method may not yet be in the cache!                                          // 683\n  //   returnStubValue: Boolean - If true then in cases where we would have                                          // 684\n  //                              otherwise discarded the stub's return value                                        // 685\n  //                              and returned undefined, instead we go ahead                                        // 686\n  //                              and return it.  Specifically, this is any                                          // 687\n  //                              time other than when (a) we are already                                            // 688\n  //                              inside a stub or (b) we are in Node and no                                         // 689\n  //                              callback was provided.  Currently we require                                       // 690\n  //                              this flag to be explicitly passed to reduce                                        // 691\n  //                              the likelihood that stub return values will                                        // 692\n  //                              be confused with server return values; we                                          // 693\n  //                              may improve this in future.                                                        // 694\n  // @param callback {Optional Function}                                                                             // 695\n                                                                                                                     // 696\n  /**                                                                                                                // 697\n   * @memberOf Meteor                                                                                                // 698\n   * @summary Invoke a method passing an array of arguments.                                                         // 699\n   * @locus Anywhere                                                                                                 // 700\n   * @param {String} name Name of method to invoke                                                                   // 701\n   * @param {EJSONable[]} args Method arguments                                                                      // 702\n   * @param {Object} [options]                                                                                       // 703\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).        // 706\n   */                                                                                                                // 707\n  apply: function (name, args, options, callback) {                                                                  // 708\n    var self = this;                                                                                                 // 709\n                                                                                                                     // 710\n    // We were passed 3 arguments. They may be either (name, args, options)                                          // 711\n    // or (name, args, callback)                                                                                     // 712\n    if (!callback && typeof options === 'function') {                                                                // 713\n      callback = options;                                                                                            // 714\n      options = {};                                                                                                  // 715\n    }                                                                                                                // 716\n    options = options || {};                                                                                         // 717\n                                                                                                                     // 718\n    if (callback) {                                                                                                  // 719\n      // XXX would it be better form to do the binding in stream.on,                                                 // 720\n      // or caller, instead of here?                                                                                 // 721\n      // XXX improve error message (and how we report it)                                                            // 722\n      callback = Meteor.bindEnvironment(                                                                             // 723\n        callback,                                                                                                    // 724\n        \"delivering result of invoking '\" + name + \"'\"                                                               // 725\n      );                                                                                                             // 726\n    }                                                                                                                // 727\n                                                                                                                     // 728\n    // Keep our args safe from mutation (eg if we don't send the message for a                                       // 729\n    // while because of a wait method).                                                                              // 730\n    args = EJSON.clone(args);                                                                                        // 731\n                                                                                                                     // 732\n    // Lazily allocate method ID once we know that it'll be needed.                                                  // 733\n    var methodId = (function () {                                                                                    // 734\n      var id;                                                                                                        // 735\n      return function () {                                                                                           // 736\n        if (id === undefined)                                                                                        // 737\n          id = '' + (self._nextMethodId++);                                                                          // 738\n        return id;                                                                                                   // 739\n      };                                                                                                             // 740\n    })();                                                                                                            // 741\n                                                                                                                     // 742\n    var enclosing = DDP._CurrentInvocation.get();                                                                    // 743\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;                                                   // 744\n                                                                                                                     // 745\n    // Lazily generate a randomSeed, only if it is requested by the stub.                                            // 746\n    // The random streams only have utility if they're used on both the client                                       // 747\n    // and the server; if the client doesn't generate any 'random' values                                            // 748\n    // then we don't expect the server to generate any either.                                                       // 749\n    // Less commonly, the server may perform different actions from the client,                                      // 750\n    // and may in fact generate values where the client did not, but we don't                                        // 751\n    // have any client-side values to match, so even here we may as well just                                        // 752\n    // use a random seed on the server.  In that case, we don't pass the                                             // 753\n    // randomSeed to save bandwidth, and we don't even generate it to save a                                         // 754\n    // bit of CPU and to avoid consuming entropy.                                                                    // 755\n    var randomSeed = null;                                                                                           // 756\n    var randomSeedGenerator = function () {                                                                          // 757\n      if (randomSeed === null) {                                                                                     // 758\n        randomSeed = DDPCommon.makeRpcSeed(enclosing, name);                                                         // 759\n      }                                                                                                              // 760\n      return randomSeed;                                                                                             // 761\n    };                                                                                                               // 762\n                                                                                                                     // 763\n    // Run the stub, if we have one. The stub is supposed to make some                                               // 764\n    // temporary writes to the database to give the user a smooth experience                                         // 765\n    // until the actual result of executing the method comes back from the                                           // 766\n    // server (whereupon the temporary writes to the database will be reversed                                       // 767\n    // during the beginUpdate/endUpdate process.)                                                                    // 768\n    //                                                                                                               // 769\n    // Normally, we ignore the return value of the stub (even if it is an                                            // 770\n    // exception), in favor of the real return value from the server. The                                            // 771\n    // exception is if the *caller* is a stub. In that case, we're not going                                         // 772\n    // to do a RPC, so we use the return value of the stub as our return                                             // 773\n    // value.                                                                                                        // 774\n                                                                                                                     // 775\n    var stub = self._methodHandlers[name];                                                                           // 776\n    if (stub) {                                                                                                      // 777\n      var setUserId = function(userId) {                                                                             // 778\n        self.setUserId(userId);                                                                                      // 779\n      };                                                                                                             // 780\n                                                                                                                     // 781\n      var invocation = new DDPCommon.MethodInvocation({                                                              // 782\n        isSimulation: true,                                                                                          // 783\n        userId: self.userId(),                                                                                       // 784\n        setUserId: setUserId,                                                                                        // 785\n        randomSeed: function () { return randomSeedGenerator(); }                                                    // 786\n      });                                                                                                            // 787\n                                                                                                                     // 788\n      if (!alreadyInSimulation)                                                                                      // 789\n        self._saveOriginals();                                                                                       // 790\n                                                                                                                     // 791\n      try {                                                                                                          // 792\n        // Note that unlike in the corresponding server code, we never audit                                         // 793\n        // that stubs check() their arguments.                                                                       // 794\n        var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {                             // 795\n          if (Meteor.isServer) {                                                                                     // 796\n            // Because saveOriginals and retrieveOriginals aren't reentrant,                                         // 797\n            // don't allow stubs to yield.                                                                           // 798\n            return Meteor._noYieldsAllowed(function () {                                                             // 799\n              // re-clone, so that the stub can't affect our caller's values                                         // 800\n              return stub.apply(invocation, EJSON.clone(args));                                                      // 801\n            });                                                                                                      // 802\n          } else {                                                                                                   // 803\n            return stub.apply(invocation, EJSON.clone(args));                                                        // 804\n          }                                                                                                          // 805\n        });                                                                                                          // 806\n      }                                                                                                              // 807\n      catch (e) {                                                                                                    // 808\n        var exception = e;                                                                                           // 809\n      }                                                                                                              // 810\n                                                                                                                     // 811\n      if (!alreadyInSimulation)                                                                                      // 812\n        self._retrieveAndStoreOriginals(methodId());                                                                 // 813\n    }                                                                                                                // 814\n                                                                                                                     // 815\n    // If we're in a simulation, stop and return the result we have,                                                 // 816\n    // rather than going on to do an RPC. If there was no stub,                                                      // 817\n    // we'll end up returning undefined.                                                                             // 818\n    if (alreadyInSimulation) {                                                                                       // 819\n      if (callback) {                                                                                                // 820\n        callback(exception, stubReturnValue);                                                                        // 821\n        return undefined;                                                                                            // 822\n      }                                                                                                              // 823\n      if (exception)                                                                                                 // 824\n        throw exception;                                                                                             // 825\n      return stubReturnValue;                                                                                        // 826\n    }                                                                                                                // 827\n                                                                                                                     // 828\n    // If an exception occurred in a stub, and we're ignoring it                                                     // 829\n    // because we're doing an RPC and want to use what the server                                                    // 830\n    // returns instead, log it so the developer knows                                                                // 831\n    // (unless they explicitly ask to see the error).                                                                // 832\n    //                                                                                                               // 833\n    // Tests can set the 'expected' flag on an exception so it won't                                                 // 834\n    // go to log.                                                                                                    // 835\n    if (exception) {                                                                                                 // 836\n      if (options.throwStubExceptions) {                                                                             // 837\n        throw exception;                                                                                             // 838\n      } else if (!exception.expected) {                                                                              // 839\n        Meteor._debug(\"Exception while simulating the effect of invoking '\" +                                        // 840\n          name + \"'\", exception, exception.stack);                                                                   // 841\n      }                                                                                                              // 842\n    }                                                                                                                // 843\n                                                                                                                     // 844\n                                                                                                                     // 845\n    // At this point we're definitely doing an RPC, and we're going to                                               // 846\n    // return the value of the RPC to the caller.                                                                    // 847\n                                                                                                                     // 848\n    // If the caller didn't give a callback, decide what to do.                                                      // 849\n    if (!callback) {                                                                                                 // 850\n      if (Meteor.isClient) {                                                                                         // 851\n        // On the client, we don't have fibers, so we can't block. The                                               // 852\n        // only thing we can do is to return undefined and discard the                                               // 853\n        // result of the RPC. If an error occurred then print the error                                              // 854\n        // to the console.                                                                                           // 855\n        callback = function (err) {                                                                                  // 856\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\",                                              // 857\n                               err.message);                                                                         // 858\n        };                                                                                                           // 859\n      } else {                                                                                                       // 860\n        // On the server, make the function synchronous. Throw on                                                    // 861\n        // errors, return on success.                                                                                // 862\n        var future = new Future;                                                                                     // 863\n        callback = future.resolver();                                                                                // 864\n      }                                                                                                              // 865\n    }                                                                                                                // 866\n    // Send the RPC. Note that on the client, it is important that the                                               // 867\n    // stub have finished before we send the RPC, so that we know we have                                            // 868\n    // a complete list of which local documents the stub wrote.                                                      // 869\n    var message = {                                                                                                  // 870\n      msg: 'method',                                                                                                 // 871\n      method: name,                                                                                                  // 872\n      params: args,                                                                                                  // 873\n      id: methodId()                                                                                                 // 874\n    };                                                                                                               // 875\n                                                                                                                     // 876\n    // Send the randomSeed only if we used it                                                                        // 877\n    if (randomSeed !== null) {                                                                                       // 878\n      message.randomSeed = randomSeed;                                                                               // 879\n    }                                                                                                                // 880\n                                                                                                                     // 881\n    var methodInvoker = new MethodInvoker({                                                                          // 882\n      methodId: methodId(),                                                                                          // 883\n      callback: callback,                                                                                            // 884\n      connection: self,                                                                                              // 885\n      onResultReceived: options.onResultReceived,                                                                    // 886\n      wait: !!options.wait,                                                                                          // 887\n      message: message                                                                                               // 888\n    });                                                                                                              // 889\n                                                                                                                     // 890\n    if (options.wait) {                                                                                              // 891\n      // It's a wait method! Wait methods go in their own block.                                                     // 892\n      self._outstandingMethodBlocks.push(                                                                            // 893\n        {wait: true, methods: [methodInvoker]});                                                                     // 894\n    } else {                                                                                                         // 895\n      // Not a wait method. Start a new block if the previous block was a wait                                       // 896\n      // block, and add it to the last block of methods.                                                             // 897\n      if (_.isEmpty(self._outstandingMethodBlocks) ||                                                                // 898\n          _.last(self._outstandingMethodBlocks).wait)                                                                // 899\n        self._outstandingMethodBlocks.push({wait: false, methods: []});                                              // 900\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);                                             // 901\n    }                                                                                                                // 902\n                                                                                                                     // 903\n    // If we added it to the first block, send it out now.                                                           // 904\n    if (self._outstandingMethodBlocks.length === 1)                                                                  // 905\n      methodInvoker.sendMessage();                                                                                   // 906\n                                                                                                                     // 907\n    // If we're using the default callback on the server,                                                            // 908\n    // block waiting for the result.                                                                                 // 909\n    if (future) {                                                                                                    // 910\n      return future.wait();                                                                                          // 911\n    }                                                                                                                // 912\n    return options.returnStubValue ? stubReturnValue : undefined;                                                    // 913\n  },                                                                                                                 // 914\n                                                                                                                     // 915\n  // Before calling a method stub, prepare all stores to track changes and allow                                     // 916\n  // _retrieveAndStoreOriginals to get the original versions of changed                                              // 917\n  // documents.                                                                                                      // 918\n  _saveOriginals: function () {                                                                                      // 919\n    var self = this;                                                                                                 // 920\n    _.each(self._stores, function (s) {                                                                              // 921\n      s.saveOriginals();                                                                                             // 922\n    });                                                                                                              // 923\n  },                                                                                                                 // 924\n  // Retrieves the original versions of all documents modified by the stub for                                       // 925\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed                                     // 926\n  // by document) and _documentsWrittenByStub (keyed by method ID).                                                  // 927\n  _retrieveAndStoreOriginals: function (methodId) {                                                                  // 928\n    var self = this;                                                                                                 // 929\n    if (self._documentsWrittenByStub[methodId])                                                                      // 930\n      throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");                                           // 931\n                                                                                                                     // 932\n    var docsWritten = [];                                                                                            // 933\n    _.each(self._stores, function (s, collection) {                                                                  // 934\n      var originals = s.retrieveOriginals();                                                                         // 935\n      // not all stores define retrieveOriginals                                                                     // 936\n      if (!originals)                                                                                                // 937\n        return;                                                                                                      // 938\n      originals.forEach(function (doc, id) {                                                                         // 939\n        docsWritten.push({collection: collection, id: id});                                                          // 940\n        if (!_.has(self._serverDocuments, collection))                                                               // 941\n          self._serverDocuments[collection] = new MongoIDMap;                                                        // 942\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});                                        // 943\n        if (serverDoc.writtenByStubs) {                                                                              // 944\n          // We're not the first stub to write this doc. Just add our method ID                                      // 945\n          // to the record.                                                                                          // 946\n          serverDoc.writtenByStubs[methodId] = true;                                                                 // 947\n        } else {                                                                                                     // 948\n          // First stub! Save the original value and our method ID.                                                  // 949\n          serverDoc.document = doc;                                                                                  // 950\n          serverDoc.flushCallbacks = [];                                                                             // 951\n          serverDoc.writtenByStubs = {};                                                                             // 952\n          serverDoc.writtenByStubs[methodId] = true;                                                                 // 953\n        }                                                                                                            // 954\n      });                                                                                                            // 955\n    });                                                                                                              // 956\n    if (!_.isEmpty(docsWritten)) {                                                                                   // 957\n      self._documentsWrittenByStub[methodId] = docsWritten;                                                          // 958\n    }                                                                                                                // 959\n  },                                                                                                                 // 960\n                                                                                                                     // 961\n  // This is very much a private function we use to make the tests                                                   // 962\n  // take up fewer server resources after they complete.                                                             // 963\n  _unsubscribeAll: function () {                                                                                     // 964\n    var self = this;                                                                                                 // 965\n    _.each(_.clone(self._subscriptions), function (sub, id) {                                                        // 966\n      // Avoid killing the autoupdate subscription so that developers                                                // 967\n      // still get hot code pushes when writing tests.                                                               // 968\n      //                                                                                                             // 969\n      // XXX it's a hack to encode knowledge about autoupdate here,                                                  // 970\n      // but it doesn't seem worth it yet to have a special API for                                                  // 971\n      // subscriptions to preserve after unit tests.                                                                 // 972\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {                                                         // 973\n        self._subscriptions[id].stop();                                                                              // 974\n      }                                                                                                              // 975\n    });                                                                                                              // 976\n  },                                                                                                                 // 977\n                                                                                                                     // 978\n  // Sends the DDP stringification of the given message object                                                       // 979\n  _send: function (obj) {                                                                                            // 980\n    var self = this;                                                                                                 // 981\n    self._stream.send(DDPCommon.stringifyDDP(obj));                                                                  // 982\n  },                                                                                                                 // 983\n                                                                                                                     // 984\n  // We detected via DDP-level heartbeats that we've lost the                                                        // 985\n  // connection.  Unlike `disconnect` or `close`, a lost connection                                                  // 986\n  // will be automatically retried.                                                                                  // 987\n  _lostConnection: function (error) {                                                                                // 988\n    var self = this;                                                                                                 // 989\n    self._stream._lostConnection(error);                                                                             // 990\n  },                                                                                                                 // 991\n                                                                                                                     // 992\n  /**                                                                                                                // 993\n   * @summary Get the current connection status. A reactive data source.                                             // 994\n   * @locus Client                                                                                                   // 995\n   * @memberOf Meteor                                                                                                // 996\n   */                                                                                                                // 997\n  status: function (/*passthrough args*/) {                                                                          // 998\n    var self = this;                                                                                                 // 999\n    return self._stream.status.apply(self._stream, arguments);                                                       // 1000\n  },                                                                                                                 // 1001\n                                                                                                                     // 1002\n  /**                                                                                                                // 1003\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.                  // 1004\n                                                                                                                     // 1005\n  This method does nothing if the client is already connected.                                                       // 1006\n   * @locus Client                                                                                                   // 1007\n   * @memberOf Meteor                                                                                                // 1008\n   */                                                                                                                // 1009\n  reconnect: function (/*passthrough args*/) {                                                                       // 1010\n    var self = this;                                                                                                 // 1011\n    return self._stream.reconnect.apply(self._stream, arguments);                                                    // 1012\n  },                                                                                                                 // 1013\n                                                                                                                     // 1014\n  /**                                                                                                                // 1015\n   * @summary Disconnect the client from the server.                                                                 // 1016\n   * @locus Client                                                                                                   // 1017\n   * @memberOf Meteor                                                                                                // 1018\n   */                                                                                                                // 1019\n  disconnect: function (/*passthrough args*/) {                                                                      // 1020\n    var self = this;                                                                                                 // 1021\n    return self._stream.disconnect.apply(self._stream, arguments);                                                   // 1022\n  },                                                                                                                 // 1023\n                                                                                                                     // 1024\n  close: function () {                                                                                               // 1025\n    var self = this;                                                                                                 // 1026\n    return self._stream.disconnect({_permanent: true});                                                              // 1027\n  },                                                                                                                 // 1028\n                                                                                                                     // 1029\n  ///                                                                                                                // 1030\n  /// Reactive user system                                                                                           // 1031\n  ///                                                                                                                // 1032\n  userId: function () {                                                                                              // 1033\n    var self = this;                                                                                                 // 1034\n    if (self._userIdDeps)                                                                                            // 1035\n      self._userIdDeps.depend();                                                                                     // 1036\n    return self._userId;                                                                                             // 1037\n  },                                                                                                                 // 1038\n                                                                                                                     // 1039\n  setUserId: function (userId) {                                                                                     // 1040\n    var self = this;                                                                                                 // 1041\n    // Avoid invalidating dependents if setUserId is called with current value.                                      // 1042\n    if (self._userId === userId)                                                                                     // 1043\n      return;                                                                                                        // 1044\n    self._userId = userId;                                                                                           // 1045\n    if (self._userIdDeps)                                                                                            // 1046\n      self._userIdDeps.changed();                                                                                    // 1047\n  },                                                                                                                 // 1048\n                                                                                                                     // 1049\n  // Returns true if we are in a state after reconnect of waiting for subs to be                                     // 1050\n  // revived or early methods to finish their data, or we are waiting for a                                          // 1051\n  // \"wait\" method to finish.                                                                                        // 1052\n  _waitingForQuiescence: function () {                                                                               // 1053\n    var self = this;                                                                                                 // 1054\n    return (! _.isEmpty(self._subsBeingRevived) ||                                                                   // 1055\n            ! _.isEmpty(self._methodsBlockingQuiescence));                                                           // 1056\n  },                                                                                                                 // 1057\n                                                                                                                     // 1058\n  // Returns true if any method whose message has been sent to the server has                                        // 1059\n  // not yet invoked its user callback.                                                                              // 1060\n  _anyMethodsAreOutstanding: function () {                                                                           // 1061\n    var self = this;                                                                                                 // 1062\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));                                                      // 1063\n  },                                                                                                                 // 1064\n                                                                                                                     // 1065\n  _livedata_connected: function (msg) {                                                                              // 1066\n    var self = this;                                                                                                 // 1067\n                                                                                                                     // 1068\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {                                                 // 1069\n      self._heartbeat = new DDPCommon.Heartbeat({                                                                    // 1070\n        heartbeatInterval: self._heartbeatInterval,                                                                  // 1071\n        heartbeatTimeout: self._heartbeatTimeout,                                                                    // 1072\n        onTimeout: function () {                                                                                     // 1073\n          self._lostConnection(                                                                                      // 1074\n            new DDP.ConnectionError(\"DDP heartbeat timed out\"));                                                     // 1075\n        },                                                                                                           // 1076\n        sendPing: function () {                                                                                      // 1077\n          self._send({msg: 'ping'});                                                                                 // 1078\n        }                                                                                                            // 1079\n      });                                                                                                            // 1080\n      self._heartbeat.start();                                                                                       // 1081\n    }                                                                                                                // 1082\n                                                                                                                     // 1083\n    // If this is a reconnect, we'll have to reset all stores.                                                       // 1084\n    if (self._lastSessionId)                                                                                         // 1085\n      self._resetStores = true;                                                                                      // 1086\n                                                                                                                     // 1087\n    if (typeof (msg.session) === \"string\") {                                                                         // 1088\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);                                      // 1089\n      self._lastSessionId = msg.session;                                                                             // 1090\n    }                                                                                                                // 1091\n                                                                                                                     // 1092\n    if (reconnectedToPreviousSession) {                                                                              // 1093\n      // Successful reconnection -- pick up where we left off.  Note that right                                      // 1094\n      // now, this never happens: the server never connects us to a previous                                         // 1095\n      // session, because DDP doesn't provide enough data for the server to know                                     // 1096\n      // what messages the client has processed. We need to improve DDP to make                                      // 1097\n      // this possible, at which point we'll probably need more code here.                                           // 1098\n      return;                                                                                                        // 1099\n    }                                                                                                                // 1100\n                                                                                                                     // 1101\n    // Server doesn't have our data any more. Re-sync a new session.                                                 // 1102\n                                                                                                                     // 1103\n    // Forget about messages we were buffering for unknown collections. They'll                                      // 1104\n    // be resent if still relevant.                                                                                  // 1105\n    self._updatesForUnknownStores = {};                                                                              // 1106\n                                                                                                                     // 1107\n    if (self._resetStores) {                                                                                         // 1108\n      // Forget about the effects of stubs. We'll be resetting all collections                                       // 1109\n      // anyway.                                                                                                     // 1110\n      self._documentsWrittenByStub = {};                                                                             // 1111\n      self._serverDocuments = {};                                                                                    // 1112\n    }                                                                                                                // 1113\n                                                                                                                     // 1114\n    // Clear _afterUpdateCallbacks.                                                                                  // 1115\n    self._afterUpdateCallbacks = [];                                                                                 // 1116\n                                                                                                                     // 1117\n    // Mark all named subscriptions which are ready (ie, we already called the                                       // 1118\n    // ready callback) as needing to be revived.                                                                     // 1119\n    // XXX We should also block reconnect quiescence until unnamed subscriptions                                     // 1120\n    //     (eg, autopublish) are done re-publishing to avoid flicker!                                                // 1121\n    self._subsBeingRevived = {};                                                                                     // 1122\n    _.each(self._subscriptions, function (sub, id) {                                                                 // 1123\n      if (sub.ready)                                                                                                 // 1124\n        self._subsBeingRevived[id] = true;                                                                           // 1125\n    });                                                                                                              // 1126\n                                                                                                                     // 1127\n    // Arrange for \"half-finished\" methods to have their callbacks run, and                                          // 1128\n    // track methods that were sent on this connection so that we don't                                              // 1129\n    // quiesce until they are all done.                                                                              // 1130\n    //                                                                                                               // 1131\n    // Start by clearing _methodsBlockingQuiescence: methods sent before                                             // 1132\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection                                     // 1133\n    // that we drop here will be restored by the loop below.                                                         // 1134\n    self._methodsBlockingQuiescence = {};                                                                            // 1135\n    if (self._resetStores) {                                                                                         // 1136\n      _.each(self._methodInvokers, function (invoker) {                                                              // 1137\n        if (invoker.gotResult()) {                                                                                   // 1138\n          // This method already got its result, but it didn't call its callback                                     // 1139\n          // because its data didn't become visible. We did not resend the                                           // 1140\n          // method RPC. We'll call its callback when we get a full quiesce,                                         // 1141\n          // since that's as close as we'll get to \"data must be visible\".                                           // 1142\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));                                     // 1143\n        } else if (invoker.sentMessage) {                                                                            // 1144\n          // This method has been sent on this connection (maybe as a resend                                         // 1145\n          // from the last connection, maybe from onReconnect, maybe just very                                       // 1146\n          // quickly before processing the connected message).                                                       // 1147\n          //                                                                                                         // 1148\n          // We don't need to do anything special to ensure its callbacks get                                        // 1149\n          // called, but we'll count it as a method which is preventing                                              // 1150\n          // reconnect quiescence. (eg, it might be a login method that was run                                      // 1151\n          // from onReconnect, and we don't want to see flicker by seeing a                                          // 1152\n          // logged-out state.)                                                                                      // 1153\n          self._methodsBlockingQuiescence[invoker.methodId] = true;                                                  // 1154\n        }                                                                                                            // 1155\n      });                                                                                                            // 1156\n    }                                                                                                                // 1157\n                                                                                                                     // 1158\n    self._messagesBufferedUntilQuiescence = [];                                                                      // 1159\n                                                                                                                     // 1160\n    // If we're not waiting on any methods or subs, we can reset the stores and                                      // 1161\n    // call the callbacks immediately.                                                                               // 1162\n    if (!self._waitingForQuiescence()) {                                                                             // 1163\n      if (self._resetStores) {                                                                                       // 1164\n        _.each(self._stores, function (s) {                                                                          // 1165\n          s.beginUpdate(0, true);                                                                                    // 1166\n          s.endUpdate();                                                                                             // 1167\n        });                                                                                                          // 1168\n        self._resetStores = false;                                                                                   // 1169\n      }                                                                                                              // 1170\n      self._runAfterUpdateCallbacks();                                                                               // 1171\n    }                                                                                                                // 1172\n  },                                                                                                                 // 1173\n                                                                                                                     // 1174\n                                                                                                                     // 1175\n  _processOneDataMessage: function (msg, updates) {                                                                  // 1176\n    var self = this;                                                                                                 // 1177\n    // Using underscore here so as not to need to capitalize.                                                        // 1178\n    self['_process_' + msg.msg](msg, updates);                                                                       // 1179\n  },                                                                                                                 // 1180\n                                                                                                                     // 1181\n                                                                                                                     // 1182\n  _livedata_data: function (msg) {                                                                                   // 1183\n    var self = this;                                                                                                 // 1184\n                                                                                                                     // 1185\n    // collection name -> array of messages                                                                          // 1186\n    var updates = {};                                                                                                // 1187\n                                                                                                                     // 1188\n    if (self._waitingForQuiescence()) {                                                                              // 1189\n      self._messagesBufferedUntilQuiescence.push(msg);                                                               // 1190\n                                                                                                                     // 1191\n      if (msg.msg === \"nosub\")                                                                                       // 1192\n        delete self._subsBeingRevived[msg.id];                                                                       // 1193\n                                                                                                                     // 1194\n      _.each(msg.subs || [], function (subId) {                                                                      // 1195\n        delete self._subsBeingRevived[subId];                                                                        // 1196\n      });                                                                                                            // 1197\n      _.each(msg.methods || [], function (methodId) {                                                                // 1198\n        delete self._methodsBlockingQuiescence[methodId];                                                            // 1199\n      });                                                                                                            // 1200\n                                                                                                                     // 1201\n      if (self._waitingForQuiescence())                                                                              // 1202\n        return;                                                                                                      // 1203\n                                                                                                                     // 1204\n      // No methods or subs are blocking quiescence!                                                                 // 1205\n      // We'll now process and all of our buffered messages, reset all stores,                                       // 1206\n      // and apply them all at once.                                                                                 // 1207\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {                                         // 1208\n        self._processOneDataMessage(bufferedMsg, updates);                                                           // 1209\n      });                                                                                                            // 1210\n      self._messagesBufferedUntilQuiescence = [];                                                                    // 1211\n    } else {                                                                                                         // 1212\n      self._processOneDataMessage(msg, updates);                                                                     // 1213\n    }                                                                                                                // 1214\n                                                                                                                     // 1215\n    if (self._resetStores || !_.isEmpty(updates)) {                                                                  // 1216\n      // Begin a transactional update of each store.                                                                 // 1217\n      _.each(self._stores, function (s, storeName) {                                                                 // 1218\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,                                     // 1219\n                      self._resetStores);                                                                            // 1220\n      });                                                                                                            // 1221\n      self._resetStores = false;                                                                                     // 1222\n                                                                                                                     // 1223\n      _.each(updates, function (updateMessages, storeName) {                                                         // 1224\n        var store = self._stores[storeName];                                                                         // 1225\n        if (store) {                                                                                                 // 1226\n          _.each(updateMessages, function (updateMessage) {                                                          // 1227\n            store.update(updateMessage);                                                                             // 1228\n          });                                                                                                        // 1229\n        } else {                                                                                                     // 1230\n          // Nobody's listening for this data. Queue it up until                                                     // 1231\n          // someone wants it.                                                                                       // 1232\n          // XXX memory use will grow without bound if you forget to                                                 // 1233\n          // create a collection or just don't care about it... going                                                // 1234\n          // to have to do something about that.                                                                     // 1235\n          if (!_.has(self._updatesForUnknownStores, storeName))                                                      // 1236\n            self._updatesForUnknownStores[storeName] = [];                                                           // 1237\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],                                       // 1238\n                                     updateMessages);                                                                // 1239\n        }                                                                                                            // 1240\n      });                                                                                                            // 1241\n                                                                                                                     // 1242\n      // End update transaction.                                                                                     // 1243\n      _.each(self._stores, function (s) { s.endUpdate(); });                                                         // 1244\n    }                                                                                                                // 1245\n                                                                                                                     // 1246\n    self._runAfterUpdateCallbacks();                                                                                 // 1247\n  },                                                                                                                 // 1248\n                                                                                                                     // 1249\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose                                          // 1250\n  // relevant docs have been flushed, as well as dataVisible callbacks at                                            // 1251\n  // reconnect-quiescence time.                                                                                      // 1252\n  _runAfterUpdateCallbacks: function () {                                                                            // 1253\n    var self = this;                                                                                                 // 1254\n    var callbacks = self._afterUpdateCallbacks;                                                                      // 1255\n    self._afterUpdateCallbacks = [];                                                                                 // 1256\n    _.each(callbacks, function (c) {                                                                                 // 1257\n      c();                                                                                                           // 1258\n    });                                                                                                              // 1259\n  },                                                                                                                 // 1260\n                                                                                                                     // 1261\n  _pushUpdate: function (updates, collection, msg) {                                                                 // 1262\n    var self = this;                                                                                                 // 1263\n    if (!_.has(updates, collection)) {                                                                               // 1264\n      updates[collection] = [];                                                                                      // 1265\n    }                                                                                                                // 1266\n    updates[collection].push(msg);                                                                                   // 1267\n  },                                                                                                                 // 1268\n                                                                                                                     // 1269\n  _getServerDoc: function (collection, id) {                                                                         // 1270\n    var self = this;                                                                                                 // 1271\n    if (!_.has(self._serverDocuments, collection))                                                                   // 1272\n      return null;                                                                                                   // 1273\n    var serverDocsForCollection = self._serverDocuments[collection];                                                 // 1274\n    return serverDocsForCollection.get(id) || null;                                                                  // 1275\n  },                                                                                                                 // 1276\n                                                                                                                     // 1277\n  _process_added: function (msg, updates) {                                                                          // 1278\n    var self = this;                                                                                                 // 1279\n    var id = MongoID.idParse(msg.id);                                                                                // 1280\n    var serverDoc = self._getServerDoc(msg.collection, id);                                                          // 1281\n    if (serverDoc) {                                                                                                 // 1282\n      // Some outstanding stub wrote here.                                                                           // 1283\n      var isExisting = (serverDoc.document !== undefined);                                                           // 1284\n                                                                                                                     // 1285\n      serverDoc.document = msg.fields || {};                                                                         // 1286\n      serverDoc.document._id = id;                                                                                   // 1287\n                                                                                                                     // 1288\n      if (self._resetStores) {                                                                                       // 1289\n        // During reconnect the server is sending adds for existing ids.                                             // 1290\n        // Always push an update so that document stays in the store after                                           // 1291\n        // reset. Use current version of the document for this update, so                                            // 1292\n        // that stub-written values are preserved.                                                                   // 1293\n        var currentDoc = self._stores[msg.collection].getDoc(msg.id);                                                // 1294\n        if (currentDoc !== undefined)                                                                                // 1295\n          msg.fields = currentDoc;                                                                                   // 1296\n                                                                                                                     // 1297\n        self._pushUpdate(updates, msg.collection, msg);                                                              // 1298\n      } else if (isExisting) {                                                                                       // 1299\n        throw new Error(\"Server sent add for existing id: \" + msg.id);                                               // 1300\n      }                                                                                                              // 1301\n    } else {                                                                                                         // 1302\n      self._pushUpdate(updates, msg.collection, msg);                                                                // 1303\n    }                                                                                                                // 1304\n  },                                                                                                                 // 1305\n                                                                                                                     // 1306\n  _process_changed: function (msg, updates) {                                                                        // 1307\n    var self = this;                                                                                                 // 1308\n    var serverDoc = self._getServerDoc(                                                                              // 1309\n      msg.collection, MongoID.idParse(msg.id));                                                                      // 1310\n    if (serverDoc) {                                                                                                 // 1311\n      if (serverDoc.document === undefined)                                                                          // 1312\n        throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);                                        // 1313\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);                                                     // 1314\n    } else {                                                                                                         // 1315\n      self._pushUpdate(updates, msg.collection, msg);                                                                // 1316\n    }                                                                                                                // 1317\n  },                                                                                                                 // 1318\n                                                                                                                     // 1319\n  _process_removed: function (msg, updates) {                                                                        // 1320\n    var self = this;                                                                                                 // 1321\n    var serverDoc = self._getServerDoc(                                                                              // 1322\n      msg.collection, MongoID.idParse(msg.id));                                                                      // 1323\n    if (serverDoc) {                                                                                                 // 1324\n      // Some outstanding stub wrote here.                                                                           // 1325\n      if (serverDoc.document === undefined)                                                                          // 1326\n        throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);                                         // 1327\n      serverDoc.document = undefined;                                                                                // 1328\n    } else {                                                                                                         // 1329\n      self._pushUpdate(updates, msg.collection, {                                                                    // 1330\n        msg: 'removed',                                                                                              // 1331\n        collection: msg.collection,                                                                                  // 1332\n        id: msg.id                                                                                                   // 1333\n      });                                                                                                            // 1334\n    }                                                                                                                // 1335\n  },                                                                                                                 // 1336\n                                                                                                                     // 1337\n  _process_updated: function (msg, updates) {                                                                        // 1338\n    var self = this;                                                                                                 // 1339\n    // Process \"method done\" messages.                                                                               // 1340\n    _.each(msg.methods, function (methodId) {                                                                        // 1341\n      _.each(self._documentsWrittenByStub[methodId], function (written) {                                            // 1342\n        var serverDoc = self._getServerDoc(written.collection, written.id);                                          // 1343\n        if (!serverDoc)                                                                                              // 1344\n          throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));                                          // 1345\n        if (!serverDoc.writtenByStubs[methodId])                                                                     // 1346\n          throw new Error(\"Doc \" + JSON.stringify(written) +                                                         // 1347\n                          \" not written by  method \" + methodId);                                                    // 1348\n        delete serverDoc.writtenByStubs[methodId];                                                                   // 1349\n        if (_.isEmpty(serverDoc.writtenByStubs)) {                                                                   // 1350\n          // All methods whose stubs wrote this method have completed! We can                                        // 1351\n          // now copy the saved document to the database (reverting the stub's                                       // 1352\n          // change if the server did not write to this object, or applying the                                      // 1353\n          // server's writes if it did).                                                                             // 1354\n                                                                                                                     // 1355\n          // This is a fake ddp 'replace' message.  It's just for talking                                            // 1356\n          // between livedata connections and minimongo.  (We have to stringify                                      // 1357\n          // the ID because it's supposed to look like a wire message.)                                              // 1358\n          self._pushUpdate(updates, written.collection, {                                                            // 1359\n            msg: 'replace',                                                                                          // 1360\n            id: MongoID.idStringify(written.id),                                                                     // 1361\n            replace: serverDoc.document                                                                              // 1362\n          });                                                                                                        // 1363\n          // Call all flush callbacks.                                                                               // 1364\n          _.each(serverDoc.flushCallbacks, function (c) {                                                            // 1365\n            c();                                                                                                     // 1366\n          });                                                                                                        // 1367\n                                                                                                                     // 1368\n          // Delete this completed serverDocument. Don't bother to GC empty                                          // 1369\n          // IdMaps inside self._serverDocuments, since there probably aren't                                        // 1370\n          // many collections and they'll be written repeatedly.                                                     // 1371\n          self._serverDocuments[written.collection].remove(written.id);                                              // 1372\n        }                                                                                                            // 1373\n      });                                                                                                            // 1374\n      delete self._documentsWrittenByStub[methodId];                                                                 // 1375\n                                                                                                                     // 1376\n      // We want to call the data-written callback, but we can't do so until all                                     // 1377\n      // currently buffered messages are flushed.                                                                    // 1378\n      var callbackInvoker = self._methodInvokers[methodId];                                                          // 1379\n      if (!callbackInvoker)                                                                                          // 1380\n        throw new Error(\"No callback invoker for method \" + methodId);                                               // 1381\n      self._runWhenAllServerDocsAreFlushed(                                                                          // 1382\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));                                                       // 1383\n    });                                                                                                              // 1384\n  },                                                                                                                 // 1385\n                                                                                                                     // 1386\n  _process_ready: function (msg, updates) {                                                                          // 1387\n    var self = this;                                                                                                 // 1388\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect                                          // 1389\n    // until all current server documents have been flushed to the local                                             // 1390\n    // database. We can use a write fence to implement this.                                                         // 1391\n    _.each(msg.subs, function (subId) {                                                                              // 1392\n      self._runWhenAllServerDocsAreFlushed(function () {                                                             // 1393\n        var subRecord = self._subscriptions[subId];                                                                  // 1394\n        // Did we already unsubscribe?                                                                               // 1395\n        if (!subRecord)                                                                                              // 1396\n          return;                                                                                                    // 1397\n        // Did we already receive a ready message? (Oops!)                                                           // 1398\n        if (subRecord.ready)                                                                                         // 1399\n          return;                                                                                                    // 1400\n        subRecord.ready = true;                                                                                      // 1401\n        subRecord.readyCallback && subRecord.readyCallback();                                                        // 1402\n        subRecord.readyDeps.changed();                                                                               // 1403\n      });                                                                                                            // 1404\n    });                                                                                                              // 1405\n  },                                                                                                                 // 1406\n                                                                                                                     // 1407\n  // Ensures that \"f\" will be called after all documents currently in                                                // 1408\n  // _serverDocuments have been written to the local cache. f will not be called                                     // 1409\n  // if the connection is lost before then!                                                                          // 1410\n  _runWhenAllServerDocsAreFlushed: function (f) {                                                                    // 1411\n    var self = this;                                                                                                 // 1412\n    var runFAfterUpdates = function () {                                                                             // 1413\n      self._afterUpdateCallbacks.push(f);                                                                            // 1414\n    };                                                                                                               // 1415\n    var unflushedServerDocCount = 0;                                                                                 // 1416\n    var onServerDocFlush = function () {                                                                             // 1417\n      --unflushedServerDocCount;                                                                                     // 1418\n      if (unflushedServerDocCount === 0) {                                                                           // 1419\n        // This was the last doc to flush! Arrange to run f after the updates                                        // 1420\n        // have been applied.                                                                                        // 1421\n        runFAfterUpdates();                                                                                          // 1422\n      }                                                                                                              // 1423\n    };                                                                                                               // 1424\n    _.each(self._serverDocuments, function (collectionDocs) {                                                        // 1425\n      collectionDocs.forEach(function (serverDoc) {                                                                  // 1426\n        var writtenByStubForAMethodWithSentMessage = _.any(                                                          // 1427\n          serverDoc.writtenByStubs, function (dummy, methodId) {                                                     // 1428\n            var invoker = self._methodInvokers[methodId];                                                            // 1429\n            return invoker && invoker.sentMessage;                                                                   // 1430\n          });                                                                                                        // 1431\n        if (writtenByStubForAMethodWithSentMessage) {                                                                // 1432\n          ++unflushedServerDocCount;                                                                                 // 1433\n          serverDoc.flushCallbacks.push(onServerDocFlush);                                                           // 1434\n        }                                                                                                            // 1435\n      });                                                                                                            // 1436\n    });                                                                                                              // 1437\n    if (unflushedServerDocCount === 0) {                                                                             // 1438\n      // There aren't any buffered docs --- we can call f as soon as the current                                     // 1439\n      // round of updates is applied!                                                                                // 1440\n      runFAfterUpdates();                                                                                            // 1441\n    }                                                                                                                // 1442\n  },                                                                                                                 // 1443\n                                                                                                                     // 1444\n  _livedata_nosub: function (msg) {                                                                                  // 1445\n    var self = this;                                                                                                 // 1446\n                                                                                                                     // 1447\n    // First pass it through _livedata_data, which only uses it to help get                                          // 1448\n    // towards quiescence.                                                                                           // 1449\n    self._livedata_data(msg);                                                                                        // 1450\n                                                                                                                     // 1451\n    // Do the rest of our processing immediately, with no                                                            // 1452\n    // buffering-until-quiescence.                                                                                   // 1453\n                                                                                                                     // 1454\n    // we weren't subbed anyway, or we initiated the unsub.                                                          // 1455\n    if (!_.has(self._subscriptions, msg.id))                                                                         // 1456\n      return;                                                                                                        // 1457\n                                                                                                                     // 1458\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                        // 1459\n    var errorCallback = self._subscriptions[msg.id].errorCallback;                                                   // 1460\n    var stopCallback = self._subscriptions[msg.id].stopCallback;                                                     // 1461\n                                                                                                                     // 1462\n    self._subscriptions[msg.id].remove();                                                                            // 1463\n                                                                                                                     // 1464\n    var meteorErrorFromMsg = function (msgArg) {                                                                     // 1465\n      return msgArg && msgArg.error && new Meteor.Error(                                                             // 1466\n        msgArg.error.error, msgArg.error.reason, msgArg.error.details);                                              // 1467\n    }                                                                                                                // 1468\n                                                                                                                     // 1469\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback                                                                        // 1470\n    if (errorCallback && msg.error) {                                                                                // 1471\n      errorCallback(meteorErrorFromMsg(msg));                                                                        // 1472\n    }                                                                                                                // 1473\n                                                                                                                     // 1474\n    if (stopCallback) {                                                                                              // 1475\n      stopCallback(meteorErrorFromMsg(msg));                                                                         // 1476\n    }                                                                                                                // 1477\n  },                                                                                                                 // 1478\n                                                                                                                     // 1479\n  _process_nosub: function () {                                                                                      // 1480\n    // This is called as part of the \"buffer until quiescence\" process, but                                          // 1481\n    // nosub's effect is always immediate. It only goes in the buffer at all                                         // 1482\n    // because it's possible for a nosub to be the thing that triggers                                               // 1483\n    // quiescence, if we were waiting for a sub to be revived and it dies                                            // 1484\n    // instead.                                                                                                      // 1485\n  },                                                                                                                 // 1486\n                                                                                                                     // 1487\n  _livedata_result: function (msg) {                                                                                 // 1488\n    // id, result or error. error has error (code), reason, details                                                  // 1489\n                                                                                                                     // 1490\n    var self = this;                                                                                                 // 1491\n                                                                                                                     // 1492\n    // find the outstanding request                                                                                  // 1493\n    // should be O(1) in nearly all realistic use cases                                                              // 1494\n    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                                  // 1495\n      Meteor._debug(\"Received method result but no methods outstanding\");                                            // 1496\n      return;                                                                                                        // 1497\n    }                                                                                                                // 1498\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;                                               // 1499\n    var m;                                                                                                           // 1500\n    for (var i = 0; i < currentMethodBlock.length; i++) {                                                            // 1501\n      m = currentMethodBlock[i];                                                                                     // 1502\n      if (m.methodId === msg.id)                                                                                     // 1503\n        break;                                                                                                       // 1504\n    }                                                                                                                // 1505\n                                                                                                                     // 1506\n    if (!m) {                                                                                                        // 1507\n      Meteor._debug(\"Can't match method response to original method call\", msg);                                     // 1508\n      return;                                                                                                        // 1509\n    }                                                                                                                // 1510\n                                                                                                                     // 1511\n    // Remove from current method block. This may leave the block empty, but we                                      // 1512\n    // don't move on to the next block until the callback has been delivered, in                                     // 1513\n    // _outstandingMethodFinished.                                                                                   // 1514\n    currentMethodBlock.splice(i, 1);                                                                                 // 1515\n                                                                                                                     // 1516\n    if (_.has(msg, 'error')) {                                                                                       // 1517\n      m.receiveResult(new Meteor.Error(                                                                              // 1518\n        msg.error.error, msg.error.reason,                                                                           // 1519\n        msg.error.details));                                                                                         // 1520\n    } else {                                                                                                         // 1521\n      // msg.result may be undefined if the method didn't return a                                                   // 1522\n      // value                                                                                                       // 1523\n      m.receiveResult(undefined, msg.result);                                                                        // 1524\n    }                                                                                                                // 1525\n  },                                                                                                                 // 1526\n                                                                                                                     // 1527\n  // Called by MethodInvoker after a method's callback is invoked.  If this was                                      // 1528\n  // the last outstanding method in the current block, runs the next block. If                                       // 1529\n  // there are no more methods, consider accepting a hot code push.                                                  // 1530\n  _outstandingMethodFinished: function () {                                                                          // 1531\n    var self = this;                                                                                                 // 1532\n    if (self._anyMethodsAreOutstanding())                                                                            // 1533\n      return;                                                                                                        // 1534\n                                                                                                                     // 1535\n    // No methods are outstanding. This should mean that the first block of                                          // 1536\n    // methods is empty. (Or it might not exist, if this was a method that                                           // 1537\n    // half-finished before disconnect/reconnect.)                                                                   // 1538\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {                                                                // 1539\n      var firstBlock = self._outstandingMethodBlocks.shift();                                                        // 1540\n      if (! _.isEmpty(firstBlock.methods))                                                                           // 1541\n        throw new Error(\"No methods outstanding but nonempty block: \" +                                              // 1542\n                        JSON.stringify(firstBlock));                                                                 // 1543\n                                                                                                                     // 1544\n      // Send the outstanding methods now in the first block.                                                        // 1545\n      if (!_.isEmpty(self._outstandingMethodBlocks))                                                                 // 1546\n        self._sendOutstandingMethods();                                                                              // 1547\n    }                                                                                                                // 1548\n                                                                                                                     // 1549\n    // Maybe accept a hot code push.                                                                                 // 1550\n    self._maybeMigrate();                                                                                            // 1551\n  },                                                                                                                 // 1552\n                                                                                                                     // 1553\n  // Sends messages for all the methods in the first block in                                                        // 1554\n  // _outstandingMethodBlocks.                                                                                       // 1555\n  _sendOutstandingMethods: function() {                                                                              // 1556\n    var self = this;                                                                                                 // 1557\n    if (_.isEmpty(self._outstandingMethodBlocks))                                                                    // 1558\n      return;                                                                                                        // 1559\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {                                                  // 1560\n      m.sendMessage();                                                                                               // 1561\n    });                                                                                                              // 1562\n  },                                                                                                                 // 1563\n                                                                                                                     // 1564\n  _livedata_error: function (msg) {                                                                                  // 1565\n    Meteor._debug(\"Received error from server: \", msg.reason);                                                       // 1566\n    if (msg.offendingMessage)                                                                                        // 1567\n      Meteor._debug(\"For: \", msg.offendingMessage);                                                                  // 1568\n  },                                                                                                                 // 1569\n                                                                                                                     // 1570\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {                                                 // 1571\n    var self = this;                                                                                                 // 1572\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;                                                  // 1573\n    self._outstandingMethodBlocks = [];                                                                              // 1574\n                                                                                                                     // 1575\n    self.onReconnect();                                                                                              // 1576\n                                                                                                                     // 1577\n    if (_.isEmpty(oldOutstandingMethodBlocks))                                                                       // 1578\n      return;                                                                                                        // 1579\n                                                                                                                     // 1580\n    // We have at least one block worth of old outstanding methods to try                                            // 1581\n    // again. First: did onReconnect actually send anything? If not, we just                                         // 1582\n    // restore all outstanding methods and run the first block.                                                      // 1583\n    if (_.isEmpty(self._outstandingMethodBlocks)) {                                                                  // 1584\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;                                                    // 1585\n      self._sendOutstandingMethods();                                                                                // 1586\n      return;                                                                                                        // 1587\n    }                                                                                                                // 1588\n                                                                                                                     // 1589\n    // OK, there are blocks on both sides. Special case: merge the last block of                                     // 1590\n    // the reconnect methods with the first block of the original methods, if                                        // 1591\n    // neither of them are \"wait\" blocks.                                                                            // 1592\n    if (!_.last(self._outstandingMethodBlocks).wait &&                                                               // 1593\n        !oldOutstandingMethodBlocks[0].wait) {                                                                       // 1594\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {                                                   // 1595\n        _.last(self._outstandingMethodBlocks).methods.push(m);                                                       // 1596\n                                                                                                                     // 1597\n        // If this \"last block\" is also the first block, send the message.                                           // 1598\n        if (self._outstandingMethodBlocks.length === 1)                                                              // 1599\n          m.sendMessage();                                                                                           // 1600\n      });                                                                                                            // 1601\n                                                                                                                     // 1602\n      oldOutstandingMethodBlocks.shift();                                                                            // 1603\n    }                                                                                                                // 1604\n                                                                                                                     // 1605\n    // Now add the rest of the original blocks on.                                                                   // 1606\n    _.each(oldOutstandingMethodBlocks, function (block) {                                                            // 1607\n      self._outstandingMethodBlocks.push(block);                                                                     // 1608\n    });                                                                                                              // 1609\n  },                                                                                                                 // 1610\n                                                                                                                     // 1611\n  // We can accept a hot code push if there are no methods in flight.                                                // 1612\n  _readyToMigrate: function() {                                                                                      // 1613\n    var self = this;                                                                                                 // 1614\n    return _.isEmpty(self._methodInvokers);                                                                          // 1615\n  },                                                                                                                 // 1616\n                                                                                                                     // 1617\n  // If we were blocking a migration, see if it's now possible to continue.                                          // 1618\n  // Call whenever the set of outstanding/blocked methods shrinks.                                                   // 1619\n  _maybeMigrate: function () {                                                                                       // 1620\n    var self = this;                                                                                                 // 1621\n    if (self._retryMigrate && self._readyToMigrate()) {                                                              // 1622\n      self._retryMigrate();                                                                                          // 1623\n      self._retryMigrate = null;                                                                                     // 1624\n    }                                                                                                                // 1625\n  }                                                                                                                  // 1626\n});                                                                                                                  // 1627\n                                                                                                                     // 1628\nLivedataTest.Connection = Connection;                                                                                // 1629\n                                                                                                                     // 1630\n// @param url {String} URL to Meteor app,                                                                            // 1631\n//     e.g.:                                                                                                         // 1632\n//     \"subdomain.meteor.com\",                                                                                       // 1633\n//     \"http://subdomain.meteor.com\",                                                                                // 1634\n//     \"/\",                                                                                                          // 1635\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"                                                                // 1636\n                                                                                                                     // 1637\n/**                                                                                                                  // 1638\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n * @locus Anywhere                                                                                                   // 1640\n * @param {String} url The URL of another Meteor application.                                                        // 1641\n */                                                                                                                  // 1642\nDDP.connect = function (url, options) {                                                                              // 1643\n  var ret = new Connection(url, options);                                                                            // 1644\n  allConnections.push(ret); // hack. see below.                                                                      // 1645\n  return ret;                                                                                                        // 1646\n};                                                                                                                   // 1647\n                                                                                                                     // 1648\n// Hack for `spiderable` package: a way to see if the page is done                                                   // 1649\n// loading all the data it needs.                                                                                    // 1650\n//                                                                                                                   // 1651\nallConnections = [];                                                                                                 // 1652\nDDP._allSubscriptionsReady = function () {                                                                           // 1653\n  return _.all(allConnections, function (conn) {                                                                     // 1654\n    return _.all(conn._subscriptions, function (sub) {                                                               // 1655\n      return sub.ready;                                                                                              // 1656\n    });                                                                                                              // 1657\n  });                                                                                                                // 1658\n};                                                                                                                   // 1659\n                                                                                                                     // 1660\n///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['ddp-client'] = {}, {\n  DDP: DDP,\n  LivedataTest: LivedataTest\n});\n\n})();\n","servePath":"/packages/ddp-client.js","sourceMap":{"version":3,"sources":["/packages/ddp-client/namespace.js","/packages/ddp-client/id_map.js","/packages/ddp-client/stream_client_nodejs.js","/packages/ddp-client/stream_client_common.js","/packages/ddp-client/livedata_common.js","/packages/ddp-client/random_stream.js","/packages/ddp-client/livedata_connection.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;;;;;;;;AC3MA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2H;;;;;;;;;;;;;;;;;;AC1QA;AACA;AACA;AACA;AACA;AACA;AACA,yH;;;;;;;;;;;;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0H;;;;;;;;;;;;;;;;;;ACTA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,4H","file":"/packages/ddp-client.js","sourcesContent":["/**\n * @namespace DDP\n * @summary Namespace for DDP-related methods/classes.\n */\nDDP          = {};\nLivedataTest = {};\n","MongoIDMap = function () {\n  var self = this;\n  IdMap.call(self, MongoID.idStringify, MongoID.idParse);\n};\n\nMeteor._inherits(MongoIDMap, IdMap);\n","// @param endpoint {String} URL to Meteor app\n//   \"http://subdomain.meteor.com/\" or \"/\" or\n//   \"ddp+sockjs://foo-**.meteor.com/sockjs\"\n//\n// We do some rewriting of the URL to eventually make it \"ws://\" or \"wss://\",\n// whatever was passed in.  At the very least, what Meteor.absoluteUrl() returns\n// us should work.\n//\n// We don't do any heartbeating. (The logic that did this in sockjs was removed,\n// because it used a built-in sockjs mechanism. We could do it with WebSocket\n// ping frames or with DDP-level messages.)\nLivedataTest.ClientStream = function (endpoint, options) {\n  var self = this;\n  options = options || {};\n\n  self.options = _.extend({\n    retry: true\n  }, options);\n\n  self.client = null;  // created in _launchConnection\n  self.endpoint = endpoint;\n\n  self.headers = self.options.headers || {};\n  self.npmFayeOptions = self.options.npmFayeOptions || {};\n\n  self._initCommon(self.options);\n\n  //// Kickoff!\n  self._launchConnection();\n};\n\n_.extend(LivedataTest.ClientStream.prototype, {\n\n  // data is a utf8 string. Data sent while not connected is dropped on\n  // the floor, and it is up the user of this API to retransmit lost\n  // messages on 'reset'\n  send: function (data) {\n    var self = this;\n    if (self.currentStatus.connected) {\n      self.client.send(data);\n    }\n  },\n\n  // Changes where this connection points\n  _changeUrl: function (url) {\n    var self = this;\n    self.endpoint = url;\n  },\n\n  _onConnect: function (client) {\n    var self = this;\n\n    if (client !== self.client) {\n      // This connection is not from the last call to _launchConnection.\n      // But _launchConnection calls _cleanup which closes previous connections.\n      // It's our belief that this stifles future 'open' events, but maybe\n      // we are wrong?\n      throw new Error(\"Got open from inactive client \" + !!self.client);\n    }\n\n    if (self._forcedToDisconnect) {\n      // We were asked to disconnect between trying to open the connection and\n      // actually opening it. Let's just pretend this never happened.\n      self.client.close();\n      self.client = null;\n      return;\n    }\n\n    if (self.currentStatus.connected) {\n      // We already have a connection. It must have been the case that we\n      // started two parallel connection attempts (because we wanted to\n      // 'reconnect now' on a hanging connection and we had no way to cancel the\n      // connection attempt.) But this shouldn't happen (similarly to the client\n      // !== self.client check above).\n      throw new Error(\"Two parallel connections?\");\n    }\n\n    self._clearConnectionTimer();\n\n    // update status\n    self.currentStatus.status = \"connected\";\n    self.currentStatus.connected = true;\n    self.currentStatus.retryCount = 0;\n    self.statusChanged();\n\n    // fire resets. This must come after status change so that clients\n    // can call send from within a reset callback.\n    _.each(self.eventCallbacks.reset, function (callback) { callback(); });\n  },\n\n  _cleanup: function (maybeError) {\n    var self = this;\n\n    self._clearConnectionTimer();\n    if (self.client) {\n      var client = self.client;\n      self.client = null;\n      client.close();\n\n      _.each(self.eventCallbacks.disconnect, function (callback) {\n        callback(maybeError);\n      });\n    }\n  },\n\n  _clearConnectionTimer: function () {\n    var self = this;\n\n    if (self.connectionTimer) {\n      clearTimeout(self.connectionTimer);\n      self.connectionTimer = null;\n    }\n  },\n\n  _getProxyUrl: function (targetUrl) {\n    var self = this;\n    // Similar to code in tools/http-helpers.js.\n    var proxy = process.env.HTTP_PROXY || process.env.http_proxy || null;\n    // if we're going to a secure url, try the https_proxy env variable first.\n    if (targetUrl.match(/^wss:/)) {\n      proxy = process.env.HTTPS_PROXY || process.env.https_proxy || proxy;\n    }\n    return proxy;\n  },\n\n  _launchConnection: function () {\n    var self = this;\n    self._cleanup(); // cleanup the old socket, if there was one.\n\n    // Since server-to-server DDP is still an experimental feature, we only\n    // require the module if we actually create a server-to-server\n    // connection.\n    var FayeWebSocket = Npm.require('faye-websocket');\n    var deflate = Npm.require('permessage-deflate');\n\n    var targetUrl = toWebsocketUrl(self.endpoint);\n    var fayeOptions = {\n      headers: self.headers,\n      extensions: [deflate]\n    };\n    fayeOptions = _.extend(fayeOptions, self.npmFayeOptions);\n    var proxyUrl = self._getProxyUrl(targetUrl);\n    if (proxyUrl) {\n      fayeOptions.proxy = { origin: proxyUrl };\n    };\n\n    // We would like to specify 'ddp' as the subprotocol here. The npm module we\n    // used to use as a client would fail the handshake if we ask for a\n    // subprotocol and the server doesn't send one back (and sockjs doesn't).\n    // Faye doesn't have that behavior; it's unclear from reading RFC 6455 if\n    // Faye is erroneous or not.  So for now, we don't specify protocols.\n    var subprotocols = [];\n\n    var client = self.client = new FayeWebSocket.Client(\n      targetUrl, subprotocols, fayeOptions);\n\n    self._clearConnectionTimer();\n    self.connectionTimer = Meteor.setTimeout(\n      function () {\n        self._lostConnection(\n          new DDP.ConnectionError(\"DDP connection timed out\"));\n      },\n      self.CONNECT_TIMEOUT);\n\n    self.client.on('open', Meteor.bindEnvironment(function () {\n      return self._onConnect(client);\n    }, \"stream connect callback\"));\n\n    var clientOnIfCurrent = function (event, description, f) {\n      self.client.on(event, Meteor.bindEnvironment(function () {\n        // Ignore events from any connection we've already cleaned up.\n        if (client !== self.client)\n          return;\n        f.apply(this, arguments);\n      }, description));\n    };\n\n    clientOnIfCurrent('error', 'stream error callback', function (error) {\n      if (!self.options._dontPrintErrors)\n        Meteor._debug(\"stream error\", error.message);\n\n      // Faye's 'error' object is not a JS error (and among other things,\n      // doesn't stringify well). Convert it to one.\n      self._lostConnection(new DDP.ConnectionError(error.message));\n    });\n\n\n    clientOnIfCurrent('close', 'stream close callback', function () {\n      self._lostConnection();\n    });\n\n\n    clientOnIfCurrent('message', 'stream message callback', function (message) {\n      // Ignore binary frames, where message.data is a Buffer\n      if (typeof message.data !== \"string\")\n        return;\n\n      _.each(self.eventCallbacks.message, function (callback) {\n        callback(message.data);\n      });\n    });\n  }\n});\n","// XXX from Underscore.String (http://epeli.github.com/underscore.string/)\nvar startsWith = function(str, starts) {\n  return str.length >= starts.length &&\n    str.substring(0, starts.length) === starts;\n};\nvar endsWith = function(str, ends) {\n  return str.length >= ends.length &&\n    str.substring(str.length - ends.length) === ends;\n};\n\n// @param url {String} URL to Meteor app, eg:\n//   \"/\" or \"madewith.meteor.com\" or \"https://foo.meteor.com\"\n//   or \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n// @returns {String} URL to the endpoint with the specific scheme and subPath, e.g.\n// for scheme \"http\" and subPath \"sockjs\"\n//   \"http://subdomain.meteor.com/sockjs\" or \"/sockjs\"\n//   or \"https://ddp--1234-foo.meteor.com/sockjs\"\nvar translateUrl =  function(url, newSchemeBase, subPath) {\n  if (! newSchemeBase) {\n    newSchemeBase = \"http\";\n  }\n\n  var ddpUrlMatch = url.match(/^ddp(i?)\\+sockjs:\\/\\//);\n  var httpUrlMatch = url.match(/^http(s?):\\/\\//);\n  var newScheme;\n  if (ddpUrlMatch) {\n    // Remove scheme and split off the host.\n    var urlAfterDDP = url.substr(ddpUrlMatch[0].length);\n    newScheme = ddpUrlMatch[1] === \"i\" ? newSchemeBase : newSchemeBase + \"s\";\n    var slashPos = urlAfterDDP.indexOf('/');\n    var host =\n          slashPos === -1 ? urlAfterDDP : urlAfterDDP.substr(0, slashPos);\n    var rest = slashPos === -1 ? '' : urlAfterDDP.substr(slashPos);\n\n    // In the host (ONLY!), change '*' characters into random digits. This\n    // allows different stream connections to connect to different hostnames\n    // and avoid browser per-hostname connection limits.\n    host = host.replace(/\\*/g, function () {\n      return Math.floor(Random.fraction()*10);\n    });\n\n    return newScheme + '://' + host + rest;\n  } else if (httpUrlMatch) {\n    newScheme = !httpUrlMatch[1] ? newSchemeBase : newSchemeBase + \"s\";\n    var urlAfterHttp = url.substr(httpUrlMatch[0].length);\n    url = newScheme + \"://\" + urlAfterHttp;\n  }\n\n  // Prefix FQDNs but not relative URLs\n  if (url.indexOf(\"://\") === -1 && !startsWith(url, \"/\")) {\n    url = newSchemeBase + \"://\" + url;\n  }\n\n  // XXX This is not what we should be doing: if I have a site\n  // deployed at \"/foo\", then DDP.connect(\"/\") should actually connect\n  // to \"/\", not to \"/foo\". \"/\" is an absolute path. (Contrast: if\n  // deployed at \"/foo\", it would be reasonable for DDP.connect(\"bar\")\n  // to connect to \"/foo/bar\").\n  //\n  // We should make this properly honor absolute paths rather than\n  // forcing the path to be relative to the site root. Simultaneously,\n  // we should set DDP_DEFAULT_CONNECTION_URL to include the site\n  // root. See also client_convenience.js #RationalizingRelativeDDPURLs\n  url = Meteor._relativeToSiteRootUrl(url);\n\n  if (endsWith(url, \"/\"))\n    return url + subPath;\n  else\n    return url + \"/\" + subPath;\n};\n\ntoSockjsUrl = function (url) {\n  return translateUrl(url, \"http\", \"sockjs\");\n};\n\ntoWebsocketUrl = function (url) {\n  var ret = translateUrl(url, \"ws\", \"websocket\");\n  return ret;\n};\n\nLivedataTest.toSockjsUrl = toSockjsUrl;\n\n \n_.extend(LivedataTest.ClientStream.prototype, {\n\n  // Register for callbacks.\n  on: function (name, callback) {\n    var self = this;\n\n    if (name !== 'message' && name !== 'reset' && name !== 'disconnect')\n      throw new Error(\"unknown event type: \" + name);\n\n    if (!self.eventCallbacks[name])\n      self.eventCallbacks[name] = [];\n    self.eventCallbacks[name].push(callback);\n  },\n\n\n  _initCommon: function (options) {\n    var self = this;\n    options = options || {};\n\n    //// Constants\n\n    // how long to wait until we declare the connection attempt\n    // failed.\n    self.CONNECT_TIMEOUT = options.connectTimeoutMs || 10000;\n\n    self.eventCallbacks = {}; // name -> [callback]\n\n    self._forcedToDisconnect = false;\n\n    //// Reactive status\n    self.currentStatus = {\n      status: \"connecting\",\n      connected: false,\n      retryCount: 0\n    };\n\n\n    self.statusListeners = typeof Tracker !== 'undefined' && new Tracker.Dependency;\n    self.statusChanged = function () {\n      if (self.statusListeners)\n        self.statusListeners.changed();\n    };\n\n    //// Retry logic\n    self._retry = new Retry;\n    self.connectionTimer = null;\n\n  },\n\n  // Trigger a reconnect.\n  reconnect: function (options) {\n    var self = this;\n    options = options || {};\n\n    if (options.url) {\n      self._changeUrl(options.url);\n    }\n\n    if (options._sockjsOptions) {\n      self.options._sockjsOptions = options._sockjsOptions;\n    }\n\n    if (self.currentStatus.connected) {\n      if (options._force || options.url) {\n        // force reconnect.\n        self._lostConnection(new DDP.ForcedReconnectError);\n      } // else, noop.\n      return;\n    }\n\n    // if we're mid-connection, stop it.\n    if (self.currentStatus.status === \"connecting\") {\n      // Pretend it's a clean close.\n      self._lostConnection();\n    }\n\n    self._retry.clear();\n    self.currentStatus.retryCount -= 1; // don't count manual retries\n    self._retryNow();\n  },\n\n  disconnect: function (options) {\n    var self = this;\n    options = options || {};\n\n    // Failed is permanent. If we're failed, don't let people go back\n    // online by calling 'disconnect' then 'reconnect'.\n    if (self._forcedToDisconnect)\n      return;\n\n    // If _permanent is set, permanently disconnect a stream. Once a stream\n    // is forced to disconnect, it can never reconnect. This is for\n    // error cases such as ddp version mismatch, where trying again\n    // won't fix the problem.\n    if (options._permanent) {\n      self._forcedToDisconnect = true;\n    }\n\n    self._cleanup();\n    self._retry.clear();\n\n    self.currentStatus = {\n      status: (options._permanent ? \"failed\" : \"offline\"),\n      connected: false,\n      retryCount: 0\n    };\n\n    if (options._permanent && options._error)\n      self.currentStatus.reason = options._error;\n\n    self.statusChanged();\n  },\n\n  // maybeError is set unless it's a clean protocol-level close.\n  _lostConnection: function (maybeError) {\n    var self = this;\n\n    self._cleanup(maybeError);\n    self._retryLater(maybeError); // sets status. no need to do it here.\n  },\n\n  // fired when we detect that we've gone online. try to reconnect\n  // immediately.\n  _online: function () {\n    // if we've requested to be offline by disconnecting, don't reconnect.\n    if (this.currentStatus.status != \"offline\")\n      this.reconnect();\n  },\n\n  _retryLater: function (maybeError) {\n    var self = this;\n\n    var timeout = 0;\n    if (self.options.retry ||\n        (maybeError && maybeError.errorType === \"DDP.ForcedReconnectError\")) {\n      timeout = self._retry.retryLater(\n        self.currentStatus.retryCount,\n        _.bind(self._retryNow, self)\n      );\n      self.currentStatus.status = \"waiting\";\n      self.currentStatus.retryTime = (new Date()).getTime() + timeout;\n    } else {\n      self.currentStatus.status = \"failed\";\n      delete self.currentStatus.retryTime;\n    }\n\n    self.currentStatus.connected = false;\n    self.statusChanged();\n  },\n\n  _retryNow: function () {\n    var self = this;\n\n    if (self._forcedToDisconnect)\n      return;\n\n    self.currentStatus.retryCount += 1;\n    self.currentStatus.status = \"connecting\";\n    self.currentStatus.connected = false;\n    delete self.currentStatus.retryTime;\n    self.statusChanged();\n\n    self._launchConnection();\n  },\n\n\n  // Get current status. Reactive.\n  status: function () {\n    var self = this;\n    if (self.statusListeners)\n      self.statusListeners.depend();\n    return self.currentStatus;\n  }\n});\n\nDDP.ConnectionError = Meteor.makeErrorType(\n  \"DDP.ConnectionError\", function (message) {\n    var self = this;\n    self.message = message;\n});\n\nDDP.ForcedReconnectError = Meteor.makeErrorType(\n  \"DDP.ForcedReconnectError\", function () {});\n","LivedataTest.SUPPORTED_DDP_VERSIONS = DDPCommon.SUPPORTED_DDP_VERSIONS;\n\n// This is private but it's used in a few places. accounts-base uses\n// it to get the current user. Meteor.setTimeout and friends clear\n// it. We can probably find a better way to factor this.\nDDP._CurrentInvocation = new Meteor.EnvironmentVariable;\n","// Returns the named sequence of pseudo-random values.\n// The scope will be DDP._CurrentInvocation.get(), so the stream will produce\n// consistent values for method calls on the client and server.\nDDP.randomStream = function (name) {\n  var scope = DDP._CurrentInvocation.get();\n  return DDPCommon.RandomStream.get(scope, name);\n};\n\n\n","if (Meteor.isServer) {\n  var path = Npm.require('path');\n  var Fiber = Npm.require('fibers');\n  var Future = Npm.require(path.join('fibers', 'future'));\n}\n\n// @param url {String|Object} URL to Meteor app,\n//   or an object as a test hook (see code)\n// Options:\n//   reloadWithOutstanding: is it OK to reload if there are outstanding methods?\n//   headers: extra headers to send on the websockets connection, for\n//     server-to-server DDP only\n//   _sockjsOptions: Specifies options to pass through to the sockjs client\n//   onDDPNegotiationVersionFailure: callback when version negotiation fails.\n//\n// XXX There should be a way to destroy a DDP connection, causing all\n// outstanding method calls to fail.\n//\n// XXX Our current way of handling failure and reconnection is great\n// for an app (where we want to tolerate being disconnected as an\n// expect state, and keep trying forever to reconnect) but cumbersome\n// for something like a command line tool that wants to make a\n// connection, call a method, and print an error if connection\n// fails. We should have better usability in the latter case (while\n// still transparently reconnecting if it's just a transient failure\n// or the server migrating us).\nvar Connection = function (url, options) {\n  var self = this;\n  options = _.extend({\n    onConnected: function () {},\n    onDDPVersionNegotiationFailure: function (description) {\n      Meteor._debug(description);\n    },\n    heartbeatInterval: 17500,\n    heartbeatTimeout: 15000,\n    npmFayeOptions: {},\n    // These options are only for testing.\n    reloadWithOutstanding: false,\n    supportedDDPVersions: DDPCommon.SUPPORTED_DDP_VERSIONS,\n    retry: true,\n    respondToPings: true\n  }, options);\n\n  // If set, called when we reconnect, queuing method calls _before_ the\n  // existing outstanding ones. This is the only data member that is part of the\n  // public API!\n  self.onReconnect = null;\n\n  // as a test hook, allow passing a stream instead of a url.\n  if (typeof url === \"object\") {\n    self._stream = url;\n  } else {\n    self._stream = new LivedataTest.ClientStream(url, {\n      retry: options.retry,\n      headers: options.headers,\n      _sockjsOptions: options._sockjsOptions,\n      // Used to keep some tests quiet, or for other cases in which\n      // the right thing to do with connection errors is to silently\n      // fail (e.g. sending package usage stats). At some point we\n      // should have a real API for handling client-stream-level\n      // errors.\n      _dontPrintErrors: options._dontPrintErrors,\n      connectTimeoutMs: options.connectTimeoutMs,\n      npmFayeOptions: options.npmFayeOptions\n    });\n  }\n\n  self._lastSessionId = null;\n  self._versionSuggestion = null;  // The last proposed DDP version.\n  self._version = null;   // The DDP version agreed on by client and server.\n  self._stores = {}; // name -> object with methods\n  self._methodHandlers = {}; // name -> func\n  self._nextMethodId = 1;\n  self._supportedDDPVersions = options.supportedDDPVersions;\n\n  self._heartbeatInterval = options.heartbeatInterval;\n  self._heartbeatTimeout = options.heartbeatTimeout;\n\n  // Tracks methods which the user has tried to call but which have not yet\n  // called their user callback (ie, they are waiting on their result or for all\n  // of their writes to be written to the local cache). Map from method ID to\n  // MethodInvoker object.\n  self._methodInvokers = {};\n\n  // Tracks methods which the user has called but whose result messages have not\n  // arrived yet.\n  //\n  // _outstandingMethodBlocks is an array of blocks of methods. Each block\n  // represents a set of methods that can run at the same time. The first block\n  // represents the methods which are currently in flight; subsequent blocks\n  // must wait for previous blocks to be fully finished before they can be sent\n  // to the server.\n  //\n  // Each block is an object with the following fields:\n  // - methods: a list of MethodInvoker objects\n  // - wait: a boolean; if true, this block had a single method invoked with\n  //         the \"wait\" option\n  //\n  // There will never be adjacent blocks with wait=false, because the only thing\n  // that makes methods need to be serialized is a wait method.\n  //\n  // Methods are removed from the first block when their \"result\" is\n  // received. The entire first block is only removed when all of the in-flight\n  // methods have received their results (so the \"methods\" list is empty) *AND*\n  // all of the data written by those methods are visible in the local cache. So\n  // it is possible for the first block's methods list to be empty, if we are\n  // still waiting for some objects to quiesce.\n  //\n  // Example:\n  //  _outstandingMethodBlocks = [\n  //    {wait: false, methods: []},\n  //    {wait: true, methods: [<MethodInvoker for 'login'>]},\n  //    {wait: false, methods: [<MethodInvoker for 'foo'>,\n  //                            <MethodInvoker for 'bar'>]}]\n  // This means that there were some methods which were sent to the server and\n  // which have returned their results, but some of the data written by\n  // the methods may not be visible in the local cache. Once all that data is\n  // visible, we will send a 'login' method. Once the login method has returned\n  // and all the data is visible (including re-running subs if userId changes),\n  // we will send the 'foo' and 'bar' methods in parallel.\n  self._outstandingMethodBlocks = [];\n\n  // method ID -> array of objects with keys 'collection' and 'id', listing\n  // documents written by a given method's stub. keys are associated with\n  // methods whose stub wrote at least one document, and whose data-done message\n  // has not yet been received.\n  self._documentsWrittenByStub = {};\n  // collection -> IdMap of \"server document\" object. A \"server document\" has:\n  // - \"document\": the version of the document according the\n  //   server (ie, the snapshot before a stub wrote it, amended by any changes\n  //   received from the server)\n  //   It is undefined if we think the document does not exist\n  // - \"writtenByStubs\": a set of method IDs whose stubs wrote to the document\n  //   whose \"data done\" messages have not yet been processed\n  self._serverDocuments = {};\n\n  // Array of callbacks to be called after the next update of the local\n  // cache. Used for:\n  //  - Calling methodInvoker.dataVisible and sub ready callbacks after\n  //    the relevant data is flushed.\n  //  - Invoking the callbacks of \"half-finished\" methods after reconnect\n  //    quiescence. Specifically, methods whose result was received over the old\n  //    connection (so we don't re-send it) but whose data had not been made\n  //    visible.\n  self._afterUpdateCallbacks = [];\n\n  // In two contexts, we buffer all incoming data messages and then process them\n  // all at once in a single update:\n  //   - During reconnect, we buffer all data messages until all subs that had\n  //     been ready before reconnect are ready again, and all methods that are\n  //     active have returned their \"data done message\"; then\n  //   - During the execution of a \"wait\" method, we buffer all data messages\n  //     until the wait method gets its \"data done\" message. (If the wait method\n  //     occurs during reconnect, it doesn't get any special handling.)\n  // all data messages are processed in one update.\n  //\n  // The following fields are used for this \"quiescence\" process.\n\n  // This buffers the messages that aren't being processed yet.\n  self._messagesBufferedUntilQuiescence = [];\n  // Map from method ID -> true. Methods are removed from this when their\n  // \"data done\" message is received, and we will not quiesce until it is\n  // empty.\n  self._methodsBlockingQuiescence = {};\n  // map from sub ID -> true for subs that were ready (ie, called the sub\n  // ready callback) before reconnect but haven't become ready again yet\n  self._subsBeingRevived = {}; // map from sub._id -> true\n  // if true, the next data update should reset all stores. (set during\n  // reconnect.)\n  self._resetStores = false;\n\n  // name -> array of updates for (yet to be created) collections\n  self._updatesForUnknownStores = {};\n  // if we're blocking a migration, the retry func\n  self._retryMigrate = null;\n\n  // metadata for subscriptions.  Map from sub ID to object with keys:\n  //   - id\n  //   - name\n  //   - params\n  //   - inactive (if true, will be cleaned up if not reused in re-run)\n  //   - ready (has the 'ready' message been received?)\n  //   - readyCallback (an optional callback to call when ready)\n  //   - errorCallback (an optional callback to call if the sub terminates with\n  //                    an error, XXX COMPAT WITH 1.0.3.1)\n  //   - stopCallback (an optional callback to call when the sub terminates\n  //     for any reason, with an error argument if an error triggered the stop)\n  self._subscriptions = {};\n\n  // Reactive userId.\n  self._userId = null;\n  self._userIdDeps = new Tracker.Dependency;\n\n  // Block auto-reload while we're waiting for method responses.\n  if (Meteor.isClient && Package.reload && !options.reloadWithOutstanding) {\n    Package.reload.Reload._onMigrate(function (retry) {\n      if (!self._readyToMigrate()) {\n        if (self._retryMigrate)\n          throw new Error(\"Two migrations in progress?\");\n        self._retryMigrate = retry;\n        return false;\n      } else {\n        return [true];\n      }\n    });\n  }\n\n  var onMessage = function (raw_msg) {\n    try {\n      var msg = DDPCommon.parseDDP(raw_msg);\n    } catch (e) {\n      Meteor._debug(\"Exception while parsing DDP\", e);\n      return;\n    }\n\n    // Any message counts as receiving a pong, as it demonstrates that\n    // the server is still alive.\n    if (self._heartbeat) {\n      self._heartbeat.messageReceived();\n    }\n\n    if (msg === null || !msg.msg) {\n      // XXX COMPAT WITH 0.6.6. ignore the old welcome message for back\n      // compat.  Remove this 'if' once the server stops sending welcome\n      // messages (stream_server.js).\n      if (! (msg && msg.server_id))\n        Meteor._debug(\"discarding invalid livedata message\", msg);\n      return;\n    }\n\n    if (msg.msg === 'connected') {\n      self._version = self._versionSuggestion;\n      self._livedata_connected(msg);\n      options.onConnected();\n    }\n    else if (msg.msg === 'failed') {\n      if (_.contains(self._supportedDDPVersions, msg.version)) {\n        self._versionSuggestion = msg.version;\n        self._stream.reconnect({_force: true});\n      } else {\n        var description =\n              \"DDP version negotiation failed; server requested version \" + msg.version;\n        self._stream.disconnect({_permanent: true, _error: description});\n        options.onDDPVersionNegotiationFailure(description);\n      }\n    }\n    else if (msg.msg === 'ping' && options.respondToPings) {\n      self._send({msg: \"pong\", id: msg.id});\n    }\n    else if (msg.msg === 'pong') {\n      // noop, as we assume everything's a pong\n    }\n    else if (_.include(['added', 'changed', 'removed', 'ready', 'updated'], msg.msg))\n      self._livedata_data(msg);\n    else if (msg.msg === 'nosub')\n      self._livedata_nosub(msg);\n    else if (msg.msg === 'result')\n      self._livedata_result(msg);\n    else if (msg.msg === 'error')\n      self._livedata_error(msg);\n    else\n      Meteor._debug(\"discarding unknown livedata message type\", msg);\n  };\n\n  var onReset = function () {\n    // Send a connect message at the beginning of the stream.\n    // NOTE: reset is called even on the first connection, so this is\n    // the only place we send this message.\n    var msg = {msg: 'connect'};\n    if (self._lastSessionId)\n      msg.session = self._lastSessionId;\n    msg.version = self._versionSuggestion || self._supportedDDPVersions[0];\n    self._versionSuggestion = msg.version;\n    msg.support = self._supportedDDPVersions;\n    self._send(msg);\n\n    // Now, to minimize setup latency, go ahead and blast out all of\n    // our pending methods ands subscriptions before we've even taken\n    // the necessary RTT to know if we successfully reconnected. (1)\n    // They're supposed to be idempotent; (2) even if we did\n    // reconnect, we're not sure what messages might have gotten lost\n    // (in either direction) since we were disconnected (TCP being\n    // sloppy about that.)\n\n    // If the current block of methods all got their results (but didn't all get\n    // their data visible), discard the empty block now.\n    if (! _.isEmpty(self._outstandingMethodBlocks) &&\n        _.isEmpty(self._outstandingMethodBlocks[0].methods)) {\n      self._outstandingMethodBlocks.shift();\n    }\n\n    // Mark all messages as unsent, they have not yet been sent on this\n    // connection.\n    _.each(self._methodInvokers, function (m) {\n      m.sentMessage = false;\n    });\n\n    // If an `onReconnect` handler is set, call it first. Go through\n    // some hoops to ensure that methods that are called from within\n    // `onReconnect` get executed _before_ ones that were originally\n    // outstanding (since `onReconnect` is used to re-establish auth\n    // certificates)\n    if (self.onReconnect)\n      self._callOnReconnectAndSendAppropriateOutstandingMethods();\n    else\n      self._sendOutstandingMethods();\n\n    // add new subscriptions at the end. this way they take effect after\n    // the handlers and we don't see flicker.\n    _.each(self._subscriptions, function (sub, id) {\n      self._send({\n        msg: 'sub',\n        id: id,\n        name: sub.name,\n        params: sub.params\n      });\n    });\n  };\n\n  var onDisconnect = function () {\n    if (self._heartbeat) {\n      self._heartbeat.stop();\n      self._heartbeat = null;\n    }\n  };\n\n  if (Meteor.isServer) {\n    self._stream.on('message', Meteor.bindEnvironment(onMessage, \"handling DDP message\"));\n    self._stream.on('reset', Meteor.bindEnvironment(onReset, \"handling DDP reset\"));\n    self._stream.on('disconnect', Meteor.bindEnvironment(onDisconnect, \"handling DDP disconnect\"));\n  } else {\n    self._stream.on('message', onMessage);\n    self._stream.on('reset', onReset);\n    self._stream.on('disconnect', onDisconnect);\n  }\n};\n\n// A MethodInvoker manages sending a method to the server and calling the user's\n// callbacks. On construction, it registers itself in the connection's\n// _methodInvokers map; it removes itself once the method is fully finished and\n// the callback is invoked. This occurs when it has both received a result,\n// and the data written by it is fully visible.\nvar MethodInvoker = function (options) {\n  var self = this;\n\n  // Public (within this file) fields.\n  self.methodId = options.methodId;\n  self.sentMessage = false;\n\n  self._callback = options.callback;\n  self._connection = options.connection;\n  self._message = options.message;\n  self._onResultReceived = options.onResultReceived || function () {};\n  self._wait = options.wait;\n  self._methodResult = null;\n  self._dataVisible = false;\n\n  // Register with the connection.\n  self._connection._methodInvokers[self.methodId] = self;\n};\n_.extend(MethodInvoker.prototype, {\n  // Sends the method message to the server. May be called additional times if\n  // we lose the connection and reconnect before receiving a result.\n  sendMessage: function () {\n    var self = this;\n    // This function is called before sending a method (including resending on\n    // reconnect). We should only (re)send methods where we don't already have a\n    // result!\n    if (self.gotResult())\n      throw new Error(\"sendingMethod is called on method with result\");\n\n    // If we're re-sending it, it doesn't matter if data was written the first\n    // time.\n    self._dataVisible = false;\n\n    self.sentMessage = true;\n\n    // If this is a wait method, make all data messages be buffered until it is\n    // done.\n    if (self._wait)\n      self._connection._methodsBlockingQuiescence[self.methodId] = true;\n\n    // Actually send the message.\n    self._connection._send(self._message);\n  },\n  // Invoke the callback, if we have both a result and know that all data has\n  // been written to the local cache.\n  _maybeInvokeCallback: function () {\n    var self = this;\n    if (self._methodResult && self._dataVisible) {\n      // Call the callback. (This won't throw: the callback was wrapped with\n      // bindEnvironment.)\n      self._callback(self._methodResult[0], self._methodResult[1]);\n\n      // Forget about this method.\n      delete self._connection._methodInvokers[self.methodId];\n\n      // Let the connection know that this method is finished, so it can try to\n      // move on to the next block of methods.\n      self._connection._outstandingMethodFinished();\n    }\n  },\n  // Call with the result of the method from the server. Only may be called\n  // once; once it is called, you should not call sendMessage again.\n  // If the user provided an onResultReceived callback, call it immediately.\n  // Then invoke the main callback if data is also visible.\n  receiveResult: function (err, result) {\n    var self = this;\n    if (self.gotResult())\n      throw new Error(\"Methods should only receive results once\");\n    self._methodResult = [err, result];\n    self._onResultReceived(err, result);\n    self._maybeInvokeCallback();\n  },\n  // Call this when all data written by the method is visible. This means that\n  // the method has returns its \"data is done\" message *AND* all server\n  // documents that are buffered at that time have been written to the local\n  // cache. Invokes the main callback if the result has been received.\n  dataVisible: function () {\n    var self = this;\n    self._dataVisible = true;\n    self._maybeInvokeCallback();\n  },\n  // True if receiveResult has been called.\n  gotResult: function () {\n    var self = this;\n    return !!self._methodResult;\n  }\n});\n\n_.extend(Connection.prototype, {\n  // 'name' is the name of the data on the wire that should go in the\n  // store. 'wrappedStore' should be an object with methods beginUpdate, update,\n  // endUpdate, saveOriginals, retrieveOriginals. see Collection for an example.\n  registerStore: function (name, wrappedStore) {\n    var self = this;\n\n    if (name in self._stores)\n      return false;\n\n    // Wrap the input object in an object which makes any store method not\n    // implemented by 'store' into a no-op.\n    var store = {};\n    _.each(['update', 'beginUpdate', 'endUpdate', 'saveOriginals',\n            'retrieveOriginals', 'getDoc'], function (method) {\n              store[method] = function () {\n                return (wrappedStore[method]\n                        ? wrappedStore[method].apply(wrappedStore, arguments)\n                        : undefined);\n              };\n            });\n\n    self._stores[name] = store;\n\n    var queued = self._updatesForUnknownStores[name];\n    if (queued) {\n      store.beginUpdate(queued.length, false);\n      _.each(queued, function (msg) {\n        store.update(msg);\n      });\n      store.endUpdate();\n      delete self._updatesForUnknownStores[name];\n    }\n\n    return true;\n  },\n\n  /**\n   * @memberOf Meteor\n   * @summary Subscribe to a record set.  Returns a handle that provides\n   * `stop()` and `ready()` methods.\n   * @locus Client\n   * @param {String} name Name of the subscription.  Matches the name of the\n   * server's `publish()` call.\n   * @param {EJSONable} [arg1,arg2...] Optional arguments passed to publisher\n   * function on server.\n   * @param {Function|Object} [callbacks] Optional. May include `onStop`\n   * and `onReady` callbacks. If there is an error, it is passed as an\n   * argument to `onStop`. If a function is passed instead of an object, it\n   * is interpreted as an `onReady` callback.\n   */\n  subscribe: function (name /* .. [arguments] .. (callback|callbacks) */) {\n    var self = this;\n\n    var params = Array.prototype.slice.call(arguments, 1);\n    var callbacks = {};\n    if (params.length) {\n      var lastParam = params[params.length - 1];\n      if (_.isFunction(lastParam)) {\n        callbacks.onReady = params.pop();\n      } else if (lastParam &&\n        // XXX COMPAT WITH 1.0.3.1 onError used to exist, but now we use\n        // onStop with an error callback instead.\n        _.any([lastParam.onReady, lastParam.onError, lastParam.onStop],\n          _.isFunction)) {\n        callbacks = params.pop();\n      }\n    }\n\n    // Is there an existing sub with the same name and param, run in an\n    // invalidated Computation? This will happen if we are rerunning an\n    // existing computation.\n    //\n    // For example, consider a rerun of:\n    //\n    //     Tracker.autorun(function () {\n    //       Meteor.subscribe(\"foo\", Session.get(\"foo\"));\n    //       Meteor.subscribe(\"bar\", Session.get(\"bar\"));\n    //     });\n    //\n    // If \"foo\" has changed but \"bar\" has not, we will match the \"bar\"\n    // subcribe to an existing inactive subscription in order to not\n    // unsub and resub the subscription unnecessarily.\n    //\n    // We only look for one such sub; if there are N apparently-identical subs\n    // being invalidated, we will require N matching subscribe calls to keep\n    // them all active.\n    var existing = _.find(self._subscriptions, function (sub) {\n      return sub.inactive && sub.name === name &&\n        EJSON.equals(sub.params, params);\n    });\n\n    var id;\n    if (existing) {\n      id = existing.id;\n      existing.inactive = false; // reactivate\n\n      if (callbacks.onReady) {\n        // If the sub is not already ready, replace any ready callback with the\n        // one provided now. (It's not really clear what users would expect for\n        // an onReady callback inside an autorun; the semantics we provide is\n        // that at the time the sub first becomes ready, we call the last\n        // onReady callback provided, if any.)\n        if (!existing.ready)\n          existing.readyCallback = callbacks.onReady;\n      }\n\n      // XXX COMPAT WITH 1.0.3.1 we used to have onError but now we call\n      // onStop with an optional error argument\n      if (callbacks.onError) {\n        // Replace existing callback if any, so that errors aren't\n        // double-reported.\n        existing.errorCallback = callbacks.onError;\n      }\n\n      if (callbacks.onStop) {\n        existing.stopCallback = callbacks.onStop;\n      }\n    } else {\n      // New sub! Generate an id, save it locally, and send message.\n      id = Random.id();\n      self._subscriptions[id] = {\n        id: id,\n        name: name,\n        params: EJSON.clone(params),\n        inactive: false,\n        ready: false,\n        readyDeps: new Tracker.Dependency,\n        readyCallback: callbacks.onReady,\n        // XXX COMPAT WITH 1.0.3.1 #errorCallback\n        errorCallback: callbacks.onError,\n        stopCallback: callbacks.onStop,\n        connection: self,\n        remove: function() {\n          delete this.connection._subscriptions[this.id];\n          this.ready && this.readyDeps.changed();\n        },\n        stop: function() {\n          this.connection._send({msg: 'unsub', id: id});\n          this.remove();\n\n          if (callbacks.onStop) {\n            callbacks.onStop();\n          }\n        }\n      };\n      self._send({msg: 'sub', id: id, name: name, params: params});\n    }\n\n    // return a handle to the application.\n    var handle = {\n      stop: function () {\n        if (!_.has(self._subscriptions, id))\n          return;\n\n        self._subscriptions[id].stop();\n      },\n      ready: function () {\n        // return false if we've unsubscribed.\n        if (!_.has(self._subscriptions, id))\n          return false;\n        var record = self._subscriptions[id];\n        record.readyDeps.depend();\n        return record.ready;\n      },\n      subscriptionId: id\n    };\n\n    if (Tracker.active) {\n      // We're in a reactive computation, so we'd like to unsubscribe when the\n      // computation is invalidated... but not if the rerun just re-subscribes\n      // to the same subscription!  When a rerun happens, we use onInvalidate\n      // as a change to mark the subscription \"inactive\" so that it can\n      // be reused from the rerun.  If it isn't reused, it's killed from\n      // an afterFlush.\n      Tracker.onInvalidate(function (c) {\n        if (_.has(self._subscriptions, id))\n          self._subscriptions[id].inactive = true;\n\n        Tracker.afterFlush(function () {\n          if (_.has(self._subscriptions, id) &&\n              self._subscriptions[id].inactive)\n            handle.stop();\n        });\n      });\n    }\n\n    return handle;\n  },\n\n  // options:\n  // - onLateError {Function(error)} called if an error was received after the ready event.\n  //     (errors received before ready cause an error to be thrown)\n  _subscribeAndWait: function (name, args, options) {\n    var self = this;\n    var f = new Future();\n    var ready = false;\n    var handle;\n    args = args || [];\n    args.push({\n      onReady: function () {\n        ready = true;\n        f['return']();\n      },\n      onError: function (e) {\n        if (!ready)\n          f['throw'](e);\n        else\n          options && options.onLateError && options.onLateError(e);\n      }\n    });\n\n    handle = self.subscribe.apply(self, [name].concat(args));\n    f.wait();\n    return handle;\n  },\n\n  methods: function (methods) {\n    var self = this;\n    _.each(methods, function (func, name) {\n      if (typeof func !== 'function')\n        throw new Error(\"Method '\" + name + \"' must be a function\");\n      if (self._methodHandlers[name])\n        throw new Error(\"A method named '\" + name + \"' is already defined\");\n      self._methodHandlers[name] = func;\n    });\n  },\n\n  /**\n   * @memberOf Meteor\n   * @summary Invokes a method passing any number of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable} [arg1,arg2...] Optional method arguments\n   * @param {Function} [asyncCallback] Optional callback, which is called asynchronously with the error or result after the method is complete. If not provided, the method runs synchronously if possible (see below).\n   */\n  call: function (name /* .. [arguments] .. callback */) {\n    // if it's a function, the last argument is the result callback,\n    // not a parameter to the remote method.\n    var args = Array.prototype.slice.call(arguments, 1);\n    if (args.length && typeof args[args.length - 1] === \"function\")\n      var callback = args.pop();\n    return this.apply(name, args, callback);\n  },\n\n  // @param options {Optional Object}\n  //   wait: Boolean - Should we wait to call this until all current methods\n  //                   are fully finished, and block subsequent method calls\n  //                   until this method is fully finished?\n  //                   (does not affect methods called from within this method)\n  //   onResultReceived: Function - a callback to call as soon as the method\n  //                                result is received. the data written by\n  //                                the method may not yet be in the cache!\n  //   returnStubValue: Boolean - If true then in cases where we would have\n  //                              otherwise discarded the stub's return value\n  //                              and returned undefined, instead we go ahead\n  //                              and return it.  Specifically, this is any\n  //                              time other than when (a) we are already\n  //                              inside a stub or (b) we are in Node and no\n  //                              callback was provided.  Currently we require\n  //                              this flag to be explicitly passed to reduce\n  //                              the likelihood that stub return values will\n  //                              be confused with server return values; we\n  //                              may improve this in future.\n  // @param callback {Optional Function}\n\n  /**\n   * @memberOf Meteor\n   * @summary Invoke a method passing an array of arguments.\n   * @locus Anywhere\n   * @param {String} name Name of method to invoke\n   * @param {EJSONable[]} args Method arguments\n   * @param {Object} [options]\n   * @param {Boolean} options.wait (Client only) If true, don't send this method until all previous method calls have completed, and don't send any subsequent method calls until this one is completed.\n   * @param {Function} options.onResultReceived (Client only) This callback is invoked with the error or result of the method (just like `asyncCallback`) as soon as the error or result is available. The local cache may not yet reflect the writes performed by the method.\n   * @param {Function} [asyncCallback] Optional callback; same semantics as in [`Meteor.call`](#meteor_call).\n   */\n  apply: function (name, args, options, callback) {\n    var self = this;\n\n    // We were passed 3 arguments. They may be either (name, args, options)\n    // or (name, args, callback)\n    if (!callback && typeof options === 'function') {\n      callback = options;\n      options = {};\n    }\n    options = options || {};\n\n    if (callback) {\n      // XXX would it be better form to do the binding in stream.on,\n      // or caller, instead of here?\n      // XXX improve error message (and how we report it)\n      callback = Meteor.bindEnvironment(\n        callback,\n        \"delivering result of invoking '\" + name + \"'\"\n      );\n    }\n\n    // Keep our args safe from mutation (eg if we don't send the message for a\n    // while because of a wait method).\n    args = EJSON.clone(args);\n\n    // Lazily allocate method ID once we know that it'll be needed.\n    var methodId = (function () {\n      var id;\n      return function () {\n        if (id === undefined)\n          id = '' + (self._nextMethodId++);\n        return id;\n      };\n    })();\n\n    var enclosing = DDP._CurrentInvocation.get();\n    var alreadyInSimulation = enclosing && enclosing.isSimulation;\n\n    // Lazily generate a randomSeed, only if it is requested by the stub.\n    // The random streams only have utility if they're used on both the client\n    // and the server; if the client doesn't generate any 'random' values\n    // then we don't expect the server to generate any either.\n    // Less commonly, the server may perform different actions from the client,\n    // and may in fact generate values where the client did not, but we don't\n    // have any client-side values to match, so even here we may as well just\n    // use a random seed on the server.  In that case, we don't pass the\n    // randomSeed to save bandwidth, and we don't even generate it to save a\n    // bit of CPU and to avoid consuming entropy.\n    var randomSeed = null;\n    var randomSeedGenerator = function () {\n      if (randomSeed === null) {\n        randomSeed = DDPCommon.makeRpcSeed(enclosing, name);\n      }\n      return randomSeed;\n    };\n\n    // Run the stub, if we have one. The stub is supposed to make some\n    // temporary writes to the database to give the user a smooth experience\n    // until the actual result of executing the method comes back from the\n    // server (whereupon the temporary writes to the database will be reversed\n    // during the beginUpdate/endUpdate process.)\n    //\n    // Normally, we ignore the return value of the stub (even if it is an\n    // exception), in favor of the real return value from the server. The\n    // exception is if the *caller* is a stub. In that case, we're not going\n    // to do a RPC, so we use the return value of the stub as our return\n    // value.\n\n    var stub = self._methodHandlers[name];\n    if (stub) {\n      var setUserId = function(userId) {\n        self.setUserId(userId);\n      };\n\n      var invocation = new DDPCommon.MethodInvocation({\n        isSimulation: true,\n        userId: self.userId(),\n        setUserId: setUserId,\n        randomSeed: function () { return randomSeedGenerator(); }\n      });\n\n      if (!alreadyInSimulation)\n        self._saveOriginals();\n\n      try {\n        // Note that unlike in the corresponding server code, we never audit\n        // that stubs check() their arguments.\n        var stubReturnValue = DDP._CurrentInvocation.withValue(invocation, function () {\n          if (Meteor.isServer) {\n            // Because saveOriginals and retrieveOriginals aren't reentrant,\n            // don't allow stubs to yield.\n            return Meteor._noYieldsAllowed(function () {\n              // re-clone, so that the stub can't affect our caller's values\n              return stub.apply(invocation, EJSON.clone(args));\n            });\n          } else {\n            return stub.apply(invocation, EJSON.clone(args));\n          }\n        });\n      }\n      catch (e) {\n        var exception = e;\n      }\n\n      if (!alreadyInSimulation)\n        self._retrieveAndStoreOriginals(methodId());\n    }\n\n    // If we're in a simulation, stop and return the result we have,\n    // rather than going on to do an RPC. If there was no stub,\n    // we'll end up returning undefined.\n    if (alreadyInSimulation) {\n      if (callback) {\n        callback(exception, stubReturnValue);\n        return undefined;\n      }\n      if (exception)\n        throw exception;\n      return stubReturnValue;\n    }\n\n    // If an exception occurred in a stub, and we're ignoring it\n    // because we're doing an RPC and want to use what the server\n    // returns instead, log it so the developer knows\n    // (unless they explicitly ask to see the error).\n    //\n    // Tests can set the 'expected' flag on an exception so it won't\n    // go to log.\n    if (exception) {\n      if (options.throwStubExceptions) {\n        throw exception;\n      } else if (!exception.expected) {\n        Meteor._debug(\"Exception while simulating the effect of invoking '\" +\n          name + \"'\", exception, exception.stack);\n      }\n    }\n\n\n    // At this point we're definitely doing an RPC, and we're going to\n    // return the value of the RPC to the caller.\n\n    // If the caller didn't give a callback, decide what to do.\n    if (!callback) {\n      if (Meteor.isClient) {\n        // On the client, we don't have fibers, so we can't block. The\n        // only thing we can do is to return undefined and discard the\n        // result of the RPC. If an error occurred then print the error\n        // to the console.\n        callback = function (err) {\n          err && Meteor._debug(\"Error invoking Method '\" + name + \"':\",\n                               err.message);\n        };\n      } else {\n        // On the server, make the function synchronous. Throw on\n        // errors, return on success.\n        var future = new Future;\n        callback = future.resolver();\n      }\n    }\n    // Send the RPC. Note that on the client, it is important that the\n    // stub have finished before we send the RPC, so that we know we have\n    // a complete list of which local documents the stub wrote.\n    var message = {\n      msg: 'method',\n      method: name,\n      params: args,\n      id: methodId()\n    };\n\n    // Send the randomSeed only if we used it\n    if (randomSeed !== null) {\n      message.randomSeed = randomSeed;\n    }\n\n    var methodInvoker = new MethodInvoker({\n      methodId: methodId(),\n      callback: callback,\n      connection: self,\n      onResultReceived: options.onResultReceived,\n      wait: !!options.wait,\n      message: message\n    });\n\n    if (options.wait) {\n      // It's a wait method! Wait methods go in their own block.\n      self._outstandingMethodBlocks.push(\n        {wait: true, methods: [methodInvoker]});\n    } else {\n      // Not a wait method. Start a new block if the previous block was a wait\n      // block, and add it to the last block of methods.\n      if (_.isEmpty(self._outstandingMethodBlocks) ||\n          _.last(self._outstandingMethodBlocks).wait)\n        self._outstandingMethodBlocks.push({wait: false, methods: []});\n      _.last(self._outstandingMethodBlocks).methods.push(methodInvoker);\n    }\n\n    // If we added it to the first block, send it out now.\n    if (self._outstandingMethodBlocks.length === 1)\n      methodInvoker.sendMessage();\n\n    // If we're using the default callback on the server,\n    // block waiting for the result.\n    if (future) {\n      return future.wait();\n    }\n    return options.returnStubValue ? stubReturnValue : undefined;\n  },\n\n  // Before calling a method stub, prepare all stores to track changes and allow\n  // _retrieveAndStoreOriginals to get the original versions of changed\n  // documents.\n  _saveOriginals: function () {\n    var self = this;\n    _.each(self._stores, function (s) {\n      s.saveOriginals();\n    });\n  },\n  // Retrieves the original versions of all documents modified by the stub for\n  // method 'methodId' from all stores and saves them to _serverDocuments (keyed\n  // by document) and _documentsWrittenByStub (keyed by method ID).\n  _retrieveAndStoreOriginals: function (methodId) {\n    var self = this;\n    if (self._documentsWrittenByStub[methodId])\n      throw new Error(\"Duplicate methodId in _retrieveAndStoreOriginals\");\n\n    var docsWritten = [];\n    _.each(self._stores, function (s, collection) {\n      var originals = s.retrieveOriginals();\n      // not all stores define retrieveOriginals\n      if (!originals)\n        return;\n      originals.forEach(function (doc, id) {\n        docsWritten.push({collection: collection, id: id});\n        if (!_.has(self._serverDocuments, collection))\n          self._serverDocuments[collection] = new MongoIDMap;\n        var serverDoc = self._serverDocuments[collection].setDefault(id, {});\n        if (serverDoc.writtenByStubs) {\n          // We're not the first stub to write this doc. Just add our method ID\n          // to the record.\n          serverDoc.writtenByStubs[methodId] = true;\n        } else {\n          // First stub! Save the original value and our method ID.\n          serverDoc.document = doc;\n          serverDoc.flushCallbacks = [];\n          serverDoc.writtenByStubs = {};\n          serverDoc.writtenByStubs[methodId] = true;\n        }\n      });\n    });\n    if (!_.isEmpty(docsWritten)) {\n      self._documentsWrittenByStub[methodId] = docsWritten;\n    }\n  },\n\n  // This is very much a private function we use to make the tests\n  // take up fewer server resources after they complete.\n  _unsubscribeAll: function () {\n    var self = this;\n    _.each(_.clone(self._subscriptions), function (sub, id) {\n      // Avoid killing the autoupdate subscription so that developers\n      // still get hot code pushes when writing tests.\n      //\n      // XXX it's a hack to encode knowledge about autoupdate here,\n      // but it doesn't seem worth it yet to have a special API for\n      // subscriptions to preserve after unit tests.\n      if (sub.name !== 'meteor_autoupdate_clientVersions') {\n        self._subscriptions[id].stop();\n      }\n    });\n  },\n\n  // Sends the DDP stringification of the given message object\n  _send: function (obj) {\n    var self = this;\n    self._stream.send(DDPCommon.stringifyDDP(obj));\n  },\n\n  // We detected via DDP-level heartbeats that we've lost the\n  // connection.  Unlike `disconnect` or `close`, a lost connection\n  // will be automatically retried.\n  _lostConnection: function (error) {\n    var self = this;\n    self._stream._lostConnection(error);\n  },\n\n  /**\n   * @summary Get the current connection status. A reactive data source.\n   * @locus Client\n   * @memberOf Meteor\n   */\n  status: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.status.apply(self._stream, arguments);\n  },\n\n  /**\n   * @summary Force an immediate reconnection attempt if the client is not connected to the server.\n\n  This method does nothing if the client is already connected.\n   * @locus Client\n   * @memberOf Meteor\n   */\n  reconnect: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.reconnect.apply(self._stream, arguments);\n  },\n\n  /**\n   * @summary Disconnect the client from the server.\n   * @locus Client\n   * @memberOf Meteor\n   */\n  disconnect: function (/*passthrough args*/) {\n    var self = this;\n    return self._stream.disconnect.apply(self._stream, arguments);\n  },\n\n  close: function () {\n    var self = this;\n    return self._stream.disconnect({_permanent: true});\n  },\n\n  ///\n  /// Reactive user system\n  ///\n  userId: function () {\n    var self = this;\n    if (self._userIdDeps)\n      self._userIdDeps.depend();\n    return self._userId;\n  },\n\n  setUserId: function (userId) {\n    var self = this;\n    // Avoid invalidating dependents if setUserId is called with current value.\n    if (self._userId === userId)\n      return;\n    self._userId = userId;\n    if (self._userIdDeps)\n      self._userIdDeps.changed();\n  },\n\n  // Returns true if we are in a state after reconnect of waiting for subs to be\n  // revived or early methods to finish their data, or we are waiting for a\n  // \"wait\" method to finish.\n  _waitingForQuiescence: function () {\n    var self = this;\n    return (! _.isEmpty(self._subsBeingRevived) ||\n            ! _.isEmpty(self._methodsBlockingQuiescence));\n  },\n\n  // Returns true if any method whose message has been sent to the server has\n  // not yet invoked its user callback.\n  _anyMethodsAreOutstanding: function () {\n    var self = this;\n    return _.any(_.pluck(self._methodInvokers, 'sentMessage'));\n  },\n\n  _livedata_connected: function (msg) {\n    var self = this;\n\n    if (self._version !== 'pre1' && self._heartbeatInterval !== 0) {\n      self._heartbeat = new DDPCommon.Heartbeat({\n        heartbeatInterval: self._heartbeatInterval,\n        heartbeatTimeout: self._heartbeatTimeout,\n        onTimeout: function () {\n          self._lostConnection(\n            new DDP.ConnectionError(\"DDP heartbeat timed out\"));\n        },\n        sendPing: function () {\n          self._send({msg: 'ping'});\n        }\n      });\n      self._heartbeat.start();\n    }\n\n    // If this is a reconnect, we'll have to reset all stores.\n    if (self._lastSessionId)\n      self._resetStores = true;\n\n    if (typeof (msg.session) === \"string\") {\n      var reconnectedToPreviousSession = (self._lastSessionId === msg.session);\n      self._lastSessionId = msg.session;\n    }\n\n    if (reconnectedToPreviousSession) {\n      // Successful reconnection -- pick up where we left off.  Note that right\n      // now, this never happens: the server never connects us to a previous\n      // session, because DDP doesn't provide enough data for the server to know\n      // what messages the client has processed. We need to improve DDP to make\n      // this possible, at which point we'll probably need more code here.\n      return;\n    }\n\n    // Server doesn't have our data any more. Re-sync a new session.\n\n    // Forget about messages we were buffering for unknown collections. They'll\n    // be resent if still relevant.\n    self._updatesForUnknownStores = {};\n\n    if (self._resetStores) {\n      // Forget about the effects of stubs. We'll be resetting all collections\n      // anyway.\n      self._documentsWrittenByStub = {};\n      self._serverDocuments = {};\n    }\n\n    // Clear _afterUpdateCallbacks.\n    self._afterUpdateCallbacks = [];\n\n    // Mark all named subscriptions which are ready (ie, we already called the\n    // ready callback) as needing to be revived.\n    // XXX We should also block reconnect quiescence until unnamed subscriptions\n    //     (eg, autopublish) are done re-publishing to avoid flicker!\n    self._subsBeingRevived = {};\n    _.each(self._subscriptions, function (sub, id) {\n      if (sub.ready)\n        self._subsBeingRevived[id] = true;\n    });\n\n    // Arrange for \"half-finished\" methods to have their callbacks run, and\n    // track methods that were sent on this connection so that we don't\n    // quiesce until they are all done.\n    //\n    // Start by clearing _methodsBlockingQuiescence: methods sent before\n    // reconnect don't matter, and any \"wait\" methods sent on the new connection\n    // that we drop here will be restored by the loop below.\n    self._methodsBlockingQuiescence = {};\n    if (self._resetStores) {\n      _.each(self._methodInvokers, function (invoker) {\n        if (invoker.gotResult()) {\n          // This method already got its result, but it didn't call its callback\n          // because its data didn't become visible. We did not resend the\n          // method RPC. We'll call its callback when we get a full quiesce,\n          // since that's as close as we'll get to \"data must be visible\".\n          self._afterUpdateCallbacks.push(_.bind(invoker.dataVisible, invoker));\n        } else if (invoker.sentMessage) {\n          // This method has been sent on this connection (maybe as a resend\n          // from the last connection, maybe from onReconnect, maybe just very\n          // quickly before processing the connected message).\n          //\n          // We don't need to do anything special to ensure its callbacks get\n          // called, but we'll count it as a method which is preventing\n          // reconnect quiescence. (eg, it might be a login method that was run\n          // from onReconnect, and we don't want to see flicker by seeing a\n          // logged-out state.)\n          self._methodsBlockingQuiescence[invoker.methodId] = true;\n        }\n      });\n    }\n\n    self._messagesBufferedUntilQuiescence = [];\n\n    // If we're not waiting on any methods or subs, we can reset the stores and\n    // call the callbacks immediately.\n    if (!self._waitingForQuiescence()) {\n      if (self._resetStores) {\n        _.each(self._stores, function (s) {\n          s.beginUpdate(0, true);\n          s.endUpdate();\n        });\n        self._resetStores = false;\n      }\n      self._runAfterUpdateCallbacks();\n    }\n  },\n\n\n  _processOneDataMessage: function (msg, updates) {\n    var self = this;\n    // Using underscore here so as not to need to capitalize.\n    self['_process_' + msg.msg](msg, updates);\n  },\n\n\n  _livedata_data: function (msg) {\n    var self = this;\n\n    // collection name -> array of messages\n    var updates = {};\n\n    if (self._waitingForQuiescence()) {\n      self._messagesBufferedUntilQuiescence.push(msg);\n\n      if (msg.msg === \"nosub\")\n        delete self._subsBeingRevived[msg.id];\n\n      _.each(msg.subs || [], function (subId) {\n        delete self._subsBeingRevived[subId];\n      });\n      _.each(msg.methods || [], function (methodId) {\n        delete self._methodsBlockingQuiescence[methodId];\n      });\n\n      if (self._waitingForQuiescence())\n        return;\n\n      // No methods or subs are blocking quiescence!\n      // We'll now process and all of our buffered messages, reset all stores,\n      // and apply them all at once.\n      _.each(self._messagesBufferedUntilQuiescence, function (bufferedMsg) {\n        self._processOneDataMessage(bufferedMsg, updates);\n      });\n      self._messagesBufferedUntilQuiescence = [];\n    } else {\n      self._processOneDataMessage(msg, updates);\n    }\n\n    if (self._resetStores || !_.isEmpty(updates)) {\n      // Begin a transactional update of each store.\n      _.each(self._stores, function (s, storeName) {\n        s.beginUpdate(_.has(updates, storeName) ? updates[storeName].length : 0,\n                      self._resetStores);\n      });\n      self._resetStores = false;\n\n      _.each(updates, function (updateMessages, storeName) {\n        var store = self._stores[storeName];\n        if (store) {\n          _.each(updateMessages, function (updateMessage) {\n            store.update(updateMessage);\n          });\n        } else {\n          // Nobody's listening for this data. Queue it up until\n          // someone wants it.\n          // XXX memory use will grow without bound if you forget to\n          // create a collection or just don't care about it... going\n          // to have to do something about that.\n          if (!_.has(self._updatesForUnknownStores, storeName))\n            self._updatesForUnknownStores[storeName] = [];\n          Array.prototype.push.apply(self._updatesForUnknownStores[storeName],\n                                     updateMessages);\n        }\n      });\n\n      // End update transaction.\n      _.each(self._stores, function (s) { s.endUpdate(); });\n    }\n\n    self._runAfterUpdateCallbacks();\n  },\n\n  // Call any callbacks deferred with _runWhenAllServerDocsAreFlushed whose\n  // relevant docs have been flushed, as well as dataVisible callbacks at\n  // reconnect-quiescence time.\n  _runAfterUpdateCallbacks: function () {\n    var self = this;\n    var callbacks = self._afterUpdateCallbacks;\n    self._afterUpdateCallbacks = [];\n    _.each(callbacks, function (c) {\n      c();\n    });\n  },\n\n  _pushUpdate: function (updates, collection, msg) {\n    var self = this;\n    if (!_.has(updates, collection)) {\n      updates[collection] = [];\n    }\n    updates[collection].push(msg);\n  },\n\n  _getServerDoc: function (collection, id) {\n    var self = this;\n    if (!_.has(self._serverDocuments, collection))\n      return null;\n    var serverDocsForCollection = self._serverDocuments[collection];\n    return serverDocsForCollection.get(id) || null;\n  },\n\n  _process_added: function (msg, updates) {\n    var self = this;\n    var id = MongoID.idParse(msg.id);\n    var serverDoc = self._getServerDoc(msg.collection, id);\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      var isExisting = (serverDoc.document !== undefined);\n\n      serverDoc.document = msg.fields || {};\n      serverDoc.document._id = id;\n\n      if (self._resetStores) {\n        // During reconnect the server is sending adds for existing ids.\n        // Always push an update so that document stays in the store after\n        // reset. Use current version of the document for this update, so\n        // that stub-written values are preserved.\n        var currentDoc = self._stores[msg.collection].getDoc(msg.id);\n        if (currentDoc !== undefined)\n          msg.fields = currentDoc;\n\n        self._pushUpdate(updates, msg.collection, msg);\n      } else if (isExisting) {\n        throw new Error(\"Server sent add for existing id: \" + msg.id);\n      }\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n\n  _process_changed: function (msg, updates) {\n    var self = this;\n    var serverDoc = self._getServerDoc(\n      msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      if (serverDoc.document === undefined)\n        throw new Error(\"Server sent changed for nonexisting id: \" + msg.id);\n      DiffSequence.applyChanges(serverDoc.document, msg.fields);\n    } else {\n      self._pushUpdate(updates, msg.collection, msg);\n    }\n  },\n\n  _process_removed: function (msg, updates) {\n    var self = this;\n    var serverDoc = self._getServerDoc(\n      msg.collection, MongoID.idParse(msg.id));\n    if (serverDoc) {\n      // Some outstanding stub wrote here.\n      if (serverDoc.document === undefined)\n        throw new Error(\"Server sent removed for nonexisting id:\" + msg.id);\n      serverDoc.document = undefined;\n    } else {\n      self._pushUpdate(updates, msg.collection, {\n        msg: 'removed',\n        collection: msg.collection,\n        id: msg.id\n      });\n    }\n  },\n\n  _process_updated: function (msg, updates) {\n    var self = this;\n    // Process \"method done\" messages.\n    _.each(msg.methods, function (methodId) {\n      _.each(self._documentsWrittenByStub[methodId], function (written) {\n        var serverDoc = self._getServerDoc(written.collection, written.id);\n        if (!serverDoc)\n          throw new Error(\"Lost serverDoc for \" + JSON.stringify(written));\n        if (!serverDoc.writtenByStubs[methodId])\n          throw new Error(\"Doc \" + JSON.stringify(written) +\n                          \" not written by  method \" + methodId);\n        delete serverDoc.writtenByStubs[methodId];\n        if (_.isEmpty(serverDoc.writtenByStubs)) {\n          // All methods whose stubs wrote this method have completed! We can\n          // now copy the saved document to the database (reverting the stub's\n          // change if the server did not write to this object, or applying the\n          // server's writes if it did).\n\n          // This is a fake ddp 'replace' message.  It's just for talking\n          // between livedata connections and minimongo.  (We have to stringify\n          // the ID because it's supposed to look like a wire message.)\n          self._pushUpdate(updates, written.collection, {\n            msg: 'replace',\n            id: MongoID.idStringify(written.id),\n            replace: serverDoc.document\n          });\n          // Call all flush callbacks.\n          _.each(serverDoc.flushCallbacks, function (c) {\n            c();\n          });\n\n          // Delete this completed serverDocument. Don't bother to GC empty\n          // IdMaps inside self._serverDocuments, since there probably aren't\n          // many collections and they'll be written repeatedly.\n          self._serverDocuments[written.collection].remove(written.id);\n        }\n      });\n      delete self._documentsWrittenByStub[methodId];\n\n      // We want to call the data-written callback, but we can't do so until all\n      // currently buffered messages are flushed.\n      var callbackInvoker = self._methodInvokers[methodId];\n      if (!callbackInvoker)\n        throw new Error(\"No callback invoker for method \" + methodId);\n      self._runWhenAllServerDocsAreFlushed(\n        _.bind(callbackInvoker.dataVisible, callbackInvoker));\n    });\n  },\n\n  _process_ready: function (msg, updates) {\n    var self = this;\n    // Process \"sub ready\" messages. \"sub ready\" messages don't take effect\n    // until all current server documents have been flushed to the local\n    // database. We can use a write fence to implement this.\n    _.each(msg.subs, function (subId) {\n      self._runWhenAllServerDocsAreFlushed(function () {\n        var subRecord = self._subscriptions[subId];\n        // Did we already unsubscribe?\n        if (!subRecord)\n          return;\n        // Did we already receive a ready message? (Oops!)\n        if (subRecord.ready)\n          return;\n        subRecord.ready = true;\n        subRecord.readyCallback && subRecord.readyCallback();\n        subRecord.readyDeps.changed();\n      });\n    });\n  },\n\n  // Ensures that \"f\" will be called after all documents currently in\n  // _serverDocuments have been written to the local cache. f will not be called\n  // if the connection is lost before then!\n  _runWhenAllServerDocsAreFlushed: function (f) {\n    var self = this;\n    var runFAfterUpdates = function () {\n      self._afterUpdateCallbacks.push(f);\n    };\n    var unflushedServerDocCount = 0;\n    var onServerDocFlush = function () {\n      --unflushedServerDocCount;\n      if (unflushedServerDocCount === 0) {\n        // This was the last doc to flush! Arrange to run f after the updates\n        // have been applied.\n        runFAfterUpdates();\n      }\n    };\n    _.each(self._serverDocuments, function (collectionDocs) {\n      collectionDocs.forEach(function (serverDoc) {\n        var writtenByStubForAMethodWithSentMessage = _.any(\n          serverDoc.writtenByStubs, function (dummy, methodId) {\n            var invoker = self._methodInvokers[methodId];\n            return invoker && invoker.sentMessage;\n          });\n        if (writtenByStubForAMethodWithSentMessage) {\n          ++unflushedServerDocCount;\n          serverDoc.flushCallbacks.push(onServerDocFlush);\n        }\n      });\n    });\n    if (unflushedServerDocCount === 0) {\n      // There aren't any buffered docs --- we can call f as soon as the current\n      // round of updates is applied!\n      runFAfterUpdates();\n    }\n  },\n\n  _livedata_nosub: function (msg) {\n    var self = this;\n\n    // First pass it through _livedata_data, which only uses it to help get\n    // towards quiescence.\n    self._livedata_data(msg);\n\n    // Do the rest of our processing immediately, with no\n    // buffering-until-quiescence.\n\n    // we weren't subbed anyway, or we initiated the unsub.\n    if (!_.has(self._subscriptions, msg.id))\n      return;\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    var errorCallback = self._subscriptions[msg.id].errorCallback;\n    var stopCallback = self._subscriptions[msg.id].stopCallback;\n\n    self._subscriptions[msg.id].remove();\n\n    var meteorErrorFromMsg = function (msgArg) {\n      return msgArg && msgArg.error && new Meteor.Error(\n        msgArg.error.error, msgArg.error.reason, msgArg.error.details);\n    }\n\n    // XXX COMPAT WITH 1.0.3.1 #errorCallback\n    if (errorCallback && msg.error) {\n      errorCallback(meteorErrorFromMsg(msg));\n    }\n\n    if (stopCallback) {\n      stopCallback(meteorErrorFromMsg(msg));\n    }\n  },\n\n  _process_nosub: function () {\n    // This is called as part of the \"buffer until quiescence\" process, but\n    // nosub's effect is always immediate. It only goes in the buffer at all\n    // because it's possible for a nosub to be the thing that triggers\n    // quiescence, if we were waiting for a sub to be revived and it dies\n    // instead.\n  },\n\n  _livedata_result: function (msg) {\n    // id, result or error. error has error (code), reason, details\n\n    var self = this;\n\n    // find the outstanding request\n    // should be O(1) in nearly all realistic use cases\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      Meteor._debug(\"Received method result but no methods outstanding\");\n      return;\n    }\n    var currentMethodBlock = self._outstandingMethodBlocks[0].methods;\n    var m;\n    for (var i = 0; i < currentMethodBlock.length; i++) {\n      m = currentMethodBlock[i];\n      if (m.methodId === msg.id)\n        break;\n    }\n\n    if (!m) {\n      Meteor._debug(\"Can't match method response to original method call\", msg);\n      return;\n    }\n\n    // Remove from current method block. This may leave the block empty, but we\n    // don't move on to the next block until the callback has been delivered, in\n    // _outstandingMethodFinished.\n    currentMethodBlock.splice(i, 1);\n\n    if (_.has(msg, 'error')) {\n      m.receiveResult(new Meteor.Error(\n        msg.error.error, msg.error.reason,\n        msg.error.details));\n    } else {\n      // msg.result may be undefined if the method didn't return a\n      // value\n      m.receiveResult(undefined, msg.result);\n    }\n  },\n\n  // Called by MethodInvoker after a method's callback is invoked.  If this was\n  // the last outstanding method in the current block, runs the next block. If\n  // there are no more methods, consider accepting a hot code push.\n  _outstandingMethodFinished: function () {\n    var self = this;\n    if (self._anyMethodsAreOutstanding())\n      return;\n\n    // No methods are outstanding. This should mean that the first block of\n    // methods is empty. (Or it might not exist, if this was a method that\n    // half-finished before disconnect/reconnect.)\n    if (! _.isEmpty(self._outstandingMethodBlocks)) {\n      var firstBlock = self._outstandingMethodBlocks.shift();\n      if (! _.isEmpty(firstBlock.methods))\n        throw new Error(\"No methods outstanding but nonempty block: \" +\n                        JSON.stringify(firstBlock));\n\n      // Send the outstanding methods now in the first block.\n      if (!_.isEmpty(self._outstandingMethodBlocks))\n        self._sendOutstandingMethods();\n    }\n\n    // Maybe accept a hot code push.\n    self._maybeMigrate();\n  },\n\n  // Sends messages for all the methods in the first block in\n  // _outstandingMethodBlocks.\n  _sendOutstandingMethods: function() {\n    var self = this;\n    if (_.isEmpty(self._outstandingMethodBlocks))\n      return;\n    _.each(self._outstandingMethodBlocks[0].methods, function (m) {\n      m.sendMessage();\n    });\n  },\n\n  _livedata_error: function (msg) {\n    Meteor._debug(\"Received error from server: \", msg.reason);\n    if (msg.offendingMessage)\n      Meteor._debug(\"For: \", msg.offendingMessage);\n  },\n\n  _callOnReconnectAndSendAppropriateOutstandingMethods: function() {\n    var self = this;\n    var oldOutstandingMethodBlocks = self._outstandingMethodBlocks;\n    self._outstandingMethodBlocks = [];\n\n    self.onReconnect();\n\n    if (_.isEmpty(oldOutstandingMethodBlocks))\n      return;\n\n    // We have at least one block worth of old outstanding methods to try\n    // again. First: did onReconnect actually send anything? If not, we just\n    // restore all outstanding methods and run the first block.\n    if (_.isEmpty(self._outstandingMethodBlocks)) {\n      self._outstandingMethodBlocks = oldOutstandingMethodBlocks;\n      self._sendOutstandingMethods();\n      return;\n    }\n\n    // OK, there are blocks on both sides. Special case: merge the last block of\n    // the reconnect methods with the first block of the original methods, if\n    // neither of them are \"wait\" blocks.\n    if (!_.last(self._outstandingMethodBlocks).wait &&\n        !oldOutstandingMethodBlocks[0].wait) {\n      _.each(oldOutstandingMethodBlocks[0].methods, function (m) {\n        _.last(self._outstandingMethodBlocks).methods.push(m);\n\n        // If this \"last block\" is also the first block, send the message.\n        if (self._outstandingMethodBlocks.length === 1)\n          m.sendMessage();\n      });\n\n      oldOutstandingMethodBlocks.shift();\n    }\n\n    // Now add the rest of the original blocks on.\n    _.each(oldOutstandingMethodBlocks, function (block) {\n      self._outstandingMethodBlocks.push(block);\n    });\n  },\n\n  // We can accept a hot code push if there are no methods in flight.\n  _readyToMigrate: function() {\n    var self = this;\n    return _.isEmpty(self._methodInvokers);\n  },\n\n  // If we were blocking a migration, see if it's now possible to continue.\n  // Call whenever the set of outstanding/blocked methods shrinks.\n  _maybeMigrate: function () {\n    var self = this;\n    if (self._retryMigrate && self._readyToMigrate()) {\n      self._retryMigrate();\n      self._retryMigrate = null;\n    }\n  }\n});\n\nLivedataTest.Connection = Connection;\n\n// @param url {String} URL to Meteor app,\n//     e.g.:\n//     \"subdomain.meteor.com\",\n//     \"http://subdomain.meteor.com\",\n//     \"/\",\n//     \"ddp+sockjs://ddp--****-foo.meteor.com/sockjs\"\n\n/**\n * @summary Connect to the server of a different Meteor application to subscribe to its document sets and invoke its remote methods.\n * @locus Anywhere\n * @param {String} url The URL of another Meteor application.\n */\nDDP.connect = function (url, options) {\n  var ret = new Connection(url, options);\n  allConnections.push(ret); // hack. see below.\n  return ret;\n};\n\n// Hack for `spiderable` package: a way to see if the page is done\n// loading all the data it needs.\n//\nallConnections = [];\nDDP._allSubscriptionsReady = function () {\n  return _.all(allConnections, function (conn) {\n    return _.all(conn._subscriptions, function (sub) {\n      return sub.ready;\n    });\n  });\n};\n"]}}]