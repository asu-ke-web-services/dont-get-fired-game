[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar process = Package.meteor.process;\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\n\n/* Package-scope variables */\nvar babelHelpers;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                         //\n// packages/babel-runtime/babel-runtime.js                                                                 //\n//                                                                                                         //\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                           //\nvar hasOwn = Object.prototype.hasOwnProperty;                                                              // 1\n                                                                                                           // 2\nfunction canDefineNonEnumerableProperties() {                                                              // 3\n  var testObj = {};                                                                                        // 4\n  var testPropName = \"t\";                                                                                  // 5\n                                                                                                           // 6\n  try {                                                                                                    // 7\n    Object.defineProperty(testObj, testPropName, {                                                         // 8\n      enumerable: false,                                                                                   // 9\n      value: testObj                                                                                       // 10\n    });                                                                                                    // 11\n                                                                                                           // 12\n    for (var k in testObj) {                                                                               // 13\n      if (k === testPropName) {                                                                            // 14\n        return false;                                                                                      // 15\n      }                                                                                                    // 16\n    }                                                                                                      // 17\n  } catch (e) {                                                                                            // 18\n    return false;                                                                                          // 19\n  }                                                                                                        // 20\n                                                                                                           // 21\n  return testObj[testPropName] === testObj;                                                                // 22\n}                                                                                                          // 23\n                                                                                                           // 24\n// The name `babelHelpers` is hard-coded in Babel.  Otherwise we would make it                             // 25\n// something capitalized and more descriptive, like `BabelRuntime`.                                        // 26\nbabelHelpers = {                                                                                           // 27\n  // Meteor-specific runtime helper for wrapping the object of for-in                                      // 28\n  // loops, so that inherited Array methods defined by es5-shim can be                                     // 29\n  // ignored in browsers where they cannot be defined as non-enumerable.                                   // 30\n  sanitizeForInObject: canDefineNonEnumerableProperties()                                                  // 31\n    ? function (value) { return value; }                                                                   // 32\n    : function (obj) {                                                                                     // 33\n      if (Array.isArray(obj)) {                                                                            // 34\n        var newObj = {};                                                                                   // 35\n        var keys = Object.keys(obj);                                                                       // 36\n        var keyCount = keys.length;                                                                        // 37\n        for (var i = 0; i < keyCount; ++i) {                                                               // 38\n          var key = keys[i];                                                                               // 39\n          newObj[key] = obj[key];                                                                          // 40\n        }                                                                                                  // 41\n        return newObj;                                                                                     // 42\n      }                                                                                                    // 43\n                                                                                                           // 44\n      return obj;                                                                                          // 45\n    },                                                                                                     // 46\n                                                                                                           // 47\n  // es6.templateLiterals                                                                                  // 48\n  // Constructs the object passed to the tag function in a tagged                                          // 49\n  // template literal.                                                                                     // 50\n  taggedTemplateLiteralLoose: function (strings, raw) {                                                    // 51\n    // Babel's own version of this calls Object.freeze on `strings` and                                    // 52\n    // `strings.raw`, but it doesn't seem worth the compatibility and                                      // 53\n    // performance concerns.  If you're writing code against this helper,                                  // 54\n    // don't add properties to these objects.                                                              // 55\n    strings.raw = raw;                                                                                     // 56\n    return strings;                                                                                        // 57\n  },                                                                                                       // 58\n                                                                                                           // 59\n  // es6.classes                                                                                           // 60\n  // Checks that a class constructor is being called with `new`, and throws                                // 61\n  // an error if it is not.                                                                                // 62\n  classCallCheck: function (instance, Constructor) {                                                       // 63\n    if (!(instance instanceof Constructor)) {                                                              // 64\n      throw new TypeError(\"Cannot call a class as a function\");                                            // 65\n    }                                                                                                      // 66\n  },                                                                                                       // 67\n                                                                                                           // 68\n  // es6.classes                                                                                           // 69\n  inherits: function (subClass, superClass) {                                                              // 70\n    if (typeof superClass !== \"function\" && superClass !== null) {                                         // 71\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }                                                                                                      // 73\n                                                                                                           // 74\n    if (superClass) {                                                                                      // 75\n      if (Object.create) {                                                                                 // 76\n        // All but IE 8                                                                                    // 77\n        subClass.prototype = Object.create(superClass.prototype, {                                         // 78\n          constructor: {                                                                                   // 79\n            value: subClass,                                                                               // 80\n            enumerable: false,                                                                             // 81\n            writable: true,                                                                                // 82\n            configurable: true                                                                             // 83\n          }                                                                                                // 84\n        });                                                                                                // 85\n      } else {                                                                                             // 86\n        // IE 8 path.  Slightly worse for modern browsers, because `constructor`                           // 87\n        // is enumerable and shows up in the inspector unnecessarily.                                      // 88\n        // It's not an \"own\" property of any instance though.                                              // 89\n        //                                                                                                 // 90\n        // For correctness when writing code,                                                              // 91\n        // don't enumerate all the own-and-inherited properties of an instance                             // 92\n        // of a class and expect not to find `constructor` (but who does that?).                           // 93\n        var F = function () {                                                                              // 94\n          this.constructor = subClass;                                                                     // 95\n        };                                                                                                 // 96\n        F.prototype = superClass.prototype;                                                                // 97\n        subClass.prototype = new F();                                                                      // 98\n      }                                                                                                    // 99\n                                                                                                           // 100\n      // For modern browsers, this would be `subClass.__proto__ = superClass`,                             // 101\n      // but IE <=10 don't support `__proto__`, and in this case the difference                            // 102\n      // would be detectable; code that works in modern browsers could easily                              // 103\n      // fail on IE 8 if we ever used the `__proto__` trick.                                               // 104\n      //                                                                                                   // 105\n      // There's no perfect way to make static methods inherited if they are                               // 106\n      // assigned after declaration of the classes.  The best we can do is                                 // 107\n      // to copy them.  In other words, when you write `class Foo                                          // 108\n      // extends Bar`, we copy the static methods from Bar onto Foo, but future                            // 109\n      // ones are not copied.                                                                              // 110\n      //                                                                                                   // 111\n      // For correctness when writing code, don't add static methods to a class                            // 112\n      // after you subclass it.                                                                            // 113\n                                                                                                           // 114\n      // The ecmascript-runtime package provides adequate polyfills for                                    // 115\n      // all of these Object.* functions (and Array#forEach), and anyone                                   // 116\n      // using babel-runtime is almost certainly using it because of the                                   // 117\n      // ecmascript package, which also implies ecmascript-runtime.                                        // 118\n      Object.getOwnPropertyNames(superClass).forEach(function (k) {                                        // 119\n        // This property descriptor dance preserves getter/setter behavior                                 // 120\n        // in browsers that support accessor properties (all except                                        // 121\n        // IE8). In IE8, the superClass can't have accessor properties                                     // 122\n        // anyway, so this code is still safe.                                                             // 123\n        var descriptor = Object.getOwnPropertyDescriptor(superClass, k);                                   // 124\n        if (descriptor && typeof descriptor === \"object\") {                                                // 125\n          if (Object.getOwnPropertyDescriptor(subClass, k)) {                                              // 126\n            // If subClass already has a property by this name, then it                                    // 127\n            // would not be inherited, so it should not be copied. This                                    // 128\n            // notably excludes properties like .prototype and .name.                                      // 129\n            return;                                                                                        // 130\n          }                                                                                                // 131\n                                                                                                           // 132\n          Object.defineProperty(subClass, k, descriptor);                                                  // 133\n        }                                                                                                  // 134\n      });                                                                                                  // 135\n    }                                                                                                      // 136\n  },                                                                                                       // 137\n                                                                                                           // 138\n  createClass: (function () {                                                                              // 139\n    var hasDefineProperty = false;                                                                         // 140\n    try {                                                                                                  // 141\n      // IE 8 has a broken Object.defineProperty, so feature-test by                                       // 142\n      // trying to call it.                                                                                // 143\n      Object.defineProperty({}, 'x', {});                                                                  // 144\n      hasDefineProperty = true;                                                                            // 145\n    } catch (e) {}                                                                                         // 146\n                                                                                                           // 147\n    function defineProperties(target, props) {                                                             // 148\n      for (var i = 0; i < props.length; i++) {                                                             // 149\n        var descriptor = props[i];                                                                         // 150\n        descriptor.enumerable = descriptor.enumerable || false;                                            // 151\n        descriptor.configurable = true;                                                                    // 152\n        if (\"value\" in descriptor) descriptor.writable = true;                                             // 153\n        Object.defineProperty(target, descriptor.key, descriptor);                                         // 154\n      }                                                                                                    // 155\n    }                                                                                                      // 156\n                                                                                                           // 157\n    return function (Constructor, protoProps, staticProps) {                                               // 158\n      if (! hasDefineProperty) {                                                                           // 159\n        // e.g. `class Foo { get bar() {} }`.  If you try to use getters and                               // 160\n        // setters in IE 8, you will get a big nasty error, with or without                                // 161\n        // Babel.  I don't know of any other syntax features besides getters                               // 162\n        // and setters that will trigger this error.                                                       // 163\n        throw new Error(                                                                                   // 164\n          \"Your browser does not support this type of class property.  \" +                                 // 165\n            \"For example, Internet Explorer 8 does not support getters and \" +                             // 166\n            \"setters.\");                                                                                   // 167\n      }                                                                                                    // 168\n                                                                                                           // 169\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);                                 // 170\n      if (staticProps) defineProperties(Constructor, staticProps);                                         // 171\n      return Constructor;                                                                                  // 172\n    };                                                                                                     // 173\n  })(),                                                                                                    // 174\n                                                                                                           // 175\n  interopRequireDefault: function (obj) {                                                                  // 176\n    return obj && obj.__esModule ? obj : { 'default': obj };                                               // 177\n  },                                                                                                       // 178\n                                                                                                           // 179\n  // es7.objectRestSpread and react (JSX)                                                                  // 180\n  _extends: Object.assign || (function (target) {                                                          // 181\n    for (var i = 1; i < arguments.length; i++) {                                                           // 182\n      var source = arguments[i];                                                                           // 183\n      for (var key in source) {                                                                            // 184\n        if (hasOwn.call(source, key)) {                                                                    // 185\n          target[key] = source[key];                                                                       // 186\n        }                                                                                                  // 187\n      }                                                                                                    // 188\n    }                                                                                                      // 189\n    return target;                                                                                         // 190\n  }),                                                                                                      // 191\n                                                                                                           // 192\n  // es6.destructuring                                                                                     // 193\n  objectWithoutProperties: function (obj, keys) {                                                          // 194\n    var target = {};                                                                                       // 195\n    outer: for (var i in obj) {                                                                            // 196\n      if (! hasOwn.call(obj, i)) continue;                                                                 // 197\n      for (var j = 0; j < keys.length; j++) {                                                              // 198\n        if (keys[j] === i) continue outer;                                                                 // 199\n      }                                                                                                    // 200\n      target[i] = obj[i];                                                                                  // 201\n    }                                                                                                      // 202\n    return target;                                                                                         // 203\n  },                                                                                                       // 204\n                                                                                                           // 205\n  // es6.destructuring                                                                                     // 206\n  objectDestructuringEmpty: function (obj) {                                                               // 207\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");                                  // 208\n  },                                                                                                       // 209\n                                                                                                           // 210\n  // es6.spread                                                                                            // 211\n  bind: Function.prototype.bind || (function () {                                                          // 212\n    var isCallable = function (value) { return typeof value === 'function'; };                             // 213\n    var $Object = Object;                                                                                  // 214\n    var to_string = Object.prototype.toString;                                                             // 215\n    var array_slice = Array.prototype.slice;                                                               // 216\n    var array_concat = Array.prototype.concat;                                                             // 217\n    var array_push = Array.prototype.push;                                                                 // 218\n    var max = Math.max;                                                                                    // 219\n    var Empty = function Empty() {};                                                                       // 220\n                                                                                                           // 221\n    // Copied from es5-shim.js (3ac7942).  See original for more comments.                                 // 222\n    return function bind(that) {                                                                           // 223\n      var target = this;                                                                                   // 224\n      if (!isCallable(target)) {                                                                           // 225\n        throw new TypeError('Function.prototype.bind called on incompatible ' + target);                   // 226\n      }                                                                                                    // 227\n                                                                                                           // 228\n      var args = array_slice.call(arguments, 1);                                                           // 229\n                                                                                                           // 230\n      var bound;                                                                                           // 231\n      var binder = function () {                                                                           // 232\n                                                                                                           // 233\n        if (this instanceof bound) {                                                                       // 234\n          var result = target.apply(                                                                       // 235\n            this,                                                                                          // 236\n            array_concat.call(args, array_slice.call(arguments))                                           // 237\n          );                                                                                               // 238\n          if ($Object(result) === result) {                                                                // 239\n            return result;                                                                                 // 240\n          }                                                                                                // 241\n          return this;                                                                                     // 242\n        } else {                                                                                           // 243\n          return target.apply(                                                                             // 244\n            that,                                                                                          // 245\n            array_concat.call(args, array_slice.call(arguments))                                           // 246\n          );                                                                                               // 247\n        }                                                                                                  // 248\n      };                                                                                                   // 249\n                                                                                                           // 250\n      var boundLength = max(0, target.length - args.length);                                               // 251\n                                                                                                           // 252\n      var boundArgs = [];                                                                                  // 253\n      for (var i = 0; i < boundLength; i++) {                                                              // 254\n        array_push.call(boundArgs, '$' + i);                                                               // 255\n      }                                                                                                    // 256\n                                                                                                           // 257\n      // Create a Function from source code so that it has the right `.length`.                            // 258\n      // Probably not important for Babel.  This code violates CSPs that ban                               // 259\n      // `eval`, but the browsers that need this polyfill don't have CSP!                                  // 260\n      bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n                                                                                                           // 262\n      if (target.prototype) {                                                                              // 263\n        Empty.prototype = target.prototype;                                                                // 264\n        bound.prototype = new Empty();                                                                     // 265\n        Empty.prototype = null;                                                                            // 266\n      }                                                                                                    // 267\n                                                                                                           // 268\n      return bound;                                                                                        // 269\n    };                                                                                                     // 270\n                                                                                                           // 271\n  })(),                                                                                                    // 272\n                                                                                                           // 273\n  slice: Array.prototype.slice                                                                             // 274\n};                                                                                                         // 275\n                                                                                                           // 276\n/////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['babel-runtime'] = {}, {\n  babelHelpers: babelHelpers\n});\n\n})();\n","servePath":"/packages/babel-runtime.js","sourceMap":{"version":3,"sources":["/packages/babel-runtime/babel-runtime.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iH","file":"/packages/babel-runtime.js","sourcesContent":["var hasOwn = Object.prototype.hasOwnProperty;\n\nfunction canDefineNonEnumerableProperties() {\n  var testObj = {};\n  var testPropName = \"t\";\n\n  try {\n    Object.defineProperty(testObj, testPropName, {\n      enumerable: false,\n      value: testObj\n    });\n\n    for (var k in testObj) {\n      if (k === testPropName) {\n        return false;\n      }\n    }\n  } catch (e) {\n    return false;\n  }\n\n  return testObj[testPropName] === testObj;\n}\n\n// The name `babelHelpers` is hard-coded in Babel.  Otherwise we would make it\n// something capitalized and more descriptive, like `BabelRuntime`.\nbabelHelpers = {\n  // Meteor-specific runtime helper for wrapping the object of for-in\n  // loops, so that inherited Array methods defined by es5-shim can be\n  // ignored in browsers where they cannot be defined as non-enumerable.\n  sanitizeForInObject: canDefineNonEnumerableProperties()\n    ? function (value) { return value; }\n    : function (obj) {\n      if (Array.isArray(obj)) {\n        var newObj = {};\n        var keys = Object.keys(obj);\n        var keyCount = keys.length;\n        for (var i = 0; i < keyCount; ++i) {\n          var key = keys[i];\n          newObj[key] = obj[key];\n        }\n        return newObj;\n      }\n\n      return obj;\n    },\n\n  // es6.templateLiterals\n  // Constructs the object passed to the tag function in a tagged\n  // template literal.\n  taggedTemplateLiteralLoose: function (strings, raw) {\n    // Babel's own version of this calls Object.freeze on `strings` and\n    // `strings.raw`, but it doesn't seem worth the compatibility and\n    // performance concerns.  If you're writing code against this helper,\n    // don't add properties to these objects.\n    strings.raw = raw;\n    return strings;\n  },\n\n  // es6.classes\n  // Checks that a class constructor is being called with `new`, and throws\n  // an error if it is not.\n  classCallCheck: function (instance, Constructor) {\n    if (!(instance instanceof Constructor)) {\n      throw new TypeError(\"Cannot call a class as a function\");\n    }\n  },\n\n  // es6.classes\n  inherits: function (subClass, superClass) {\n    if (typeof superClass !== \"function\" && superClass !== null) {\n      throw new TypeError(\"Super expression must either be null or a function, not \" + typeof superClass);\n    }\n\n    if (superClass) {\n      if (Object.create) {\n        // All but IE 8\n        subClass.prototype = Object.create(superClass.prototype, {\n          constructor: {\n            value: subClass,\n            enumerable: false,\n            writable: true,\n            configurable: true\n          }\n        });\n      } else {\n        // IE 8 path.  Slightly worse for modern browsers, because `constructor`\n        // is enumerable and shows up in the inspector unnecessarily.\n        // It's not an \"own\" property of any instance though.\n        //\n        // For correctness when writing code,\n        // don't enumerate all the own-and-inherited properties of an instance\n        // of a class and expect not to find `constructor` (but who does that?).\n        var F = function () {\n          this.constructor = subClass;\n        };\n        F.prototype = superClass.prototype;\n        subClass.prototype = new F();\n      }\n\n      // For modern browsers, this would be `subClass.__proto__ = superClass`,\n      // but IE <=10 don't support `__proto__`, and in this case the difference\n      // would be detectable; code that works in modern browsers could easily\n      // fail on IE 8 if we ever used the `__proto__` trick.\n      //\n      // There's no perfect way to make static methods inherited if they are\n      // assigned after declaration of the classes.  The best we can do is\n      // to copy them.  In other words, when you write `class Foo\n      // extends Bar`, we copy the static methods from Bar onto Foo, but future\n      // ones are not copied.\n      //\n      // For correctness when writing code, don't add static methods to a class\n      // after you subclass it.\n\n      // The ecmascript-runtime package provides adequate polyfills for\n      // all of these Object.* functions (and Array#forEach), and anyone\n      // using babel-runtime is almost certainly using it because of the\n      // ecmascript package, which also implies ecmascript-runtime.\n      Object.getOwnPropertyNames(superClass).forEach(function (k) {\n        // This property descriptor dance preserves getter/setter behavior\n        // in browsers that support accessor properties (all except\n        // IE8). In IE8, the superClass can't have accessor properties\n        // anyway, so this code is still safe.\n        var descriptor = Object.getOwnPropertyDescriptor(superClass, k);\n        if (descriptor && typeof descriptor === \"object\") {\n          if (Object.getOwnPropertyDescriptor(subClass, k)) {\n            // If subClass already has a property by this name, then it\n            // would not be inherited, so it should not be copied. This\n            // notably excludes properties like .prototype and .name.\n            return;\n          }\n\n          Object.defineProperty(subClass, k, descriptor);\n        }\n      });\n    }\n  },\n\n  createClass: (function () {\n    var hasDefineProperty = false;\n    try {\n      // IE 8 has a broken Object.defineProperty, so feature-test by\n      // trying to call it.\n      Object.defineProperty({}, 'x', {});\n      hasDefineProperty = true;\n    } catch (e) {}\n\n    function defineProperties(target, props) {\n      for (var i = 0; i < props.length; i++) {\n        var descriptor = props[i];\n        descriptor.enumerable = descriptor.enumerable || false;\n        descriptor.configurable = true;\n        if (\"value\" in descriptor) descriptor.writable = true;\n        Object.defineProperty(target, descriptor.key, descriptor);\n      }\n    }\n\n    return function (Constructor, protoProps, staticProps) {\n      if (! hasDefineProperty) {\n        // e.g. `class Foo { get bar() {} }`.  If you try to use getters and\n        // setters in IE 8, you will get a big nasty error, with or without\n        // Babel.  I don't know of any other syntax features besides getters\n        // and setters that will trigger this error.\n        throw new Error(\n          \"Your browser does not support this type of class property.  \" +\n            \"For example, Internet Explorer 8 does not support getters and \" +\n            \"setters.\");\n      }\n\n      if (protoProps) defineProperties(Constructor.prototype, protoProps);\n      if (staticProps) defineProperties(Constructor, staticProps);\n      return Constructor;\n    };\n  })(),\n\n  interopRequireDefault: function (obj) {\n    return obj && obj.__esModule ? obj : { 'default': obj };\n  },\n\n  // es7.objectRestSpread and react (JSX)\n  _extends: Object.assign || (function (target) {\n    for (var i = 1; i < arguments.length; i++) {\n      var source = arguments[i];\n      for (var key in source) {\n        if (hasOwn.call(source, key)) {\n          target[key] = source[key];\n        }\n      }\n    }\n    return target;\n  }),\n\n  // es6.destructuring\n  objectWithoutProperties: function (obj, keys) {\n    var target = {};\n    outer: for (var i in obj) {\n      if (! hasOwn.call(obj, i)) continue;\n      for (var j = 0; j < keys.length; j++) {\n        if (keys[j] === i) continue outer;\n      }\n      target[i] = obj[i];\n    }\n    return target;\n  },\n\n  // es6.destructuring\n  objectDestructuringEmpty: function (obj) {\n    if (obj == null) throw new TypeError(\"Cannot destructure undefined\");\n  },\n\n  // es6.spread\n  bind: Function.prototype.bind || (function () {\n    var isCallable = function (value) { return typeof value === 'function'; };\n    var $Object = Object;\n    var to_string = Object.prototype.toString;\n    var array_slice = Array.prototype.slice;\n    var array_concat = Array.prototype.concat;\n    var array_push = Array.prototype.push;\n    var max = Math.max;\n    var Empty = function Empty() {};\n\n    // Copied from es5-shim.js (3ac7942).  See original for more comments.\n    return function bind(that) {\n      var target = this;\n      if (!isCallable(target)) {\n        throw new TypeError('Function.prototype.bind called on incompatible ' + target);\n      }\n\n      var args = array_slice.call(arguments, 1);\n\n      var bound;\n      var binder = function () {\n\n        if (this instanceof bound) {\n          var result = target.apply(\n            this,\n            array_concat.call(args, array_slice.call(arguments))\n          );\n          if ($Object(result) === result) {\n            return result;\n          }\n          return this;\n        } else {\n          return target.apply(\n            that,\n            array_concat.call(args, array_slice.call(arguments))\n          );\n        }\n      };\n\n      var boundLength = max(0, target.length - args.length);\n\n      var boundArgs = [];\n      for (var i = 0; i < boundLength; i++) {\n        array_push.call(boundArgs, '$' + i);\n      }\n\n      // Create a Function from source code so that it has the right `.length`.\n      // Probably not important for Babel.  This code violates CSPs that ban\n      // `eval`, but the browsers that need this polyfill don't have CSP!\n      bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this, arguments); }')(binder);\n\n      if (target.prototype) {\n        Empty.prototype = target.prototype;\n        bound.prototype = new Empty();\n        Empty.prototype = null;\n      }\n\n      return bound;\n    };\n\n  })(),\n\n  slice: Array.prototype.slice\n};\n"]}}]