[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Package-scope variables */\nvar makeInstaller, meteorInstall;\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////\n//                                                                             //\n// packages/modules/.npm/package/node_modules/install/install.js               //\n//                                                                             //\n/////////////////////////////////////////////////////////////////////////////////\n                                                                               //\nmakeInstaller = function (options) {                                           // 1\n  options = options || {};                                                     // 2\n                                                                               // 3\n  // These file extensions will be appended to required module identifiers     // 4\n  // if they do not exactly match an installed module.                         // 5\n  var extensions = options.extensions || [\".js\", \".json\"];                     // 6\n                                                                               // 7\n  // This constructor will be used to instantiate the module objects           // 8\n  // passed to module factory functions (i.e. the third argument after         // 9\n  // require and exports).                                                     // 10\n  var Module = options.Module || function Module(id, parent) {                 // 11\n    this.id = id;                                                              // 12\n    this.parent = parent;                                                      // 13\n  };                                                                           // 14\n                                                                               // 15\n  // If defined, the options.onInstall function will be called any time        // 16\n  // new modules are installed.                                                // 17\n  var onInstall = options.onInstall;                                           // 18\n                                                                               // 19\n  // If defined, the options.fallback function will be called when no          // 20\n  // installed module is found for a required module identifier. Often         // 21\n  // options.fallback will be implemented in terms of the native Node          // 22\n  // require function, which has the ability to load binary modules.           // 23\n  var fallback = options.fallback;                                             // 24\n                                                                               // 25\n  // Whenever a new require function is created in the makeRequire             // 26\n  // function below, any methods contained by options.requireMethods will      // 27\n  // be bound and attached as methods to that function object. This option     // 28\n  // is intended to support user-defined require.* extensions like             // 29\n  // require.ensure and require.promise.                                       // 30\n  var requireMethods = options.requireMethods;                                 // 31\n                                                                               // 32\n  // Sentinel returned by fileEvaluate when module resolution fails.           // 33\n  var MISSING = {};                                                            // 34\n                                                                               // 35\n  // Nothing special about MISSING.hasOwnProperty, except that it's fewer      // 36\n  // characters than Object.prototype.hasOwnProperty after minification.       // 37\n  var hasOwn = MISSING.hasOwnProperty;                                         // 38\n                                                                               // 39\n  // The file object representing the root directory of the installed          // 40\n  // module tree.                                                              // 41\n  var root = new File({});                                                     // 42\n                                                                               // 43\n  // Merges the given tree of directories and module factory functions         // 44\n  // into the tree of installed modules and returns a require function         // 45\n  // that behaves as if called from a module in the root directory.            // 46\n  function install(tree) {                                                     // 47\n    if (isObject(tree)) {                                                      // 48\n      fileMergeContents(root, tree);                                           // 49\n      if (isFunction(onInstall)) {                                             // 50\n        onInstall(root.r);                                                     // 51\n      }                                                                        // 52\n    }                                                                          // 53\n    return root.r;                                                             // 54\n  }                                                                            // 55\n                                                                               // 56\n  function getOwn(obj, key) {                                                  // 57\n    return hasOwn.call(obj, key) && obj[key];                                  // 58\n  }                                                                            // 59\n                                                                               // 60\n  function isObject(value) {                                                   // 61\n    return value && typeof value === \"object\";                                 // 62\n  }                                                                            // 63\n                                                                               // 64\n  function isFunction(value) {                                                 // 65\n    return typeof value === \"function\";                                        // 66\n  }                                                                            // 67\n                                                                               // 68\n  function isString(value) {                                                   // 69\n    return typeof value === \"string\";                                          // 70\n  }                                                                            // 71\n                                                                               // 72\n  function makeRequire(file) {                                                 // 73\n    function require(id) {                                                     // 74\n      var result = fileEvaluate(fileResolve(file, id));                        // 75\n      if (result === MISSING) {                                                // 76\n        var error = new Error(\"Cannot find module '\" + id + \"'\");              // 77\n        if (isFunction(fallback)) {                                            // 78\n          result = fallback(                                                   // 79\n            id, // The missing module identifier.                              // 80\n            file.m.id, // The path of the enclosing directory.                 // 81\n            error // The error we would have thrown.                           // 82\n          );                                                                   // 83\n        } else throw error;                                                    // 84\n      }                                                                        // 85\n      return result;                                                           // 86\n    }                                                                          // 87\n                                                                               // 88\n    // A function that immediately returns true iff all the transitive         // 89\n    // dependencies of the module identified by id have been installed.        // 90\n    // This function can be used with options.onInstall to implement           // 91\n    // asynchronous module loading APIs like require.ensure.                   // 92\n    require.ready = function (id) {                                            // 93\n      return fileReady(fileResolve(file, id));                                 // 94\n    };                                                                         // 95\n                                                                               // 96\n    if (requireMethods) {                                                      // 97\n      Object.keys(requireMethods).forEach(function (name) {                    // 98\n        if (isFunction(requireMethods[name])) {                                // 99\n          require[name] = requireMethods[name].bind(require);                  // 100\n        }                                                                      // 101\n      });                                                                      // 102\n    }                                                                          // 103\n                                                                               // 104\n    return require;                                                            // 105\n  }                                                                            // 106\n                                                                               // 107\n  // File objects represent either directories or modules that have been       // 108\n  // installed. When a `File` respresents a directory, its `.c` (contents)     // 109\n  // property is an object containing the names of the files (or               // 110\n  // directories) that it contains. When a `File` represents a module, its     // 111\n  // `.c` property is a function that can be invoked with the appropriate      // 112\n  // `(require, exports, module)` arguments to evaluate the module. The        // 113\n  // `.p` (parent) property of a File is either a directory `File` or          // 114\n  // `null`. Note that a child may claim another `File` as its parent even     // 115\n  // if the parent does not have an entry for that child in its `.c`           // 116\n  // object.  This is important for implementing anonymous files, and          // 117\n  // preventing child modules from using `../relative/identifier` syntax       // 118\n  // to examine unrelated modules.                                             // 119\n  function File(contents, /*optional:*/ parent, name) {                        // 120\n    var file = this;                                                           // 121\n                                                                               // 122\n    // Link to the parent file.                                                // 123\n    file.p = parent = parent || null;                                          // 124\n                                                                               // 125\n    // The module object for this File, which will eventually boast an         // 126\n    // .exports property when/if the file is evaluated.                        // 127\n    file.m = new Module(                                                       // 128\n      // If this file was created with `name`, join it with `parent.m.id`      // 129\n      // to generate a module identifier.                                      // 130\n      name ? (parent && parent.m.id || \"\") + \"/\" + name : null,                // 131\n      parent && parent.m                                                       // 132\n    );                                                                         // 133\n                                                                               // 134\n    // Queue for tracking required modules with unmet dependencies,            // 135\n    // inherited from the `parent`.                                            // 136\n    file.q = parent && parent.q;                                               // 137\n                                                                               // 138\n    // Each directory has its own bound version of the `require` function      // 139\n    // that can resolve relative identifiers. Non-directory Files inherit      // 140\n    // the require function of their parent directories, so we don't have      // 141\n    // to create a new require function every time we evaluate a module.       // 142\n    file.r = isObject(contents)                                                // 143\n      ? makeRequire(file)                                                      // 144\n      : parent && parent.r;                                                    // 145\n                                                                               // 146\n    // Set the initial value of `file.c` (the \"contents\" of the File).         // 147\n    fileMergeContents(file, contents);                                         // 148\n                                                                               // 149\n    // When the file is a directory, `file.ready` is an object mapping         // 150\n    // module identifiers to boolean ready statuses. This information can      // 151\n    // be shared by all files in the directory, because module resolution      // 152\n    // always has the same results for all files in a given directory.         // 153\n    file.ready = fileIsDirectory(file) && {};                                  // 154\n  }                                                                            // 155\n                                                                               // 156\n  // A file is ready if all of its dependencies are installed and ready.       // 157\n  function fileReady(file) {                                                   // 158\n    var result = !! file;                                                      // 159\n    var factory = file && file.c;                                              // 160\n    var deps = isFunction(factory) && factory.d;                               // 161\n    if (deps && ! getOwn(factory, \"seen\")) {                                   // 162\n      factory.seen = true;                                                     // 163\n      var parentReadyCache = file.p.ready;                                     // 164\n      result = deps.every(function (dep) {                                     // 165\n        // By storing the results of these lookups in `parentReadyCache`,      // 166\n        // we benefit when any other file in the same directory resolves       // 167\n        // the same identifier.                                                // 168\n        return parentReadyCache[dep] =                                         // 169\n          parentReadyCache[dep] ||                                             // 170\n          fileReady(fileResolve(file.p, dep));                                 // 171\n      });                                                                      // 172\n      factory.seen = false;                                                    // 173\n    }                                                                          // 174\n    return result;                                                             // 175\n  }                                                                            // 176\n                                                                               // 177\n  function fileEvaluate(file) {                                                // 178\n    var factory = file && file.c;                                              // 179\n    if (isFunction(factory)) {                                                 // 180\n      var module = file.m;                                                     // 181\n      if (! hasOwn.call(module, \"exports\")) {                                  // 182\n        factory(file.r, module.exports = {}, module);                          // 183\n      }                                                                        // 184\n      return module.exports;                                                   // 185\n    }                                                                          // 186\n    return MISSING;                                                            // 187\n  }                                                                            // 188\n                                                                               // 189\n  function fileIsDirectory(file) {                                             // 190\n    return isObject(file.c);                                                   // 191\n  }                                                                            // 192\n                                                                               // 193\n  function fileMergeContents(file, contents) {                                 // 194\n    // If contents is an array of strings and functions, return the last       // 195\n    // function with a `.d` property containing all the strings.               // 196\n    if (Array.isArray(contents)) {                                             // 197\n      var deps = [];                                                           // 198\n                                                                               // 199\n      contents.forEach(function (item) {                                       // 200\n        if (isString(item)) {                                                  // 201\n          deps.push(item);                                                     // 202\n        } else if (isFunction(item)) {                                         // 203\n          contents = item;                                                     // 204\n        }                                                                      // 205\n      });                                                                      // 206\n                                                                               // 207\n      if (isFunction(contents)) {                                              // 208\n        contents.d = deps;                                                     // 209\n      } else {                                                                 // 210\n        // If the array did not contain a function, merge nothing.             // 211\n        contents = null;                                                       // 212\n      }                                                                        // 213\n                                                                               // 214\n    } else if (isFunction(contents)) {                                         // 215\n      // If contents is already a function, make sure it has `.d`.             // 216\n      contents.d = contents.d || [];                                           // 217\n                                                                               // 218\n    } else if (! isObject(contents)) {                                         // 219\n      // If contents is neither an array nor a function nor an object,         // 220\n      // just give up and merge nothing.                                       // 221\n      contents = null;                                                         // 222\n    }                                                                          // 223\n                                                                               // 224\n    if (contents) {                                                            // 225\n      var fileContents = file.c = file.c || (                                  // 226\n        isFunction(contents) ? contents : {}                                   // 227\n      );                                                                       // 228\n                                                                               // 229\n      if (isObject(contents) && fileIsDirectory(file)) {                       // 230\n        Object.keys(contents).forEach(function (key) {                         // 231\n          var child = getOwn(fileContents, key);                               // 232\n          if (child) {                                                         // 233\n            fileMergeContents(child, contents[key]);                           // 234\n          } else {                                                             // 235\n            fileContents[key] = new File(contents[key], file, key);            // 236\n          }                                                                    // 237\n        });                                                                    // 238\n      }                                                                        // 239\n    }                                                                          // 240\n  }                                                                            // 241\n                                                                               // 242\n  function fileAppendIdPart(file, part, isLastPart) {                          // 243\n    // Always append relative to a directory.                                  // 244\n    while (file && ! fileIsDirectory(file)) {                                  // 245\n      file = file.p;                                                           // 246\n    }                                                                          // 247\n                                                                               // 248\n    if (! file || ! part || part === \".\") {                                    // 249\n      return file;                                                             // 250\n    }                                                                          // 251\n                                                                               // 252\n    if (part === \"..\") {                                                       // 253\n      return file.p;                                                           // 254\n    }                                                                          // 255\n                                                                               // 256\n    var exactChild = getOwn(file.c, part);                                     // 257\n                                                                               // 258\n    // Only consider multiple file extensions if this part is the last         // 259\n    // part of a module identifier and not equal to `.` or `..`, and there     // 260\n    // was no exact match or the exact match was a directory.                  // 261\n    if (isLastPart && (! exactChild || fileIsDirectory(exactChild))) {         // 262\n      for (var e = 0; e < extensions.length; ++e) {                            // 263\n        var child = getOwn(file.c, part + extensions[e]);                      // 264\n        if (child) {                                                           // 265\n          return child;                                                        // 266\n        }                                                                      // 267\n      }                                                                        // 268\n    }                                                                          // 269\n                                                                               // 270\n    return exactChild;                                                         // 271\n  }                                                                            // 272\n                                                                               // 273\n  function fileAppendId(file, id) {                                            // 274\n    var parts = id.split(\"/\");                                                 // 275\n    // Use `Array.prototype.every` to terminate iteration early if             // 276\n    // `fileAppendIdPart` returns a falsy value.                               // 277\n    parts.every(function (part, i) {                                           // 278\n      return file = fileAppendIdPart(file, part, i === parts.length - 1);      // 279\n    });                                                                        // 280\n    return file;                                                               // 281\n  }                                                                            // 282\n                                                                               // 283\n  function fileResolve(file, id) {                                             // 284\n    file =                                                                     // 285\n      // Absolute module identifiers (i.e. those that begin with a `/`         // 286\n      // character) are interpreted relative to the root directory, which      // 287\n      // is a slight deviation from Node, which has access to the entire       // 288\n      // file system.                                                          // 289\n      id.charAt(0) === \"/\" ? fileAppendId(root, id) :                          // 290\n      // Relative module identifiers are interpreted relative to the           // 291\n      // current file, naturally.                                              // 292\n      id.charAt(0) === \".\" ? fileAppendId(file, id) :                          // 293\n      // Top-level module identifiers are interpreted as referring to          // 294\n      // packages in `node_modules` directories.                               // 295\n      nodeModulesLookup(file, id);                                             // 296\n                                                                               // 297\n    // If the identifier resolves to a directory, we use the same logic as     // 298\n    // Node to find an `index.js` or `package.json` file to evaluate.          // 299\n    while (file && fileIsDirectory(file)) {                                    // 300\n      // If `package.json` does not exist, `fileEvaluate` will return the      // 301\n      // `MISSING` object, which has no `.main` property.                      // 302\n      var pkg = fileEvaluate(fileAppendIdPart(file, \"package.json\"));          // 303\n      file = pkg && isString(pkg.main) &&                                      // 304\n        fileAppendId(file, pkg.main) || // Might resolve to another directory!\n        fileAppendIdPart(file, \"index.js\");                                    // 306\n    }                                                                          // 307\n                                                                               // 308\n    return file;                                                               // 309\n  };                                                                           // 310\n                                                                               // 311\n  function nodeModulesLookup(file, id) {                                       // 312\n    return fileIsDirectory(file) &&                                            // 313\n      fileAppendId(file, \"node_modules/\" + id) ||                              // 314\n      (file.p && nodeModulesLookup(file.p, id));                               // 315\n  }                                                                            // 316\n                                                                               // 317\n  return install;                                                              // 318\n};                                                                             // 319\n                                                                               // 320\nif (typeof exports === \"object\") {                                             // 321\n  exports.makeInstaller = makeInstaller;                                       // 322\n}                                                                              // 323\n                                                                               // 324\n/////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n\n\n\n\n(function(){\n\n/////////////////////////////////////////////////////////////////////////////////\n//                                                                             //\n// packages/modules/modules.js                                                 //\n//                                                                             //\n/////////////////////////////////////////////////////////////////////////////////\n                                                                               //\nvar options = {};                                                              // 1\nvar hasOwn = options.hasOwnProperty;                                           // 2\n                                                                               // 3\n// RegExp matching strings that don't start with a `.` or a `/`.               // 4\nvar topLevelIdPattern = /^[^./]/;                                              // 5\n                                                                               // 6\n// This function will be called whenever a module identifier that hasn't       // 7\n// been installed is required. For backwards compatibility, and so that we     // 8\n// can require binary dependencies on the server, we implement the             // 9\n// fallback in terms of Npm.require.                                           // 10\noptions.fallback = function (id, dir, error) {                                 // 11\n  // For simplicity, we honor only top-level module identifiers here.          // 12\n  // We could try to honor relative and absolute module identifiers by         // 13\n  // somehow combining `id` with `dir`, but we'd have to be really careful     // 14\n  // that the resulting modules were located in a known directory (not         // 15\n  // some arbitrary location on the file system), and we only really need      // 16\n  // the fallback for dependencies installed in node_modules directories.      // 17\n  if (topLevelIdPattern.test(id)) {                                            // 18\n    var parts = id.split(\"/\");                                                 // 19\n    if (parts.length === 2 &&                                                  // 20\n        parts[0] === \"meteor\" &&                                               // 21\n        hasOwn.call(Package, parts[1])) {                                      // 22\n      return Package[parts[1]];                                                // 23\n    }                                                                          // 24\n                                                                               // 25\n    if (typeof Npm === \"object\" &&                                             // 26\n        typeof Npm.require === \"function\") {                                   // 27\n      return Npm.require(id);                                                  // 28\n    }                                                                          // 29\n  }                                                                            // 30\n                                                                               // 31\n  throw error;                                                                 // 32\n};                                                                             // 33\n                                                                               // 34\nmeteorInstall = makeInstaller(options);                                        // 35\n                                                                               // 36\n/////////////////////////////////////////////////////////////////////////////////\n\n}).call(this);\n\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package.modules = {}, {\n  meteorInstall: meteorInstall\n});\n\n})();\n","servePath":"/packages/modules.js","sourceMap":{"version":3,"sources":["/packages/modules/.npm/package/node_modules/install/install.js","/packages/modules/modules.js"],"names":[],"mappings":";;;;;;;;;;;;;;;;;;;;;;;AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qF;;;;;;;;;;;;;;;;;;ACnUA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oF","file":"/packages/modules.js","sourcesContent":["makeInstaller = function (options) {\n  options = options || {};\n\n  // These file extensions will be appended to required module identifiers\n  // if they do not exactly match an installed module.\n  var extensions = options.extensions || [\".js\", \".json\"];\n\n  // This constructor will be used to instantiate the module objects\n  // passed to module factory functions (i.e. the third argument after\n  // require and exports).\n  var Module = options.Module || function Module(id, parent) {\n    this.id = id;\n    this.parent = parent;\n  };\n\n  // If defined, the options.onInstall function will be called any time\n  // new modules are installed.\n  var onInstall = options.onInstall;\n\n  // If defined, the options.fallback function will be called when no\n  // installed module is found for a required module identifier. Often\n  // options.fallback will be implemented in terms of the native Node\n  // require function, which has the ability to load binary modules.\n  var fallback = options.fallback;\n\n  // Whenever a new require function is created in the makeRequire\n  // function below, any methods contained by options.requireMethods will\n  // be bound and attached as methods to that function object. This option\n  // is intended to support user-defined require.* extensions like\n  // require.ensure and require.promise.\n  var requireMethods = options.requireMethods;\n\n  // Sentinel returned by fileEvaluate when module resolution fails.\n  var MISSING = {};\n\n  // Nothing special about MISSING.hasOwnProperty, except that it's fewer\n  // characters than Object.prototype.hasOwnProperty after minification.\n  var hasOwn = MISSING.hasOwnProperty;\n\n  // The file object representing the root directory of the installed\n  // module tree.\n  var root = new File({});\n\n  // Merges the given tree of directories and module factory functions\n  // into the tree of installed modules and returns a require function\n  // that behaves as if called from a module in the root directory.\n  function install(tree) {\n    if (isObject(tree)) {\n      fileMergeContents(root, tree);\n      if (isFunction(onInstall)) {\n        onInstall(root.r);\n      }\n    }\n    return root.r;\n  }\n\n  function getOwn(obj, key) {\n    return hasOwn.call(obj, key) && obj[key];\n  }\n\n  function isObject(value) {\n    return value && typeof value === \"object\";\n  }\n\n  function isFunction(value) {\n    return typeof value === \"function\";\n  }\n\n  function isString(value) {\n    return typeof value === \"string\";\n  }\n\n  function makeRequire(file) {\n    function require(id) {\n      var result = fileEvaluate(fileResolve(file, id));\n      if (result === MISSING) {\n        var error = new Error(\"Cannot find module '\" + id + \"'\");\n        if (isFunction(fallback)) {\n          result = fallback(\n            id, // The missing module identifier.\n            file.m.id, // The path of the enclosing directory.\n            error // The error we would have thrown.\n          );\n        } else throw error;\n      }\n      return result;\n    }\n\n    // A function that immediately returns true iff all the transitive\n    // dependencies of the module identified by id have been installed.\n    // This function can be used with options.onInstall to implement\n    // asynchronous module loading APIs like require.ensure.\n    require.ready = function (id) {\n      return fileReady(fileResolve(file, id));\n    };\n\n    if (requireMethods) {\n      Object.keys(requireMethods).forEach(function (name) {\n        if (isFunction(requireMethods[name])) {\n          require[name] = requireMethods[name].bind(require);\n        }\n      });\n    }\n\n    return require;\n  }\n\n  // File objects represent either directories or modules that have been\n  // installed. When a `File` respresents a directory, its `.c` (contents)\n  // property is an object containing the names of the files (or\n  // directories) that it contains. When a `File` represents a module, its\n  // `.c` property is a function that can be invoked with the appropriate\n  // `(require, exports, module)` arguments to evaluate the module. The\n  // `.p` (parent) property of a File is either a directory `File` or\n  // `null`. Note that a child may claim another `File` as its parent even\n  // if the parent does not have an entry for that child in its `.c`\n  // object.  This is important for implementing anonymous files, and\n  // preventing child modules from using `../relative/identifier` syntax\n  // to examine unrelated modules.\n  function File(contents, /*optional:*/ parent, name) {\n    var file = this;\n\n    // Link to the parent file.\n    file.p = parent = parent || null;\n\n    // The module object for this File, which will eventually boast an\n    // .exports property when/if the file is evaluated.\n    file.m = new Module(\n      // If this file was created with `name`, join it with `parent.m.id`\n      // to generate a module identifier.\n      name ? (parent && parent.m.id || \"\") + \"/\" + name : null,\n      parent && parent.m\n    );\n\n    // Queue for tracking required modules with unmet dependencies,\n    // inherited from the `parent`.\n    file.q = parent && parent.q;\n\n    // Each directory has its own bound version of the `require` function\n    // that can resolve relative identifiers. Non-directory Files inherit\n    // the require function of their parent directories, so we don't have\n    // to create a new require function every time we evaluate a module.\n    file.r = isObject(contents)\n      ? makeRequire(file)\n      : parent && parent.r;\n\n    // Set the initial value of `file.c` (the \"contents\" of the File).\n    fileMergeContents(file, contents);\n\n    // When the file is a directory, `file.ready` is an object mapping\n    // module identifiers to boolean ready statuses. This information can\n    // be shared by all files in the directory, because module resolution\n    // always has the same results for all files in a given directory.\n    file.ready = fileIsDirectory(file) && {};\n  }\n\n  // A file is ready if all of its dependencies are installed and ready.\n  function fileReady(file) {\n    var result = !! file;\n    var factory = file && file.c;\n    var deps = isFunction(factory) && factory.d;\n    if (deps && ! getOwn(factory, \"seen\")) {\n      factory.seen = true;\n      var parentReadyCache = file.p.ready;\n      result = deps.every(function (dep) {\n        // By storing the results of these lookups in `parentReadyCache`,\n        // we benefit when any other file in the same directory resolves\n        // the same identifier.\n        return parentReadyCache[dep] =\n          parentReadyCache[dep] ||\n          fileReady(fileResolve(file.p, dep));\n      });\n      factory.seen = false;\n    }\n    return result;\n  }\n\n  function fileEvaluate(file) {\n    var factory = file && file.c;\n    if (isFunction(factory)) {\n      var module = file.m;\n      if (! hasOwn.call(module, \"exports\")) {\n        factory(file.r, module.exports = {}, module);\n      }\n      return module.exports;\n    }\n    return MISSING;\n  }\n\n  function fileIsDirectory(file) {\n    return isObject(file.c);\n  }\n\n  function fileMergeContents(file, contents) {\n    // If contents is an array of strings and functions, return the last\n    // function with a `.d` property containing all the strings.\n    if (Array.isArray(contents)) {\n      var deps = [];\n\n      contents.forEach(function (item) {\n        if (isString(item)) {\n          deps.push(item);\n        } else if (isFunction(item)) {\n          contents = item;\n        }\n      });\n\n      if (isFunction(contents)) {\n        contents.d = deps;\n      } else {\n        // If the array did not contain a function, merge nothing.\n        contents = null;\n      }\n\n    } else if (isFunction(contents)) {\n      // If contents is already a function, make sure it has `.d`.\n      contents.d = contents.d || [];\n\n    } else if (! isObject(contents)) {\n      // If contents is neither an array nor a function nor an object,\n      // just give up and merge nothing.\n      contents = null;\n    }\n\n    if (contents) {\n      var fileContents = file.c = file.c || (\n        isFunction(contents) ? contents : {}\n      );\n\n      if (isObject(contents) && fileIsDirectory(file)) {\n        Object.keys(contents).forEach(function (key) {\n          var child = getOwn(fileContents, key);\n          if (child) {\n            fileMergeContents(child, contents[key]);\n          } else {\n            fileContents[key] = new File(contents[key], file, key);\n          }\n        });\n      }\n    }\n  }\n\n  function fileAppendIdPart(file, part, isLastPart) {\n    // Always append relative to a directory.\n    while (file && ! fileIsDirectory(file)) {\n      file = file.p;\n    }\n\n    if (! file || ! part || part === \".\") {\n      return file;\n    }\n\n    if (part === \"..\") {\n      return file.p;\n    }\n\n    var exactChild = getOwn(file.c, part);\n\n    // Only consider multiple file extensions if this part is the last\n    // part of a module identifier and not equal to `.` or `..`, and there\n    // was no exact match or the exact match was a directory.\n    if (isLastPart && (! exactChild || fileIsDirectory(exactChild))) {\n      for (var e = 0; e < extensions.length; ++e) {\n        var child = getOwn(file.c, part + extensions[e]);\n        if (child) {\n          return child;\n        }\n      }\n    }\n\n    return exactChild;\n  }\n\n  function fileAppendId(file, id) {\n    var parts = id.split(\"/\");\n    // Use `Array.prototype.every` to terminate iteration early if\n    // `fileAppendIdPart` returns a falsy value.\n    parts.every(function (part, i) {\n      return file = fileAppendIdPart(file, part, i === parts.length - 1);\n    });\n    return file;\n  }\n\n  function fileResolve(file, id) {\n    file =\n      // Absolute module identifiers (i.e. those that begin with a `/`\n      // character) are interpreted relative to the root directory, which\n      // is a slight deviation from Node, which has access to the entire\n      // file system.\n      id.charAt(0) === \"/\" ? fileAppendId(root, id) :\n      // Relative module identifiers are interpreted relative to the\n      // current file, naturally.\n      id.charAt(0) === \".\" ? fileAppendId(file, id) :\n      // Top-level module identifiers are interpreted as referring to\n      // packages in `node_modules` directories.\n      nodeModulesLookup(file, id);\n\n    // If the identifier resolves to a directory, we use the same logic as\n    // Node to find an `index.js` or `package.json` file to evaluate.\n    while (file && fileIsDirectory(file)) {\n      // If `package.json` does not exist, `fileEvaluate` will return the\n      // `MISSING` object, which has no `.main` property.\n      var pkg = fileEvaluate(fileAppendIdPart(file, \"package.json\"));\n      file = pkg && isString(pkg.main) &&\n        fileAppendId(file, pkg.main) || // Might resolve to another directory!\n        fileAppendIdPart(file, \"index.js\");\n    }\n\n    return file;\n  };\n\n  function nodeModulesLookup(file, id) {\n    return fileIsDirectory(file) &&\n      fileAppendId(file, \"node_modules/\" + id) ||\n      (file.p && nodeModulesLookup(file.p, id));\n  }\n\n  return install;\n};\n\nif (typeof exports === \"object\") {\n  exports.makeInstaller = makeInstaller;\n}\n","var options = {};\nvar hasOwn = options.hasOwnProperty;\n\n// RegExp matching strings that don't start with a `.` or a `/`.\nvar topLevelIdPattern = /^[^./]/;\n\n// This function will be called whenever a module identifier that hasn't\n// been installed is required. For backwards compatibility, and so that we\n// can require binary dependencies on the server, we implement the\n// fallback in terms of Npm.require.\noptions.fallback = function (id, dir, error) {\n  // For simplicity, we honor only top-level module identifiers here.\n  // We could try to honor relative and absolute module identifiers by\n  // somehow combining `id` with `dir`, but we'd have to be really careful\n  // that the resulting modules were located in a known directory (not\n  // some arbitrary location on the file system), and we only really need\n  // the fallback for dependencies installed in node_modules directories.\n  if (topLevelIdPattern.test(id)) {\n    var parts = id.split(\"/\");\n    if (parts.length === 2 &&\n        parts[0] === \"meteor\" &&\n        hasOwn.call(Package, parts[1])) {\n      return Package[parts[1]];\n    }\n\n    if (typeof Npm === \"object\" &&\n        typeof Npm.require === \"function\") {\n      return Npm.require(id);\n    }\n  }\n\n  throw error;\n};\n\nmeteorInstall = makeInstaller(options);\n"]}}]