[{"type":"js","data":"//////////////////////////////////////////////////////////////////////////\n//                                                                      //\n// This is a generated file. You can view the original                  //\n// source in your browser if your browser supports source maps.         //\n// Source maps are supported by all recent versions of Chrome, Safari,  //\n// and Firefox, and by Internet Explorer 11.                            //\n//                                                                      //\n//////////////////////////////////////////////////////////////////////////\n\n\n(function () {\n\n/* Imports */\nvar process = Package.meteor.process;\nvar Meteor = Package.meteor.Meteor;\nvar global = Package.meteor.global;\nvar ECMAScript = Package.ecmascript.ECMAScript;\nvar _ = Package.underscore._;\nvar LocalCollection = Package.minimongo.LocalCollection;\nvar Minimongo = Package.minimongo.Minimongo;\nvar check = Package.check.check;\nvar Match = Package.check.Match;\nvar EJSON = Package.ejson.EJSON;\nvar DDP = Package['ddp-client'].DDP;\nvar meteorInstall = Package.modules.meteorInstall;\nvar Symbol = Package['ecmascript-runtime'].Symbol;\nvar Map = Package['ecmascript-runtime'].Map;\nvar Set = Package['ecmascript-runtime'].Set;\nvar regeneratorRuntime = Package['ecmascript-runtime'].regeneratorRuntime;\nvar babelHelpers = Package['babel-runtime'].babelHelpers;\nvar Promise = Package.promise.Promise;\n\n/* Package-scope variables */\nvar AllowDeny;\n\nvar require = meteorInstall({\"node_modules\":{\"meteor\":{\"allow-deny\":{\"allow-deny.js\":function(require,exports,module){\n\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n//                                                                                                                //\n// packages/allow-deny/allow-deny.js                                                                              //\n//                                                                                                                //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n                                                                                                                  //\n///                                                                                                               //\n/// Remote methods and access control.                                                                            //\n///                                                                                                               //\n                                                                                                                  //\n// Restrict default mutators on collection. allow() and deny() take the                                           //\n// same options:                                                                                                  //\n//                                                                                                                //\n// options.insert {Function(userId, doc)}                                                                         //\n//   return true to allow/deny adding this document                                                               //\n//                                                                                                                //\n// options.update {Function(userId, docs, fields, modifier)}                                                      //\n//   return true to allow/deny updating these documents.                                                          //\n//   `fields` is passed as an array of fields that are to be modified                                             //\n//                                                                                                                //\n// options.remove {Function(userId, docs)}                                                                        //\n//   return true to allow/deny removing these documents                                                           //\n//                                                                                                                //\n// options.fetch {Array}                                                                                          //\n//   Fields to fetch for these validators. If any call to allow or deny                                           //\n//   does not have this option then all fields are loaded.                                                        //\n//                                                                                                                //\n// allow and deny can be called multiple times. The validators are                                                //\n// evaluated as follows:                                                                                          //\n// - If neither deny() nor allow() has been called on the collection,                                             //\n//   then the request is allowed if and only if the \"insecure\" smart                                              //\n//   package is in use.                                                                                           //\n// - Otherwise, if any deny() function returns true, the request is denied.                                       //\n// - Otherwise, if any allow() function returns true, the request is allowed.                                     //\n// - Otherwise, the request is denied.                                                                            //\n//                                                                                                                //\n// Meteor may call your deny() and allow() functions in any order, and may not                                    //\n// call all of them if it is able to make a decision without calling them all                                     //\n// (so don't include side effects).                                                                               //\n                                                                                                                  //\nAllowDeny = {                                                                                                     // 35\n  CollectionPrototype: {}                                                                                         // 36\n};                                                                                                                //\n                                                                                                                  //\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these                                   //\n// methods                                                                                                        //\nvar CollectionPrototype = AllowDeny.CollectionPrototype;                                                          // 41\n                                                                                                                  //\n/**                                                                                                               //\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n * @locus Server                                                                                                  //\n * @method allow                                                                                                  //\n * @memberOf Mongo.Collection                                                                                     //\n * @instance                                                                                                      //\n * @param {Object} options                                                                                        //\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */                                                                                                               //\nCollectionPrototype.allow = function (options) {                                                                  // 54\n  addValidator(this, 'allow', options);                                                                           // 55\n};                                                                                                                //\n                                                                                                                  //\n/**                                                                                                               //\n * @summary Override `allow` rules.                                                                               //\n * @locus Server                                                                                                  //\n * @method deny                                                                                                   //\n * @memberOf Mongo.Collection                                                                                     //\n * @instance                                                                                                      //\n * @param {Object} options                                                                                        //\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */                                                                                                               //\nCollectionPrototype.deny = function (options) {                                                                   // 69\n  addValidator(this, 'deny', options);                                                                            // 70\n};                                                                                                                //\n                                                                                                                  //\nCollectionPrototype._defineMutationMethods = function () {                                                        // 73\n  var self = this;                                                                                                // 74\n                                                                                                                  //\n  // set to true once we call any allow or deny methods. If true, use                                             //\n  // allow/deny semantics. If false, use insecure mode semantics.                                                 //\n  self._restricted = false;                                                                                       // 78\n                                                                                                                  //\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which                                    //\n  // means insecure iff the insecure package is loaded. This property can be                                      //\n  // overriden by tests or packages wishing to change insecure mode behavior of                                   //\n  // their collections.                                                                                           //\n  self._insecure = undefined;                                                                                     // 84\n                                                                                                                  //\n  self._validators = {                                                                                            // 86\n    insert: { allow: [], deny: [] },                                                                              // 87\n    update: { allow: [], deny: [] },                                                                              // 88\n    remove: { allow: [], deny: [] },                                                                              // 89\n    upsert: { allow: [], deny: [] }, // dummy arrays; can't set these!                                            // 90\n    fetch: [],                                                                                                    // 91\n    fetchAllFields: false                                                                                         // 92\n  };                                                                                                              //\n                                                                                                                  //\n  if (!self._name) return; // anonymous collection                                                                // 95\n                                                                                                                  //\n  // XXX Think about method namespacing. Maybe methods should be                                                  //\n  // \"Meteor:Mongo:insert/NAME\"?                                                                                  //\n  self._prefix = '/' + self._name + '/';                                                                          // 100\n                                                                                                                  //\n  // mutation methods                                                                                             //\n  if (self._connection) {                                                                                         // 103\n    (function () {                                                                                                //\n      var m = {};                                                                                                 // 104\n                                                                                                                  //\n      _.each(['insert', 'update', 'remove'], function (method) {                                                  // 106\n        m[self._prefix + method] = function () /* ... */{                                                         // 107\n          // All the methods do their own validation, instead of using check().                                   //\n          check(arguments, [Match.Any]);                                                                          // 109\n          var args = _.toArray(arguments);                                                                        // 110\n          try {                                                                                                   // 111\n            // For an insert, if the client didn't specify an _id, generate one                                   //\n            // now; because this uses DDP.randomStream, it will be consistent with                                //\n            // what the client generated. We generate it now rather than later so                                 //\n            // that if (eg) an allow/deny rule does an insert to the same                                         //\n            // collection (not that it really should), the generated _id will                                     //\n            // still be the first use of the stream and will be consistent.                                       //\n            //                                                                                                    //\n            // However, we don't actually stick the _id onto the document yet,                                    //\n            // because we want allow/deny rules to be able to differentiate                                       //\n            // between arbitrary client-specified _id fields and merely                                           //\n            // client-controlled-via-randomSeed fields.                                                           //\n            var generatedId = null;                                                                               // 123\n            if (method === \"insert\" && !_.has(args[0], '_id')) {                                                  // 124\n              generatedId = self._makeNewID();                                                                    // 125\n            }                                                                                                     //\n                                                                                                                  //\n            if (this.isSimulation) {                                                                              // 128\n              // In a client simulation, you can do any mutation (even with a                                     //\n              // complex selector).                                                                               //\n              if (generatedId !== null) args[0]._id = generatedId;                                                // 131\n              return self._collection[method].apply(self._collection, args);                                      // 133\n            }                                                                                                     //\n                                                                                                                  //\n            // This is the server receiving a method call from the client.                                        //\n                                                                                                                  //\n            // We don't allow arbitrary selectors in mutations from the client: only                              //\n            // single-ID selectors.                                                                               //\n            if (method !== 'insert') throwIfSelectorIsNotId(args[0], method);                                     // 141\n                                                                                                                  //\n            if (self._restricted) {                                                                               // 144\n              // short circuit if there is no way it will pass.                                                   //\n              if (self._validators[method].allow.length === 0) {                                                  // 146\n                throw new Meteor.Error(403, \"Access denied. No allow validators set on restricted \" + \"collection for method '\" + method + \"'.\");\n              }                                                                                                   //\n                                                                                                                  //\n              var validatedMethodName = '_validated' + method.charAt(0).toUpperCase() + method.slice(1);          // 152\n              args.unshift(this.userId);                                                                          // 154\n              method === 'insert' && args.push(generatedId);                                                      // 155\n              return self[validatedMethodName].apply(self, args);                                                 // 156\n            } else if (self._isInsecure()) {                                                                      //\n              if (generatedId !== null) args[0]._id = generatedId;                                                // 158\n              // In insecure mode, allow any mutation (with a simple selector).                                   //\n              // XXX This is kind of bogus.  Instead of blindly passing whatever                                  //\n              //     we get from the network to this function, we should actually                                 //\n              //     know the correct arguments for the function and pass just                                    //\n              //     them.  For example, if you have an extraneous extra null                                     //\n              //     argument and this is Mongo on the server, the .wrapAsync'd                                   //\n              //     functions like update will get confused and pass the                                         //\n              //     \"fut.resolver()\" in the wrong slot, where _update will never                                 //\n              //     invoke it. Bam, broken DDP connection.  Probably should just                                 //\n              //     take this whole method and write it three times, invoking                                    //\n              //     helpers for the common code.                                                                 //\n              return self._collection[method].apply(self._collection, args);                                      // 171\n            } else {                                                                                              //\n              // In secure mode, if we haven't called allow or deny, then nothing                                 //\n              // is permitted.                                                                                    //\n              throw new Meteor.Error(403, \"Access denied\");                                                       // 175\n            }                                                                                                     //\n          } catch (e) {                                                                                           //\n            if (e.name === 'MongoError' || e.name === 'MinimongoError') {                                         // 178\n              throw new Meteor.Error(409, e.toString());                                                          // 179\n            } else {                                                                                              //\n              throw e;                                                                                            // 181\n            }                                                                                                     //\n          }                                                                                                       //\n        };                                                                                                        //\n      });                                                                                                         //\n      // Minimongo on the server gets no stubs; instead, by default                                               //\n      // it wait()s until its result is ready, yielding.                                                          //\n      // This matches the behavior of macromongo on the server better.                                            //\n      // XXX see #MeteorServerNull                                                                                //\n      if (Meteor.isClient || self._connection === Meteor.server) self._connection.methods(m);                     // 190\n    })();                                                                                                         //\n  }                                                                                                               //\n};                                                                                                                //\n                                                                                                                  //\nCollectionPrototype._updateFetch = function (fields) {                                                            // 195\n  var self = this;                                                                                                // 196\n                                                                                                                  //\n  if (!self._validators.fetchAllFields) {                                                                         // 198\n    if (fields) {                                                                                                 // 199\n      self._validators.fetch = _.union(self._validators.fetch, fields);                                           // 200\n    } else {                                                                                                      //\n      self._validators.fetchAllFields = true;                                                                     // 202\n      // clear fetch just to make sure we don't accidentally read it                                              //\n      self._validators.fetch = null;                                                                              // 204\n    }                                                                                                             //\n  }                                                                                                               //\n};                                                                                                                //\n                                                                                                                  //\nCollectionPrototype._isInsecure = function () {                                                                   // 209\n  var self = this;                                                                                                // 210\n  if (self._insecure === undefined) return !!Package.insecure;                                                    // 211\n  return self._insecure;                                                                                          // 213\n};                                                                                                                //\n                                                                                                                  //\nCollectionPrototype._validatedInsert = function (userId, doc, generatedId) {                                      // 216\n  var self = this;                                                                                                // 218\n                                                                                                                  //\n  // call user validators.                                                                                        //\n  // Any deny returns true means denied.                                                                          //\n  if (_.any(self._validators.insert.deny, function (validator) {                                                  // 222\n    return validator(userId, docToValidate(validator, doc, generatedId));                                         // 223\n  })) {                                                                                                           //\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 225\n  }                                                                                                               //\n  // Any allow returns true means proceed. Throw error if they all fail.                                          //\n  if (_.all(self._validators.insert.allow, function (validator) {                                                 // 228\n    return !validator(userId, docToValidate(validator, doc, generatedId));                                        // 229\n  })) {                                                                                                           //\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 231\n  }                                                                                                               //\n                                                                                                                  //\n  // If we generated an ID above, insert it now: after the validation, but                                        //\n  // before actually inserting.                                                                                   //\n  if (generatedId !== null) doc._id = generatedId;                                                                // 236\n                                                                                                                  //\n  self._collection.insert.call(self._collection, doc);                                                            // 239\n};                                                                                                                //\n                                                                                                                  //\n// Simulate a mongo `update` operation while validating that the access                                           //\n// control rules set by calls to `allow/deny` are satisfied. If all                                               //\n// pass, rewrite the mongo operation to use $in to set the list of                                                //\n// document ids to change ##ValidatedChange                                                                       //\nCollectionPrototype._validatedUpdate = function (userId, selector, mutator, options) {                            // 246\n  var self = this;                                                                                                // 248\n                                                                                                                  //\n  check(mutator, Object);                                                                                         // 250\n                                                                                                                  //\n  options = _.clone(options) || {};                                                                               // 252\n                                                                                                                  //\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) throw new Error(\"validated update should be of a single ID\");\n                                                                                                                  //\n  // We don't support upserts because they don't fit nicely into allow/deny                                       //\n  // rules.                                                                                                       //\n  if (options.upsert) throw new Meteor.Error(403, \"Access denied. Upserts not \" + \"allowed in a restricted collection.\");\n                                                                                                                  //\n  var noReplaceError = \"Access denied. In a restricted collection you can only\" + \" update documents, not replace them. Use a Mongo update operator, such \" + \"as '$set'.\";\n                                                                                                                  //\n  // compute modified fields                                                                                      //\n  var fields = [];                                                                                                // 268\n  if (_.isEmpty(mutator)) {                                                                                       // 269\n    throw new Meteor.Error(403, noReplaceError);                                                                  // 270\n  }                                                                                                               //\n  _.each(mutator, function (params, op) {                                                                         // 272\n    if (op.charAt(0) !== '$') {                                                                                   // 273\n      throw new Meteor.Error(403, noReplaceError);                                                                // 274\n    } else if (!_.has(ALLOWED_UPDATE_OPERATIONS, op)) {                                                           //\n      throw new Meteor.Error(403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\");  // 276\n    } else {                                                                                                      //\n      _.each(_.keys(params), function (field) {                                                                   // 279\n        // treat dotted fields as if they are replacing their                                                     //\n        // top-level part                                                                                         //\n        if (field.indexOf('.') !== -1) field = field.substring(0, field.indexOf('.'));                            // 282\n                                                                                                                  //\n        // record the field we are trying to change                                                               //\n        if (!_.contains(fields, field)) fields.push(field);                                                       // 286\n      });                                                                                                         //\n    }                                                                                                             //\n  });                                                                                                             //\n                                                                                                                  //\n  var findOptions = { transform: null };                                                                          // 292\n  if (!self._validators.fetchAllFields) {                                                                         // 293\n    findOptions.fields = {};                                                                                      // 294\n    _.each(self._validators.fetch, function (fieldName) {                                                         // 295\n      findOptions.fields[fieldName] = 1;                                                                          // 296\n    });                                                                                                           //\n  }                                                                                                               //\n                                                                                                                  //\n  var doc = self._collection.findOne(selector, findOptions);                                                      // 300\n  if (!doc) // none satisfied!                                                                                    // 301\n    return 0;                                                                                                     // 302\n                                                                                                                  //\n  // call user validators.                                                                                        //\n  // Any deny returns true means denied.                                                                          //\n  if (_.any(self._validators.update.deny, function (validator) {                                                  // 306\n    var factoriedDoc = transformDoc(validator, doc);                                                              // 307\n    return validator(userId, factoriedDoc, fields, mutator);                                                      // 308\n  })) {                                                                                                           //\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 313\n  }                                                                                                               //\n  // Any allow returns true means proceed. Throw error if they all fail.                                          //\n  if (_.all(self._validators.update.allow, function (validator) {                                                 // 316\n    var factoriedDoc = transformDoc(validator, doc);                                                              // 317\n    return !validator(userId, factoriedDoc, fields, mutator);                                                     // 318\n  })) {                                                                                                           //\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 323\n  }                                                                                                               //\n                                                                                                                  //\n  options._forbidReplace = true;                                                                                  // 326\n                                                                                                                  //\n  // Back when we supported arbitrary client-provided selectors, we actually                                      //\n  // rewrote the selector to include an _id clause before passing to Mongo to                                     //\n  // avoid races, but since selector is guaranteed to already just be an ID, we                                   //\n  // don't have to any more.                                                                                      //\n                                                                                                                  //\n  return self._collection.update.call(self._collection, selector, mutator, options);                              // 333\n};                                                                                                                //\n                                                                                                                  //\n// Only allow these operations in validated updates. Specifically                                                 //\n// whitelist operations, rather than blacklist, so new complex                                                    //\n// operations that are added aren't automatically allowed. A complex                                              //\n// operation is one that does more than just modify its target                                                    //\n// field. For now this contains all update operations except '$rename'.                                           //\n// http://docs.mongodb.org/manual/reference/operators/#update                                                     //\nvar ALLOWED_UPDATE_OPERATIONS = {                                                                                 // 343\n  $inc: 1, $set: 1, $unset: 1, $addToSet: 1, $pop: 1, $pullAll: 1, $pull: 1,                                      // 344\n  $pushAll: 1, $push: 1, $bit: 1                                                                                  // 345\n};                                                                                                                //\n                                                                                                                  //\n// Simulate a mongo `remove` operation while validating access control                                            //\n// rules. See #ValidatedChange                                                                                    //\nCollectionPrototype._validatedRemove = function (userId, selector) {                                              // 350\n  var self = this;                                                                                                // 351\n                                                                                                                  //\n  var findOptions = { transform: null };                                                                          // 353\n  if (!self._validators.fetchAllFields) {                                                                         // 354\n    findOptions.fields = {};                                                                                      // 355\n    _.each(self._validators.fetch, function (fieldName) {                                                         // 356\n      findOptions.fields[fieldName] = 1;                                                                          // 357\n    });                                                                                                           //\n  }                                                                                                               //\n                                                                                                                  //\n  var doc = self._collection.findOne(selector, findOptions);                                                      // 361\n  if (!doc) return 0;                                                                                             // 362\n                                                                                                                  //\n  // call user validators.                                                                                        //\n  // Any deny returns true means denied.                                                                          //\n  if (_.any(self._validators.remove.deny, function (validator) {                                                  // 367\n    return validator(userId, transformDoc(validator, doc));                                                       // 368\n  })) {                                                                                                           //\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 370\n  }                                                                                                               //\n  // Any allow returns true means proceed. Throw error if they all fail.                                          //\n  if (_.all(self._validators.remove.allow, function (validator) {                                                 // 373\n    return !validator(userId, transformDoc(validator, doc));                                                      // 374\n  })) {                                                                                                           //\n    throw new Meteor.Error(403, \"Access denied\");                                                                 // 376\n  }                                                                                                               //\n                                                                                                                  //\n  // Back when we supported arbitrary client-provided selectors, we actually                                      //\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to                                  //\n  // Mongo to avoid races, but since selector is guaranteed to already just be                                    //\n  // an ID, we don't have to any more.                                                                            //\n                                                                                                                  //\n  return self._collection.remove.call(self._collection, selector);                                                // 384\n};                                                                                                                //\n                                                                                                                  //\nCollectionPrototype._callMutatorMethod = (function () {                                                           // 387\n  function _callMutatorMethod(name, args, callback) {                                                             // 387\n    if (Meteor.isClient && !callback && !alreadyInSimulation()) {                                                 // 388\n      // Client can't block, so it can't report errors by exception,                                              //\n      // only by callback. If they forget the callback, give them a                                               //\n      // default one that logs the error, so they aren't totally                                                  //\n      // baffled if their writes don't work because their database is                                             //\n      // down.                                                                                                    //\n      // Don't give a default callback in simulation, because inside stubs we                                     //\n      // want to return the results from the local collection immediately and                                     //\n      // not force a callback.                                                                                    //\n      callback = function (err) {                                                                                 // 397\n        if (err) Meteor._debug(name + \" failed: \" + (err.reason || err.stack));                                   // 398\n      };                                                                                                          //\n    }                                                                                                             //\n                                                                                                                  //\n    // For two out of three mutator methods, the first argument is a selector                                     //\n    var firstArgIsSelector = name === \"update\" || name === \"remove\";                                              // 404\n    if (firstArgIsSelector && !alreadyInSimulation()) {                                                           // 405\n      // If we're about to actually send an RPC, we should throw an error if                                      //\n      // this is a non-ID selector, because the mutation methods only allow                                       //\n      // single-ID selectors. (If we don't throw here, we'll see flicker.)                                        //\n      throwIfSelectorIsNotId(args[0], name);                                                                      // 409\n    }                                                                                                             //\n                                                                                                                  //\n    var mutatorMethodName = this._prefix + name;                                                                  // 412\n    return this._connection.apply(mutatorMethodName, args, { returnStubValue: true }, callback);                  // 413\n  }                                                                                                               //\n                                                                                                                  //\n  return _callMutatorMethod;                                                                                      //\n})();                                                                                                             //\n                                                                                                                  //\nfunction transformDoc(validator, doc) {                                                                           // 417\n  if (validator.transform) return validator.transform(doc);                                                       // 418\n  return doc;                                                                                                     // 420\n}                                                                                                                 //\n                                                                                                                  //\nfunction docToValidate(validator, doc, generatedId) {                                                             // 423\n  var ret = doc;                                                                                                  // 424\n  if (validator.transform) {                                                                                      // 425\n    ret = EJSON.clone(doc);                                                                                       // 426\n    // If you set a server-side transform on your collection, then you don't get                                  //\n    // to tell the difference between \"client specified the ID\" and \"server                                       //\n    // generated the ID\", because transforms expect to get _id.  If you want to                                   //\n    // do that check, you can do it with a specific                                                               //\n    // `C.allow({insert: f, transform: null})` validator.                                                         //\n    if (generatedId !== null) {                                                                                   // 432\n      ret._id = generatedId;                                                                                      // 433\n    }                                                                                                             //\n    ret = validator.transform(ret);                                                                               // 435\n  }                                                                                                               //\n  return ret;                                                                                                     // 437\n}                                                                                                                 //\n                                                                                                                  //\nfunction addValidator(collection, allowOrDeny, options) {                                                         // 440\n  // validate keys                                                                                                //\n  var VALID_KEYS = ['insert', 'update', 'remove', 'fetch', 'transform'];                                          // 442\n  _.each(_.keys(options), function (key) {                                                                        // 443\n    if (!_.contains(VALID_KEYS, key)) throw new Error(allowOrDeny + \": Invalid key: \" + key);                     // 444\n  });                                                                                                             //\n                                                                                                                  //\n  collection._restricted = true;                                                                                  // 448\n                                                                                                                  //\n  _.each(['insert', 'update', 'remove'], function (name) {                                                        // 450\n    if (options.hasOwnProperty(name)) {                                                                           // 451\n      if (!(options[name] instanceof Function)) {                                                                 // 452\n        throw new Error(allowOrDeny + \": Value for `\" + name + \"` must be a function\");                           // 453\n      }                                                                                                           //\n                                                                                                                  //\n      // If the transform is specified at all (including as 'null') in this                                       //\n      // call, then take that; otherwise, take the transform from the                                             //\n      // collection.                                                                                              //\n      if (options.transform === undefined) {                                                                      // 459\n        options[name].transform = collection._transform; // already wrapped                                       // 460\n      } else {                                                                                                    //\n          options[name].transform = LocalCollection.wrapTransform(options.transform);                             // 462\n        }                                                                                                         //\n                                                                                                                  //\n      collection._validators[name][allowOrDeny].push(options[name]);                                              // 466\n    }                                                                                                             //\n  });                                                                                                             //\n                                                                                                                  //\n  // Only update the fetch fields if we're passed things that affect                                              //\n  // fetching. This way allow({}) and allow({insert: f}) don't result in                                          //\n  // setting fetchAllFields                                                                                       //\n  if (options.update || options.remove || options.fetch) {                                                        // 473\n    if (options.fetch && !(options.fetch instanceof Array)) {                                                     // 474\n      throw new Error(allowOrDeny + \": Value for `fetch` must be an array\");                                      // 475\n    }                                                                                                             //\n    collection._updateFetch(options.fetch);                                                                       // 477\n  }                                                                                                               //\n}                                                                                                                 //\n                                                                                                                  //\nfunction throwIfSelectorIsNotId(selector, methodName) {                                                           // 481\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {                                                  // 482\n    throw new Meteor.Error(403, \"Not permitted. Untrusted code may only \" + methodName + \" documents by ID.\");    // 483\n  }                                                                                                               //\n};                                                                                                                //\n                                                                                                                  //\n// Determine if we are in a DDP method simulation                                                                 //\nfunction alreadyInSimulation() {                                                                                  // 490\n  var enclosing = DDP._CurrentInvocation.get();                                                                   // 491\n  return enclosing && enclosing.isSimulation;                                                                     // 492\n}                                                                                                                 //\n////////////////////////////////////////////////////////////////////////////////////////////////////////////////////\n\n}}}}});\nrequire(\"./node_modules/meteor/allow-deny/allow-deny.js\");\n\n/* Exports */\nif (typeof Package === 'undefined') Package = {};\n(function (pkg, symbols) {\n  for (var s in symbols)\n    (s in pkg) || (pkg[s] = symbols[s]);\n})(Package['allow-deny'] = {}, {\n  AllowDeny: AllowDeny\n});\n\n})();\n","servePath":"/packages/allow-deny.js","sourceMap":{"version":3,"sources":["/packages/allow-deny/allow-deny.js"],"names":[],"mappings":"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","file":"/packages/allow-deny.js","sourcesContent":["///\n/// Remote methods and access control.\n///\n\n// Restrict default mutators on collection. allow() and deny() take the\n// same options:\n//\n// options.insert {Function(userId, doc)}\n//   return true to allow/deny adding this document\n//\n// options.update {Function(userId, docs, fields, modifier)}\n//   return true to allow/deny updating these documents.\n//   `fields` is passed as an array of fields that are to be modified\n//\n// options.remove {Function(userId, docs)}\n//   return true to allow/deny removing these documents\n//\n// options.fetch {Array}\n//   Fields to fetch for these validators. If any call to allow or deny\n//   does not have this option then all fields are loaded.\n//\n// allow and deny can be called multiple times. The validators are\n// evaluated as follows:\n// - If neither deny() nor allow() has been called on the collection,\n//   then the request is allowed if and only if the \"insecure\" smart\n//   package is in use.\n// - Otherwise, if any deny() function returns true, the request is denied.\n// - Otherwise, if any allow() function returns true, the request is allowed.\n// - Otherwise, the request is denied.\n//\n// Meteor may call your deny() and allow() functions in any order, and may not\n// call all of them if it is able to make a decision without calling them all\n// (so don't include side effects).\n\nAllowDeny = {\n  CollectionPrototype: {}\n};\n\n// In the `mongo` package, we will extend Mongo.Collection.prototype with these\n// methods\nconst CollectionPrototype = AllowDeny.CollectionPrototype;\n\n/**\n * @summary Allow users to write directly to this collection from client code, subject to limitations you define.\n * @locus Server\n * @method allow\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be allowed.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.allow = function(options) {\n  addValidator(this, 'allow', options);\n};\n\n/**\n * @summary Override `allow` rules.\n * @locus Server\n * @method deny\n * @memberOf Mongo.Collection\n * @instance\n * @param {Object} options\n * @param {Function} options.insert,update,remove Functions that look at a proposed modification to the database and return true if it should be denied, even if an [allow](#allow) rule says otherwise.\n * @param {String[]} options.fetch Optional performance enhancement. Limits the fields that will be fetched from the database for inspection by your `update` and `remove` functions.\n * @param {Function} options.transform Overrides `transform` on the  [`Collection`](#collections).  Pass `null` to disable transformation.\n */\nCollectionPrototype.deny = function(options) {\n  addValidator(this, 'deny', options);\n};\n\nCollectionPrototype._defineMutationMethods = function() {\n  const self = this;\n\n  // set to true once we call any allow or deny methods. If true, use\n  // allow/deny semantics. If false, use insecure mode semantics.\n  self._restricted = false;\n\n  // Insecure mode (default to allowing writes). Defaults to 'undefined' which\n  // means insecure iff the insecure package is loaded. This property can be\n  // overriden by tests or packages wishing to change insecure mode behavior of\n  // their collections.\n  self._insecure = undefined;\n\n  self._validators = {\n    insert: {allow: [], deny: []},\n    update: {allow: [], deny: []},\n    remove: {allow: [], deny: []},\n    upsert: {allow: [], deny: []}, // dummy arrays; can't set these!\n    fetch: [],\n    fetchAllFields: false\n  };\n\n  if (!self._name)\n    return; // anonymous collection\n\n  // XXX Think about method namespacing. Maybe methods should be\n  // \"Meteor:Mongo:insert/NAME\"?\n  self._prefix = '/' + self._name + '/';\n\n  // mutation methods\n  if (self._connection) {\n    const m = {};\n\n    _.each(['insert', 'update', 'remove'], function (method) {\n      m[self._prefix + method] = function (/* ... */) {\n        // All the methods do their own validation, instead of using check().\n        check(arguments, [Match.Any]);\n        const args = _.toArray(arguments);\n        try {\n          // For an insert, if the client didn't specify an _id, generate one\n          // now; because this uses DDP.randomStream, it will be consistent with\n          // what the client generated. We generate it now rather than later so\n          // that if (eg) an allow/deny rule does an insert to the same\n          // collection (not that it really should), the generated _id will\n          // still be the first use of the stream and will be consistent.\n          //\n          // However, we don't actually stick the _id onto the document yet,\n          // because we want allow/deny rules to be able to differentiate\n          // between arbitrary client-specified _id fields and merely\n          // client-controlled-via-randomSeed fields.\n          let generatedId = null;\n          if (method === \"insert\" && !_.has(args[0], '_id')) {\n            generatedId = self._makeNewID();\n          }\n\n          if (this.isSimulation) {\n            // In a client simulation, you can do any mutation (even with a\n            // complex selector).\n            if (generatedId !== null)\n              args[0]._id = generatedId;\n            return self._collection[method].apply(\n              self._collection, args);\n          }\n\n          // This is the server receiving a method call from the client.\n\n          // We don't allow arbitrary selectors in mutations from the client: only\n          // single-ID selectors.\n          if (method !== 'insert')\n            throwIfSelectorIsNotId(args[0], method);\n\n          if (self._restricted) {\n            // short circuit if there is no way it will pass.\n            if (self._validators[method].allow.length === 0) {\n              throw new Meteor.Error(\n                403, \"Access denied. No allow validators set on restricted \" +\n                  \"collection for method '\" + method + \"'.\");\n            }\n\n            const validatedMethodName =\n                  '_validated' + method.charAt(0).toUpperCase() + method.slice(1);\n            args.unshift(this.userId);\n            method === 'insert' && args.push(generatedId);\n            return self[validatedMethodName].apply(self, args);\n          } else if (self._isInsecure()) {\n            if (generatedId !== null)\n              args[0]._id = generatedId;\n            // In insecure mode, allow any mutation (with a simple selector).\n            // XXX This is kind of bogus.  Instead of blindly passing whatever\n            //     we get from the network to this function, we should actually\n            //     know the correct arguments for the function and pass just\n            //     them.  For example, if you have an extraneous extra null\n            //     argument and this is Mongo on the server, the .wrapAsync'd\n            //     functions like update will get confused and pass the\n            //     \"fut.resolver()\" in the wrong slot, where _update will never\n            //     invoke it. Bam, broken DDP connection.  Probably should just\n            //     take this whole method and write it three times, invoking\n            //     helpers for the common code.\n            return self._collection[method].apply(self._collection, args);\n          } else {\n            // In secure mode, if we haven't called allow or deny, then nothing\n            // is permitted.\n            throw new Meteor.Error(403, \"Access denied\");\n          }\n        } catch (e) {\n          if (e.name === 'MongoError' || e.name === 'MinimongoError') {\n            throw new Meteor.Error(409, e.toString());\n          } else {\n            throw e;\n          }\n        }\n      };\n    });\n    // Minimongo on the server gets no stubs; instead, by default\n    // it wait()s until its result is ready, yielding.\n    // This matches the behavior of macromongo on the server better.\n    // XXX see #MeteorServerNull\n    if (Meteor.isClient || self._connection === Meteor.server)\n      self._connection.methods(m);\n  }\n};\n\nCollectionPrototype._updateFetch = function (fields) {\n  const self = this;\n\n  if (!self._validators.fetchAllFields) {\n    if (fields) {\n      self._validators.fetch = _.union(self._validators.fetch, fields);\n    } else {\n      self._validators.fetchAllFields = true;\n      // clear fetch just to make sure we don't accidentally read it\n      self._validators.fetch = null;\n    }\n  }\n};\n\nCollectionPrototype._isInsecure = function () {\n  const self = this;\n  if (self._insecure === undefined)\n    return !!Package.insecure;\n  return self._insecure;\n};\n\nCollectionPrototype._validatedInsert = function (userId, doc,\n                                                         generatedId) {\n  const self = this;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (_.any(self._validators.insert.deny, function(validator) {\n    return validator(userId, docToValidate(validator, doc, generatedId));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (_.all(self._validators.insert.allow, function(validator) {\n    return !validator(userId, docToValidate(validator, doc, generatedId));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // If we generated an ID above, insert it now: after the validation, but\n  // before actually inserting.\n  if (generatedId !== null)\n    doc._id = generatedId;\n\n  self._collection.insert.call(self._collection, doc);\n};\n\n// Simulate a mongo `update` operation while validating that the access\n// control rules set by calls to `allow/deny` are satisfied. If all\n// pass, rewrite the mongo operation to use $in to set the list of\n// document ids to change ##ValidatedChange\nCollectionPrototype._validatedUpdate = function(\n    userId, selector, mutator, options) {\n  const self = this;\n\n  check(mutator, Object);\n\n  options = _.clone(options) || {};\n\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector))\n    throw new Error(\"validated update should be of a single ID\");\n\n  // We don't support upserts because they don't fit nicely into allow/deny\n  // rules.\n  if (options.upsert)\n    throw new Meteor.Error(403, \"Access denied. Upserts not \" +\n                           \"allowed in a restricted collection.\");\n\n  const noReplaceError = \"Access denied. In a restricted collection you can only\" +\n        \" update documents, not replace them. Use a Mongo update operator, such \" +\n        \"as '$set'.\";\n\n  // compute modified fields\n  const fields = [];\n  if (_.isEmpty(mutator)) {\n    throw new Meteor.Error(403, noReplaceError);\n  }\n  _.each(mutator, function (params, op) {\n    if (op.charAt(0) !== '$') {\n      throw new Meteor.Error(403, noReplaceError);\n    } else if (!_.has(ALLOWED_UPDATE_OPERATIONS, op)) {\n      throw new Meteor.Error(\n        403, \"Access denied. Operator \" + op + \" not allowed in a restricted collection.\");\n    } else {\n      _.each(_.keys(params), function (field) {\n        // treat dotted fields as if they are replacing their\n        // top-level part\n        if (field.indexOf('.') !== -1)\n          field = field.substring(0, field.indexOf('.'));\n\n        // record the field we are trying to change\n        if (!_.contains(fields, field))\n          fields.push(field);\n      });\n    }\n  });\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    _.each(self._validators.fetch, function(fieldName) {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = self._collection.findOne(selector, findOptions);\n  if (!doc)  // none satisfied!\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (_.any(self._validators.update.deny, function(validator) {\n    const factoriedDoc = transformDoc(validator, doc);\n    return validator(userId,\n                     factoriedDoc,\n                     fields,\n                     mutator);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (_.all(self._validators.update.allow, function(validator) {\n    const factoriedDoc = transformDoc(validator, doc);\n    return !validator(userId,\n                      factoriedDoc,\n                      fields,\n                      mutator);\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  options._forbidReplace = true;\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to include an _id clause before passing to Mongo to\n  // avoid races, but since selector is guaranteed to already just be an ID, we\n  // don't have to any more.\n\n  return self._collection.update.call(\n    self._collection, selector, mutator, options);\n};\n\n// Only allow these operations in validated updates. Specifically\n// whitelist operations, rather than blacklist, so new complex\n// operations that are added aren't automatically allowed. A complex\n// operation is one that does more than just modify its target\n// field. For now this contains all update operations except '$rename'.\n// http://docs.mongodb.org/manual/reference/operators/#update\nconst ALLOWED_UPDATE_OPERATIONS = {\n  $inc:1, $set:1, $unset:1, $addToSet:1, $pop:1, $pullAll:1, $pull:1,\n  $pushAll:1, $push:1, $bit:1\n};\n\n// Simulate a mongo `remove` operation while validating access control\n// rules. See #ValidatedChange\nCollectionPrototype._validatedRemove = function(userId, selector) {\n  const self = this;\n\n  const findOptions = {transform: null};\n  if (!self._validators.fetchAllFields) {\n    findOptions.fields = {};\n    _.each(self._validators.fetch, function(fieldName) {\n      findOptions.fields[fieldName] = 1;\n    });\n  }\n\n  const doc = self._collection.findOne(selector, findOptions);\n  if (!doc)\n    return 0;\n\n  // call user validators.\n  // Any deny returns true means denied.\n  if (_.any(self._validators.remove.deny, function(validator) {\n    return validator(userId, transformDoc(validator, doc));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n  // Any allow returns true means proceed. Throw error if they all fail.\n  if (_.all(self._validators.remove.allow, function(validator) {\n    return !validator(userId, transformDoc(validator, doc));\n  })) {\n    throw new Meteor.Error(403, \"Access denied\");\n  }\n\n  // Back when we supported arbitrary client-provided selectors, we actually\n  // rewrote the selector to {_id: {$in: [ids that we found]}} before passing to\n  // Mongo to avoid races, but since selector is guaranteed to already just be\n  // an ID, we don't have to any more.\n\n  return self._collection.remove.call(self._collection, selector);\n};\n\nCollectionPrototype._callMutatorMethod = function _callMutatorMethod(name, args, callback) {\n  if (Meteor.isClient && !callback && !alreadyInSimulation()) {\n    // Client can't block, so it can't report errors by exception,\n    // only by callback. If they forget the callback, give them a\n    // default one that logs the error, so they aren't totally\n    // baffled if their writes don't work because their database is\n    // down.\n    // Don't give a default callback in simulation, because inside stubs we\n    // want to return the results from the local collection immediately and\n    // not force a callback.\n    callback = function (err) {\n      if (err)\n        Meteor._debug(name + \" failed: \" + (err.reason || err.stack));\n    };\n  }\n\n  // For two out of three mutator methods, the first argument is a selector\n  const firstArgIsSelector = name === \"update\" || name === \"remove\";\n  if (firstArgIsSelector && !alreadyInSimulation()) {\n    // If we're about to actually send an RPC, we should throw an error if\n    // this is a non-ID selector, because the mutation methods only allow\n    // single-ID selectors. (If we don't throw here, we'll see flicker.)\n    throwIfSelectorIsNotId(args[0], name);\n  }\n\n  const mutatorMethodName = this._prefix + name;\n  return this._connection.apply(\n    mutatorMethodName, args, { returnStubValue: true }, callback);\n}\n\nfunction transformDoc(validator, doc) {\n  if (validator.transform)\n    return validator.transform(doc);\n  return doc;\n}\n\nfunction docToValidate(validator, doc, generatedId) {\n  let ret = doc;\n  if (validator.transform) {\n    ret = EJSON.clone(doc);\n    // If you set a server-side transform on your collection, then you don't get\n    // to tell the difference between \"client specified the ID\" and \"server\n    // generated the ID\", because transforms expect to get _id.  If you want to\n    // do that check, you can do it with a specific\n    // `C.allow({insert: f, transform: null})` validator.\n    if (generatedId !== null) {\n      ret._id = generatedId;\n    }\n    ret = validator.transform(ret);\n  }\n  return ret;\n}\n\nfunction addValidator(collection, allowOrDeny, options) {\n  // validate keys\n  const VALID_KEYS = ['insert', 'update', 'remove', 'fetch', 'transform'];\n  _.each(_.keys(options), function (key) {\n    if (!_.contains(VALID_KEYS, key))\n      throw new Error(allowOrDeny + \": Invalid key: \" + key);\n  });\n\n  collection._restricted = true;\n\n  _.each(['insert', 'update', 'remove'], function (name) {\n    if (options.hasOwnProperty(name)) {\n      if (!(options[name] instanceof Function)) {\n        throw new Error(allowOrDeny + \": Value for `\" + name + \"` must be a function\");\n      }\n\n      // If the transform is specified at all (including as 'null') in this\n      // call, then take that; otherwise, take the transform from the\n      // collection.\n      if (options.transform === undefined) {\n        options[name].transform = collection._transform;  // already wrapped\n      } else {\n        options[name].transform = LocalCollection.wrapTransform(\n          options.transform);\n      }\n\n      collection._validators[name][allowOrDeny].push(options[name]);\n    }\n  });\n\n  // Only update the fetch fields if we're passed things that affect\n  // fetching. This way allow({}) and allow({insert: f}) don't result in\n  // setting fetchAllFields\n  if (options.update || options.remove || options.fetch) {\n    if (options.fetch && !(options.fetch instanceof Array)) {\n      throw new Error(allowOrDeny + \": Value for `fetch` must be an array\");\n    }\n    collection._updateFetch(options.fetch);\n  }\n}\n\nfunction throwIfSelectorIsNotId(selector, methodName) {\n  if (!LocalCollection._selectorIsIdPerhapsAsObject(selector)) {\n    throw new Meteor.Error(\n      403, \"Not permitted. Untrusted code may only \" + methodName +\n        \" documents by ID.\");\n  }\n};\n\n// Determine if we are in a DDP method simulation\nfunction alreadyInSimulation() {\n  const enclosing = DDP._CurrentInvocation.get();\n  return enclosing && enclosing.isSimulation;\n}\n"]}}]