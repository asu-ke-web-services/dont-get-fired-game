{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"// White box tests of invalidation crossbar matching function.\n// Note: the current crossbar match function is designed specifically\n// to ensure that a modification that targets a specific ID does not\n// notify a query that is watching a different specific ID. (And to\n// keep separate collections separate.) Other than that, there's no\n// deep meaning to the matching function, and it could be changed later\n// as long as it preserves that property.\nTinytest.add('livedata - crossbar', function (test) {\n  var crossbar = new DDPServer._Crossbar();\n  test.isTrue(crossbar._matches({ collection: \"C\" }, { collection: \"C\" }));\n  test.isTrue(crossbar._matches({ collection: \"C\", id: \"X\" }, { collection: \"C\" }));\n  test.isTrue(crossbar._matches({ collection: \"C\" }, { collection: \"C\", id: \"X\" }));\n  test.isTrue(crossbar._matches({ collection: \"C\", id: \"X\" }, { collection: \"C\" }));\n\n  test.isFalse(crossbar._matches({ collection: \"C\", id: \"X\" }, { collection: \"C\", id: \"Y\" }));\n\n  // Test that stopped listens definitely don't fire.\n  var calledFirst = false;\n  var calledSecond = false;\n  var trigger = { collection: \"C\" };\n  var secondHandle;\n  crossbar.listen(trigger, function (notification) {\n    // This test assumes that listeners will be called in the order\n    // registered. It's not wrong for the crossbar to do something different,\n    // but the test won't be valid in that case, so make it fail so we notice.\n    calledFirst = true;\n    if (calledSecond) {\n      test.fail({\n        type: \"test_assumption_failed\",\n        message: \"test assumed that listeners would be called in the order registered\"\n      });\n    } else {\n      secondHandle.stop();\n    }\n  });\n  secondHandle = crossbar.listen(trigger, function (notification) {\n    // This should not get invoked, because it should be stopped by the other\n    // listener!\n    calledSecond = true;\n  });\n  crossbar.fire(trigger);\n  test.isTrue(calledFirst);\n  test.isFalse(calledSecond);\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/crossbar_tests.js"],"names":[],"mappings":";;;;;;;AAOA,QAAQ,CAAC,GAAG,CAAC,qBAAqB,EAAE,UAAU,IAAI,EAAE;AAClD,MAAI,QAAQ,GAAG,IAAI,SAAS,CAAC,SAAS,EAAA,CAAC;AACvC,MAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAC,UAAU,EAAE,GAAG,EAAC,EACjB,EAAC,UAAU,EAAE,GAAG,EAAC,CAAC,CAAC,CAAC;AAClD,MAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAC,UAAU,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAC,EAC1B,EAAC,UAAU,EAAE,GAAG,EAAC,CAAC,CAAC,CAAC;AAClD,MAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAC,UAAU,EAAE,GAAG,EAAC,EACjB,EAAC,UAAU,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAC,CAAC,CAAC,CAAC;AAC3D,MAAI,CAAC,MAAM,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAC,UAAU,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAC,EAC1B,EAAC,UAAU,EAAE,GAAG,EAAC,CAAC,CAAC,CAAC;;AAElD,MAAI,CAAC,OAAO,CAAC,QAAQ,CAAC,QAAQ,CAAC,EAAC,UAAU,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAC,EAC1B,EAAC,UAAU,EAAE,GAAG,EAAE,EAAE,EAAE,GAAG,EAAC,CAAC,CAAC,CAAC;;;AAG5D,MAAI,WAAW,GAAG,KAAK,CAAC;AACxB,MAAI,YAAY,GAAG,KAAK,CAAC;AACzB,MAAI,OAAO,GAAG,EAAC,UAAU,EAAE,GAAG,EAAC,CAAC;AAChC,MAAI,YAAY,CAAC;AACjB,UAAQ,CAAC,MAAM,CAAC,OAAO,EAAE,UAAU,YAAY,EAAE;;;;AAI/C,eAAW,GAAG,IAAI,CAAC;AACnB,QAAI,YAAY,EAAE;AAChB,UAAI,CAAC,IAAI,CAAC;AACR,YAAI,EAAE,wBAAwB;AAC9B,eAAO,EAAE,qEAAqE;OAC/E,CAAC,CAAC;KACJ,MAAM;AACL,kBAAY,CAAC,IAAI,EAAE,CAAC;KACrB;GACF,CAAC,CAAC;AACH,cAAY,GAAG,QAAQ,CAAC,MAAM,CAAC,OAAO,EAAE,UAAU,YAAY,EAAE;;;AAG9D,gBAAY,GAAG,IAAI,CAAC;GACrB,CAAC,CAAC;AACH,UAAQ,CAAC,IAAI,CAAC,OAAO,CAAC,CAAC;AACvB,MAAI,CAAC,MAAM,CAAC,WAAW,CAAC,CAAC;AACzB,MAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;CAC5B,CAAC,CAAC","file":"/packages/ddp-server/crossbar_tests.js.map","sourcesContent":["// White box tests of invalidation crossbar matching function.\n// Note: the current crossbar match function is designed specifically\n// to ensure that a modification that targets a specific ID does not\n// notify a query that is watching a different specific ID. (And to\n// keep separate collections separate.) Other than that, there's no\n// deep meaning to the matching function, and it could be changed later\n// as long as it preserves that property.\nTinytest.add('livedata - crossbar', function (test) {\n  var crossbar = new DDPServer._Crossbar;\n  test.isTrue(crossbar._matches({collection: \"C\"},\n                                {collection: \"C\"}));\n  test.isTrue(crossbar._matches({collection: \"C\", id: \"X\"},\n                                {collection: \"C\"}));\n  test.isTrue(crossbar._matches({collection: \"C\"},\n                                {collection: \"C\", id: \"X\"}));\n  test.isTrue(crossbar._matches({collection: \"C\", id: \"X\"},\n                                {collection: \"C\"}));\n\n  test.isFalse(crossbar._matches({collection: \"C\", id: \"X\"},\n                                 {collection: \"C\", id: \"Y\"}));\n\n  // Test that stopped listens definitely don't fire.\n  var calledFirst = false;\n  var calledSecond = false;\n  var trigger = {collection: \"C\"};\n  var secondHandle;\n  crossbar.listen(trigger, function (notification) {\n    // This test assumes that listeners will be called in the order\n    // registered. It's not wrong for the crossbar to do something different,\n    // but the test won't be valid in that case, so make it fail so we notice.\n    calledFirst = true;\n    if (calledSecond) {\n      test.fail({\n        type: \"test_assumption_failed\",\n        message: \"test assumed that listeners would be called in the order registered\"\n      });\n    } else {\n      secondHandle.stop();\n    }\n  });\n  secondHandle = crossbar.listen(trigger, function (notification) {\n    // This should not get invoked, because it should be stopped by the other\n    // listener!\n    calledSecond = true;\n  });\n  crossbar.fire(trigger);\n  test.isTrue(calledFirst);\n  test.isFalse(calledSecond);\n});\n"]},"hash":"bdc8d3e0f3f8f467132bfc581375e162c0ae8a4a"}
