{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"var Fiber = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nDocFetcher = function (mongoConnection) {\n  var self = this;\n  self._mongoConnection = mongoConnection;\n  // Map from cache key -> [callback]\n  self._callbacksForCacheKey = {};\n};\n\n_.extend(DocFetcher.prototype, {\n  // Fetches document \"id\" from collectionName, returning it or null if not\n  // found.\n  //\n  // If you make multiple calls to fetch() with the same cacheKey (a string),\n  // DocFetcher may assume that they all return the same document. (It does\n  // not check to see if collectionName/id match.)\n  //\n  // You may assume that callback is never called synchronously (and in fact\n  // OplogObserveDriver does so).\n  fetch: function (collectionName, id, cacheKey, callback) {\n    var self = this;\n\n    check(collectionName, String);\n    // id is some sort of scalar\n    check(cacheKey, String);\n\n    // If there's already an in-progress fetch for this cache key, yield until\n    // it's done and return whatever it returns.\n    if (_.has(self._callbacksForCacheKey, cacheKey)) {\n      self._callbacksForCacheKey[cacheKey].push(callback);\n      return;\n    }\n\n    var callbacks = self._callbacksForCacheKey[cacheKey] = [callback];\n\n    Fiber(function () {\n      try {\n        var doc = self._mongoConnection.findOne(collectionName, { _id: id }) || null;\n        // Return doc to all relevant callbacks. Note that this array can\n        // continue to grow during callback excecution.\n        while (!_.isEmpty(callbacks)) {\n          // Clone the document so that the various calls to fetch don't return\n          // objects that are intertwingled with each other. Clone before\n          // popping the future, so that if clone throws, the error gets passed\n          // to the next callback.\n          var clonedDoc = EJSON.clone(doc);\n          callbacks.pop()(null, clonedDoc);\n        }\n      } catch (e) {\n        while (!_.isEmpty(callbacks)) {\n          callbacks.pop()(e);\n        }\n      } finally {\n        // XXX consider keeping the doc around for a period of time before\n        // removing from the cache\n        delete self._callbacksForCacheKey[cacheKey];\n      }\n    }).run();\n  }\n});\n\nMongoTest.DocFetcher = DocFetcher;","ast":null,"map":{"version":3,"sources":["/packages/mongo/doc_fetcher.js"],"names":[],"mappings":"AAAA,IAAI,KAAK,GAAG,GAAG,CAAC,OAAO,CAAC,QAAQ,CAAC,CAAC;AAClC,IAAI,MAAM,GAAG,GAAG,CAAC,OAAO,CAAC,eAAe,CAAC,CAAC;;AAE1C,UAAU,GAAG,UAAU,eAAe,EAAE;AACtC,MAAI,IAAI,GAAG,IAAI,CAAC;AAChB,MAAI,CAAC,gBAAgB,GAAG,eAAe,CAAC;;AAExC,MAAI,CAAC,qBAAqB,GAAG,EAAE,CAAC;CACjC,CAAC;;AAEF,CAAC,CAAC,MAAM,CAAC,UAAU,CAAC,SAAS,EAAE;;;;;;;;;;AAU7B,OAAK,EAAE,UAAU,cAAc,EAAE,EAAE,EAAE,QAAQ,EAAE,QAAQ,EAAE;AACvD,QAAI,IAAI,GAAG,IAAI,CAAC;;AAEhB,SAAK,CAAC,cAAc,EAAE,MAAM,CAAC,CAAC;;AAE9B,SAAK,CAAC,QAAQ,EAAE,MAAM,CAAC,CAAC;;;;AAIxB,QAAI,CAAC,CAAC,GAAG,CAAC,IAAI,CAAC,qBAAqB,EAAE,QAAQ,CAAC,EAAE;AAC/C,UAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC,IAAI,CAAC,QAAQ,CAAC,CAAC;AACpD,aAAO;KACR;;AAED,QAAI,SAAS,GAAG,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,GAAG,CAAC,QAAQ,CAAC,CAAC;;AAElE,SAAK,CAAC,YAAY;AAChB,UAAI;AACF,YAAI,GAAG,GAAG,IAAI,CAAC,gBAAgB,CAAC,OAAO,CACrC,cAAc,EAAE,EAAC,GAAG,EAAE,EAAE,EAAC,CAAC,IAAI,IAAI,CAAC;;;AAGrC,eAAO,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;;;;;AAK5B,cAAI,SAAS,GAAG,KAAK,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC;AACjC,mBAAS,CAAC,GAAG,EAAE,CAAC,IAAI,EAAE,SAAS,CAAC,CAAC;SAClC;OACF,CAAC,OAAO,CAAC,EAAE;AACV,eAAO,CAAC,CAAC,CAAC,OAAO,CAAC,SAAS,CAAC,EAAE;AAC5B,mBAAS,CAAC,GAAG,EAAE,CAAC,CAAC,CAAC,CAAC;SACpB;OACF,SAAS;;;AAGR,eAAO,IAAI,CAAC,qBAAqB,CAAC,QAAQ,CAAC,CAAC;OAC7C;KACF,CAAC,CAAC,GAAG,EAAE,CAAC;GACV;CACF,CAAC,CAAC;;AAEH,SAAS,CAAC,UAAU,GAAG,UAAU,CAAC","file":"/packages/mongo/doc_fetcher.js.map","sourcesContent":["var Fiber = Npm.require('fibers');\nvar Future = Npm.require('fibers/future');\n\nDocFetcher = function (mongoConnection) {\n  var self = this;\n  self._mongoConnection = mongoConnection;\n  // Map from cache key -> [callback]\n  self._callbacksForCacheKey = {};\n};\n\n_.extend(DocFetcher.prototype, {\n  // Fetches document \"id\" from collectionName, returning it or null if not\n  // found.\n  //\n  // If you make multiple calls to fetch() with the same cacheKey (a string),\n  // DocFetcher may assume that they all return the same document. (It does\n  // not check to see if collectionName/id match.)\n  //\n  // You may assume that callback is never called synchronously (and in fact\n  // OplogObserveDriver does so).\n  fetch: function (collectionName, id, cacheKey, callback) {\n    var self = this;\n\n    check(collectionName, String);\n    // id is some sort of scalar\n    check(cacheKey, String);\n\n    // If there's already an in-progress fetch for this cache key, yield until\n    // it's done and return whatever it returns.\n    if (_.has(self._callbacksForCacheKey, cacheKey)) {\n      self._callbacksForCacheKey[cacheKey].push(callback);\n      return;\n    }\n\n    var callbacks = self._callbacksForCacheKey[cacheKey] = [callback];\n\n    Fiber(function () {\n      try {\n        var doc = self._mongoConnection.findOne(\n          collectionName, {_id: id}) || null;\n        // Return doc to all relevant callbacks. Note that this array can\n        // continue to grow during callback excecution.\n        while (!_.isEmpty(callbacks)) {\n          // Clone the document so that the various calls to fetch don't return\n          // objects that are intertwingled with each other. Clone before\n          // popping the future, so that if clone throws, the error gets passed\n          // to the next callback.\n          var clonedDoc = EJSON.clone(doc);\n          callbacks.pop()(null, clonedDoc);\n        }\n      } catch (e) {\n        while (!_.isEmpty(callbacks)) {\n          callbacks.pop()(e);\n        }\n      } finally {\n        // XXX consider keeping the doc around for a period of time before\n        // removing from the cache\n        delete self._callbacksForCacheKey[cacheKey];\n      }\n    }).run();\n  }\n});\n\nMongoTest.DocFetcher = DocFetcher;\n"]},"hash":"8e7f469c37bb61e193cb3a471ce718c17530da57"}
