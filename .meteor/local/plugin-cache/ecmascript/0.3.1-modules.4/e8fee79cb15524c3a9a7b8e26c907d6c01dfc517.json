{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"PollingObserveDriver = function (options) {\n  var self = this;\n\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._ordered = options.ordered;\n  self._multiplexer = options.multiplexer;\n  self._stopCallbacks = [];\n  self._stopped = false;\n\n  self._synchronousCursor = self._mongoHandle._createSynchronousCursor(self._cursorDescription);\n\n  // previous results snapshot.  on each poll cycle, diffs against\n  // results drives the callbacks.\n  self._results = null;\n\n  // The number of _pollMongo calls that have been added to self._taskQueue but\n  // have not started running. Used to make sure we never schedule more than one\n  // _pollMongo (other than possibly the one that is currently running). It's\n  // also used by _suspendPolling to pretend there's a poll scheduled. Usually,\n  // it's either 0 (for \"no polls scheduled other than maybe one currently\n  // running\") or 1 (for \"a poll scheduled that isn't running yet\"), but it can\n  // also be 2 if incremented by _suspendPolling.\n  self._pollsScheduledButNotStarted = 0;\n  self._pendingWrites = []; // people to notify when polling completes\n\n  // Make sure to create a separately throttled function for each\n  // PollingObserveDriver object.\n  self._ensurePollIsScheduled = _.throttle(self._unthrottledEnsurePollIsScheduled, 50 /* ms */);\n\n  // XXX figure out if we still need a queue\n  self._taskQueue = new Meteor._SynchronousQueue();\n\n  var listenersHandle = listenAll(self._cursorDescription, function (notification) {\n    // When someone does a transaction that might affect us, schedule a poll\n    // of the database. If that transaction happens inside of a write fence,\n    // block the fence until we've polled and notified observers.\n    var fence = DDPServer._CurrentWriteFence.get();\n    if (fence) self._pendingWrites.push(fence.beginWrite());\n    // Ensure a poll is scheduled... but if we already know that one is,\n    // don't hit the throttled _ensurePollIsScheduled function (which might\n    // lead to us calling it unnecessarily in 50ms).\n    if (self._pollsScheduledButNotStarted === 0) self._ensurePollIsScheduled();\n  });\n  self._stopCallbacks.push(function () {\n    listenersHandle.stop();\n  });\n\n  // every once and a while, poll even if we don't think we're dirty, for\n  // eventual consistency with database writes from outside the Meteor\n  // universe.\n  //\n  // For testing, there's an undocumented callback argument to observeChanges\n  // which disables time-based polling and gets called at the beginning of each\n  // poll.\n  if (options._testOnlyPollCallback) {\n    self._testOnlyPollCallback = options._testOnlyPollCallback;\n  } else {\n    var pollingInterval = self._cursorDescription.options._pollingInterval || 10 * 1000;\n    var intervalHandle = Meteor.setInterval(_.bind(self._ensurePollIsScheduled, self), pollingInterval);\n    self._stopCallbacks.push(function () {\n      Meteor.clearInterval(intervalHandle);\n    });\n  }\n\n  // Make sure we actually poll soon!\n  self._unthrottledEnsurePollIsScheduled();\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", 1);\n};\n\n_.extend(PollingObserveDriver.prototype, {\n  // This is always called through _.throttle (except once at startup).\n  _unthrottledEnsurePollIsScheduled: function () {\n    var self = this;\n    if (self._pollsScheduledButNotStarted > 0) return;\n    ++self._pollsScheduledButNotStarted;\n    self._taskQueue.queueTask(function () {\n      self._pollMongo();\n    });\n  },\n\n  // test-only interface for controlling polling.\n  //\n  // _suspendPolling blocks until any currently running and scheduled polls are\n  // done, and prevents any further polls from being scheduled. (new\n  // ObserveHandles can be added and receive their initial added callbacks,\n  // though.)\n  //\n  // _resumePolling immediately polls, and allows further polls to occur.\n  _suspendPolling: function () {\n    var self = this;\n    // Pretend that there's another poll scheduled (which will prevent\n    // _ensurePollIsScheduled from queueing any more polls).\n    ++self._pollsScheduledButNotStarted;\n    // Now block until all currently running or scheduled polls are done.\n    self._taskQueue.runTask(function () {});\n\n    // Confirm that there is only one \"poll\" (the fake one we're pretending to\n    // have) scheduled.\n    if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted);\n  },\n  _resumePolling: function () {\n    var self = this;\n    // We should be in the same state as in the end of _suspendPolling.\n    if (self._pollsScheduledButNotStarted !== 1) throw new Error(\"_pollsScheduledButNotStarted is \" + self._pollsScheduledButNotStarted);\n    // Run a poll synchronously (which will counteract the\n    // ++_pollsScheduledButNotStarted from _suspendPolling).\n    self._taskQueue.runTask(function () {\n      self._pollMongo();\n    });\n  },\n\n  _pollMongo: function () {\n    var self = this;\n    --self._pollsScheduledButNotStarted;\n\n    if (self._stopped) return;\n\n    var first = false;\n    var oldResults = self._results;\n    if (!oldResults) {\n      first = true;\n      // XXX maybe use OrderedDict instead?\n      oldResults = self._ordered ? [] : new LocalCollection._IdMap();\n    }\n\n    self._testOnlyPollCallback && self._testOnlyPollCallback();\n\n    // Save the list of pending writes which this round will commit.\n    var writesForCycle = self._pendingWrites;\n    self._pendingWrites = [];\n\n    // Get the new query results. (This yields.)\n    try {\n      var newResults = self._synchronousCursor.getRawObjects(self._ordered);\n    } catch (e) {\n      if (first && typeof e.code === 'number') {\n        // This is an error document sent to us by mongod, not a connection\n        // error generated by the client. And we've never seen this query work\n        // successfully. Probably it's a bad selector or something, so we should\n        // NOT retry. Instead, we should halt the observe (which ends up calling\n        // `stop` on us).\n        self._multiplexer.queryError(new Error(\"Exception while polling query \" + JSON.stringify(self._cursorDescription) + \": \" + e.message));\n        return;\n      }\n\n      // getRawObjects can throw if we're having trouble talking to the\n      // database.  That's fine --- we will repoll later anyway. But we should\n      // make sure not to lose track of this cycle's writes.\n      // (It also can throw if there's just something invalid about this query;\n      // unfortunately the ObserveDriver API doesn't provide a good way to\n      // \"cancel\" the observe from the inside in this case.\n      Array.prototype.push.apply(self._pendingWrites, writesForCycle);\n      Meteor._debug(\"Exception while polling query \" + JSON.stringify(self._cursorDescription) + \": \" + e.stack);\n      return;\n    }\n\n    // Run diffs.\n    if (!self._stopped) {\n      LocalCollection._diffQueryChanges(self._ordered, oldResults, newResults, self._multiplexer);\n    }\n\n    // Signals the multiplexer to allow all observeChanges calls that share this\n    // multiplexer to return. (This happens asynchronously, via the\n    // multiplexer's queue.)\n    if (first) self._multiplexer.ready();\n\n    // Replace self._results atomically.  (This assignment is what makes `first`\n    // stay through on the next cycle, so we've waited until after we've\n    // committed to ready-ing the multiplexer.)\n    self._results = newResults;\n\n    // Once the ObserveMultiplexer has processed everything we've done in this\n    // round, mark all the writes which existed before this call as\n    // commmitted. (If new writes have shown up in the meantime, there'll\n    // already be another _pollMongo task scheduled.)\n    self._multiplexer.onFlush(function () {\n      _.each(writesForCycle, function (w) {\n        w.committed();\n      });\n    });\n  },\n\n  stop: function () {\n    var self = this;\n    self._stopped = true;\n    _.each(self._stopCallbacks, function (c) {\n      c();\n    });\n    // Release any write fences that are waiting on us.\n    _.each(self._pendingWrites, function (w) {\n      w.committed();\n    });\n    Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-drivers-polling\", -1);\n  }\n});","ast":null,"map":{"version":3,"sources":["/packages/mongo/polling_observe_driver.js"],"names":[],"mappings":"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","file":"/packages/mongo/polling_observe_driver.js.map","sourcesContent":["PollingObserveDriver = function (options) {\n  var self = this;\n\n  self._cursorDescription = options.cursorDescription;\n  self._mongoHandle = options.mongoHandle;\n  self._ordered = options.ordered;\n  self._multiplexer = options.multiplexer;\n  self._stopCallbacks = [];\n  self._stopped = false;\n\n  self._synchronousCursor = self._mongoHandle._createSynchronousCursor(\n    self._cursorDescription);\n\n  // previous results snapshot.  on each poll cycle, diffs against\n  // results drives the callbacks.\n  self._results = null;\n\n  // The number of _pollMongo calls that have been added to self._taskQueue but\n  // have not started running. Used to make sure we never schedule more than one\n  // _pollMongo (other than possibly the one that is currently running). It's\n  // also used by _suspendPolling to pretend there's a poll scheduled. Usually,\n  // it's either 0 (for \"no polls scheduled other than maybe one currently\n  // running\") or 1 (for \"a poll scheduled that isn't running yet\"), but it can\n  // also be 2 if incremented by _suspendPolling.\n  self._pollsScheduledButNotStarted = 0;\n  self._pendingWrites = []; // people to notify when polling completes\n\n  // Make sure to create a separately throttled function for each\n  // PollingObserveDriver object.\n  self._ensurePollIsScheduled = _.throttle(\n    self._unthrottledEnsurePollIsScheduled, 50 /* ms */);\n\n  // XXX figure out if we still need a queue\n  self._taskQueue = new Meteor._SynchronousQueue();\n\n  var listenersHandle = listenAll(\n    self._cursorDescription, function (notification) {\n      // When someone does a transaction that might affect us, schedule a poll\n      // of the database. If that transaction happens inside of a write fence,\n      // block the fence until we've polled and notified observers.\n      var fence = DDPServer._CurrentWriteFence.get();\n      if (fence)\n        self._pendingWrites.push(fence.beginWrite());\n      // Ensure a poll is scheduled... but if we already know that one is,\n      // don't hit the throttled _ensurePollIsScheduled function (which might\n      // lead to us calling it unnecessarily in 50ms).\n      if (self._pollsScheduledButNotStarted === 0)\n        self._ensurePollIsScheduled();\n    }\n  );\n  self._stopCallbacks.push(function () { listenersHandle.stop(); });\n\n  // every once and a while, poll even if we don't think we're dirty, for\n  // eventual consistency with database writes from outside the Meteor\n  // universe.\n  //\n  // For testing, there's an undocumented callback argument to observeChanges\n  // which disables time-based polling and gets called at the beginning of each\n  // poll.\n  if (options._testOnlyPollCallback) {\n    self._testOnlyPollCallback = options._testOnlyPollCallback;\n  } else {\n    var pollingInterval = self._cursorDescription.options._pollingInterval || 10 * 1000;\n    var intervalHandle = Meteor.setInterval(\n      _.bind(self._ensurePollIsScheduled, self), pollingInterval);\n    self._stopCallbacks.push(function () {\n      Meteor.clearInterval(intervalHandle);\n    });\n  }\n\n  // Make sure we actually poll soon!\n  self._unthrottledEnsurePollIsScheduled();\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-drivers-polling\", 1);\n};\n\n_.extend(PollingObserveDriver.prototype, {\n  // This is always called through _.throttle (except once at startup).\n  _unthrottledEnsurePollIsScheduled: function () {\n    var self = this;\n    if (self._pollsScheduledButNotStarted > 0)\n      return;\n    ++self._pollsScheduledButNotStarted;\n    self._taskQueue.queueTask(function () {\n      self._pollMongo();\n    });\n  },\n\n  // test-only interface for controlling polling.\n  //\n  // _suspendPolling blocks until any currently running and scheduled polls are\n  // done, and prevents any further polls from being scheduled. (new\n  // ObserveHandles can be added and receive their initial added callbacks,\n  // though.)\n  //\n  // _resumePolling immediately polls, and allows further polls to occur.\n  _suspendPolling: function() {\n    var self = this;\n    // Pretend that there's another poll scheduled (which will prevent\n    // _ensurePollIsScheduled from queueing any more polls).\n    ++self._pollsScheduledButNotStarted;\n    // Now block until all currently running or scheduled polls are done.\n    self._taskQueue.runTask(function() {});\n\n    // Confirm that there is only one \"poll\" (the fake one we're pretending to\n    // have) scheduled.\n    if (self._pollsScheduledButNotStarted !== 1)\n      throw new Error(\"_pollsScheduledButNotStarted is \" +\n                      self._pollsScheduledButNotStarted);\n  },\n  _resumePolling: function() {\n    var self = this;\n    // We should be in the same state as in the end of _suspendPolling.\n    if (self._pollsScheduledButNotStarted !== 1)\n      throw new Error(\"_pollsScheduledButNotStarted is \" +\n                      self._pollsScheduledButNotStarted);\n    // Run a poll synchronously (which will counteract the\n    // ++_pollsScheduledButNotStarted from _suspendPolling).\n    self._taskQueue.runTask(function () {\n      self._pollMongo();\n    });\n  },\n\n  _pollMongo: function () {\n    var self = this;\n    --self._pollsScheduledButNotStarted;\n\n    if (self._stopped)\n      return;\n\n    var first = false;\n    var oldResults = self._results;\n    if (!oldResults) {\n      first = true;\n      // XXX maybe use OrderedDict instead?\n      oldResults = self._ordered ? [] : new LocalCollection._IdMap;\n    }\n\n    self._testOnlyPollCallback && self._testOnlyPollCallback();\n\n    // Save the list of pending writes which this round will commit.\n    var writesForCycle = self._pendingWrites;\n    self._pendingWrites = [];\n\n    // Get the new query results. (This yields.)\n    try {\n      var newResults = self._synchronousCursor.getRawObjects(self._ordered);\n    } catch (e) {\n      if (first && typeof(e.code) === 'number') {\n        // This is an error document sent to us by mongod, not a connection\n        // error generated by the client. And we've never seen this query work\n        // successfully. Probably it's a bad selector or something, so we should\n        // NOT retry. Instead, we should halt the observe (which ends up calling\n        // `stop` on us).\n        self._multiplexer.queryError(\n          new Error(\n            \"Exception while polling query \" +\n              JSON.stringify(self._cursorDescription) + \": \" + e.message));\n        return;\n      }\n\n      // getRawObjects can throw if we're having trouble talking to the\n      // database.  That's fine --- we will repoll later anyway. But we should\n      // make sure not to lose track of this cycle's writes.\n      // (It also can throw if there's just something invalid about this query;\n      // unfortunately the ObserveDriver API doesn't provide a good way to\n      // \"cancel\" the observe from the inside in this case.\n      Array.prototype.push.apply(self._pendingWrites, writesForCycle);\n      Meteor._debug(\"Exception while polling query \" +\n                    JSON.stringify(self._cursorDescription) + \": \" + e.stack);\n      return;\n    }\n\n    // Run diffs.\n    if (!self._stopped) {\n      LocalCollection._diffQueryChanges(\n        self._ordered, oldResults, newResults, self._multiplexer);\n    }\n\n    // Signals the multiplexer to allow all observeChanges calls that share this\n    // multiplexer to return. (This happens asynchronously, via the\n    // multiplexer's queue.)\n    if (first)\n      self._multiplexer.ready();\n\n    // Replace self._results atomically.  (This assignment is what makes `first`\n    // stay through on the next cycle, so we've waited until after we've\n    // committed to ready-ing the multiplexer.)\n    self._results = newResults;\n\n    // Once the ObserveMultiplexer has processed everything we've done in this\n    // round, mark all the writes which existed before this call as\n    // commmitted. (If new writes have shown up in the meantime, there'll\n    // already be another _pollMongo task scheduled.)\n    self._multiplexer.onFlush(function () {\n      _.each(writesForCycle, function (w) {\n        w.committed();\n      });\n    });\n  },\n\n  stop: function () {\n    var self = this;\n    self._stopped = true;\n    _.each(self._stopCallbacks, function (c) { c(); });\n    // Release any write fences that are waiting on us.\n    _.each(self._pendingWrites, function (w) {\n      w.committed();\n    });\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-drivers-polling\", -1);\n  }\n});\n"]},"hash":"e8fee79cb15524c3a9a7b8e26c907d6c01dfc517"}
