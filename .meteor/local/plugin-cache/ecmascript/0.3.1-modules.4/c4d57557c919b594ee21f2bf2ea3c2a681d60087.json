{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"/**\n * Provide a synchronous Collection API using fibers, backed by\n * MongoDB.  This is only for use on the server, and mostly identical\n * to the client API.\n *\n * NOTE: the public API methods must be run within a fiber. If you call\n * these outside of a fiber they will explode!\n */\n\nvar path = Npm.require('path');\nvar MongoDB = NpmModuleMongodb;\nvar Fiber = Npm.require('fibers');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\nMongoInternals = {};\nMongoTest = {};\n\nMongoInternals.NpmModules = {\n  mongodb: {\n    version: NpmModuleMongodbVersion,\n    module: MongoDB\n  }\n};\n\n// Older version of what is now available via\n// MongoInternals.NpmModules.mongodb.module.  It was never documented, but\n// people do use it.\n// XXX COMPAT WITH 1.0.3.2\nMongoInternals.NpmModule = MongoDB;\n\n// This is used to add or remove EJSON from the beginning of everything nested\n// inside an EJSON custom type. It should only be called on pure JSON!\nvar replaceNames = function (filter, thing) {\n  if (typeof thing === \"object\") {\n    if (_.isArray(thing)) {\n      return _.map(thing, _.bind(replaceNames, null, filter));\n    }\n    var ret = {};\n    _.each(thing, function (value, key) {\n      ret[filter(key)] = replaceNames(filter, value);\n    });\n    return ret;\n  }\n  return thing;\n};\n\n// Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just\n// doing a structural clone).\n// XXX how ok is this? what if there are multiple copies of MongoDB loaded?\nMongoDB.Timestamp.prototype.clone = function () {\n  // Timestamps should be immutable.\n  return this;\n};\n\nvar makeMongoLegal = function (name) {\n  return \"EJSON\" + name;\n};\nvar unmakeMongoLegal = function (name) {\n  return name.substr(5);\n};\n\nvar replaceMongoAtomWithMeteor = function (document) {\n  if (document instanceof MongoDB.Binary) {\n    var buffer = document.value(true);\n    return new Uint8Array(buffer);\n  }\n  if (document instanceof MongoDB.ObjectID) {\n    return new Mongo.ObjectID(document.toHexString());\n  }\n  if (document[\"EJSON$type\"] && document[\"EJSON$value\"] && _.size(document) === 2) {\n    return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  return undefined;\n};\n\nvar replaceMeteorAtomWithMongo = function (document) {\n  if (EJSON.isBinary(document)) {\n    // This does more copies than we'd like, but is necessary because\n    // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n    // serialize it correctly).\n    return new MongoDB.Binary(new Buffer(document));\n  }\n  if (document instanceof Mongo.ObjectID) {\n    return new MongoDB.ObjectID(document.toHexString());\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  if (EJSON._isCustomType(document)) {\n    return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n  }\n  // It is not ordinarily possible to stick dollar-sign keys into mongo\n  // so we don't bother checking for things that need escaping at this time.\n  return undefined;\n};\n\nvar replaceTypes = function (document, atomTransformer) {\n  if (typeof document !== 'object' || document === null) return document;\n\n  var replacedTopLevelAtom = atomTransformer(document);\n  if (replacedTopLevelAtom !== undefined) return replacedTopLevelAtom;\n\n  var ret = document;\n  _.each(document, function (val, key) {\n    var valReplaced = replaceTypes(val, atomTransformer);\n    if (val !== valReplaced) {\n      // Lazy clone. Shallow copy.\n      if (ret === document) ret = _.clone(document);\n      ret[key] = valReplaced;\n    }\n  });\n  return ret;\n};\n\nMongoConnection = function (url, options) {\n  var self = this;\n  options = options || {};\n  self._observeMultiplexers = {};\n  self._onFailoverHook = new Hook();\n\n  var mongoOptions = { db: { safe: true }, server: {}, replSet: {} };\n\n  // Set autoReconnect to true, unless passed on the URL. Why someone\n  // would want to set autoReconnect to false, I'm not really sure, but\n  // keeping this for backwards compatibility for now.\n  if (!/[\\?&]auto_?[rR]econnect=/.test(url)) {\n    mongoOptions.server.auto_reconnect = true;\n  }\n\n  // Disable the native parser by default, unless specifically enabled\n  // in the mongo URL.\n  // - The native driver can cause errors which normally would be\n  //   thrown, caught, and handled into segfaults that take down the\n  //   whole app.\n  // - Binary modules don't yet work when you bundle and move the bundle\n  //   to a different platform (aka deploy)\n  // We should revisit this after binary npm module support lands.\n  if (!/[\\?&]native_?[pP]arser=/.test(url)) {\n    mongoOptions.db.native_parser = false;\n  }\n\n  // XXX maybe we should have a better way of allowing users to configure the\n  // underlying Mongo driver\n  if (_.has(options, 'poolSize')) {\n    // If we just set this for \"server\", replSet will override it. If we just\n    // set it for replSet, it will be ignored if we're not using a replSet.\n    mongoOptions.server.poolSize = options.poolSize;\n    mongoOptions.replSet.poolSize = options.poolSize;\n  }\n\n  self.db = null;\n  // We keep track of the ReplSet's primary, so that we can trigger hooks when\n  // it changes.  The Node driver's joined callback seems to fire way too\n  // often, which is why we need to track it ourselves.\n  self._primary = null;\n  self._oplogHandle = null;\n  self._docFetcher = null;\n\n  var connectFuture = new Future();\n  MongoDB.connect(url, mongoOptions, Meteor.bindEnvironment(function (err, db) {\n    if (err) {\n      throw err;\n    }\n\n    // First, figure out what the current primary is, if any.\n    if (db.serverConfig._state.master) self._primary = db.serverConfig._state.master.name;\n    db.serverConfig.on('joined', Meteor.bindEnvironment(function (kind, doc) {\n      if (kind === 'primary') {\n        if (doc.primary !== self._primary) {\n          self._primary = doc.primary;\n          self._onFailoverHook.each(function (callback) {\n            callback();\n            return true;\n          });\n        }\n      } else if (doc.me === self._primary) {\n        // The thing we thought was primary is now something other than\n        // primary.  Forget that we thought it was primary.  (This means\n        // that if a server stops being primary and then starts being\n        // primary again without another server becoming primary in the\n        // middle, we'll correctly count it as a failover.)\n        self._primary = null;\n      }\n    }));\n\n    // Allow the constructor to return.\n    connectFuture['return'](db);\n  }, connectFuture.resolver() // onException\n  ));\n\n  // Wait for the connection to be successful; throws on failure.\n  self.db = connectFuture.wait();\n\n  if (options.oplogUrl && !Package['disable-oplog']) {\n    self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n    self._docFetcher = new DocFetcher(self);\n  }\n};\n\nMongoConnection.prototype.close = function () {\n  var self = this;\n\n  if (!self.db) throw Error(\"close called before Connection created?\");\n\n  // XXX probably untested\n  var oplogHandle = self._oplogHandle;\n  self._oplogHandle = null;\n  if (oplogHandle) oplogHandle.stop();\n\n  // Use Future.wrap so that errors get thrown. This happens to\n  // work even outside a fiber since the 'close' method is not\n  // actually asynchronous.\n  Future.wrap(_.bind(self.db.close, self.db))(true).wait();\n};\n\n// Returns the Mongo Collection object; may yield.\nMongoConnection.prototype.rawCollection = function (collectionName) {\n  var self = this;\n\n  if (!self.db) throw Error(\"rawCollection called before Connection created?\");\n\n  var future = new Future();\n  self.db.collection(collectionName, future.resolver());\n  return future.wait();\n};\n\nMongoConnection.prototype._createCappedCollection = function (collectionName, byteSize, maxDocuments) {\n  var self = this;\n\n  if (!self.db) throw Error(\"_createCappedCollection called before Connection created?\");\n\n  var future = new Future();\n  self.db.createCollection(collectionName, { capped: true, size: byteSize, max: maxDocuments }, future.resolver());\n  future.wait();\n};\n\n// This should be called synchronously with a write, to create a\n// transaction on the current write fence, if any. After we can read\n// the write, and after observers have been notified (or at least,\n// after the observer notifiers have added themselves to the write\n// fence), you should call 'committed()' on the object returned.\nMongoConnection.prototype._maybeBeginWrite = function () {\n  var self = this;\n  var fence = DDPServer._CurrentWriteFence.get();\n  if (fence) return fence.beginWrite();else return { committed: function () {} };\n};\n\n// Internal interface: adds a callback which is called when the Mongo primary\n// changes. Returns a stop handle.\nMongoConnection.prototype._onFailover = function (callback) {\n  return this._onFailoverHook.register(callback);\n};\n\n//////////// Public API //////////\n\n// The write methods block until the database has confirmed the write (it may\n// not be replicated or stable on disk, but one server has confirmed it) if no\n// callback is provided. If a callback is provided, then they call the callback\n// when the write is confirmed. They return nothing on success, and raise an\n// exception on failure.\n//\n// After making a write (with insert, update, remove), observers are\n// notified asynchronously. If you want to receive a callback once all\n// of the observer notifications have landed for your write, do the\n// writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n// _WriteFence, and then set a callback on the write fence.)\n//\n// Since our execution environment is single-threaded, this is\n// well-defined -- a write \"has been made\" if it's returned, and an\n// observer \"has been notified\" if its callback has returned.\n\nvar writeCallback = function (write, refresh, callback) {\n  return function (err, result) {\n    if (!err) {\n      // XXX We don't have to run this on error, right?\n      try {\n        refresh();\n      } catch (refreshErr) {\n        if (callback) {\n          callback(refreshErr);\n          return;\n        } else {\n          throw refreshErr;\n        }\n      }\n    }\n    write.committed();\n    if (callback) callback(err, result);else if (err) throw err;\n  };\n};\n\nvar bindEnvironmentForWrite = function (callback) {\n  return Meteor.bindEnvironment(callback, \"Mongo write\");\n};\n\nMongoConnection.prototype._insert = function (collection_name, document, callback) {\n  var self = this;\n\n  var sendError = function (e) {\n    if (callback) return callback(e);\n    throw e;\n  };\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n    sendError(e);\n    return;\n  }\n\n  if (!(LocalCollection._isPlainObject(document) && !EJSON._isCustomType(document))) {\n    sendError(new Error(\"Only plain objects may be inserted into MongoDB\"));\n    return;\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({ collection: collection_name, id: document._id });\n  };\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n  try {\n    var collection = self.rawCollection(collection_name);\n    collection.insert(replaceTypes(document, replaceMeteorAtomWithMongo), { safe: true }, callback);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\n// Cause queries that may be affected by the selector to poll in this write\n// fence.\nMongoConnection.prototype._refresh = function (collectionName, selector) {\n  var self = this;\n  var refreshKey = { collection: collectionName };\n  // If we know which documents we're removing, don't poll queries that are\n  // specific to other documents. (Note that multiple notifications here should\n  // not cause multiple polls, since all our listener is doing is enqueueing a\n  // poll.)\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      Meteor.refresh(_.extend({ id: id }, refreshKey));\n    });\n  } else {\n    Meteor.refresh(refreshKey);\n  }\n};\n\nMongoConnection.prototype._remove = function (collection_name, selector, callback) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n    if (callback) return callback(e);else throw e;\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n\n  try {\n    var collection = self.rawCollection(collection_name);\n    collection.remove(replaceTypes(selector, replaceMeteorAtomWithMongo), { safe: true }, callback);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nMongoConnection.prototype._dropCollection = function (collectionName, cb) {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({ collection: collectionName, id: null,\n      dropCollection: true });\n  };\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    var collection = self.rawCollection(collectionName);\n    collection.drop(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\n// For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n// because it lets the test's fence wait for it to be complete.\nMongoConnection.prototype._dropDatabase = function (cb) {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({ dropDatabase: true });\n  };\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    self.db.dropDatabase(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nMongoConnection.prototype._update = function (collection_name, selector, mod, options, callback) {\n  var self = this;\n\n  if (!callback && options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n    if (callback) return callback(e);else throw e;\n  }\n\n  // explicit safety check. null and undefined can crash the mongo\n  // driver. Although the node driver and minimongo do 'support'\n  // non-object modifier in that they don't crash, they are not\n  // meaningful operations and do not do anything. Defensively throw an\n  // error here.\n  if (!mod || typeof mod !== 'object') throw new Error(\"Invalid modifier. Modifier must be an object.\");\n\n  if (!(LocalCollection._isPlainObject(mod) && !EJSON._isCustomType(mod))) {\n    throw new Error(\"Only plain objects may be used as replacement\" + \" documents in MongoDB\");\n    return;\n  }\n\n  if (!options) options = {};\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n  callback = writeCallback(write, refresh, callback);\n  try {\n    var collection = self.rawCollection(collection_name);\n    var mongoOpts = { safe: true };\n    // explictly enumerate options that minimongo supports\n    if (options.upsert) mongoOpts.upsert = true;\n    if (options.multi) mongoOpts.multi = true;\n    // Lets you get a more more full result from MongoDB. Use with caution:\n    // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n    // with simulated upsert.\n    if (options.fullResult) mongoOpts.fullResult = true;\n\n    var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n    var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n\n    var isModify = isModificationMod(mongoMod);\n    var knownId = selector._id || mod._id;\n\n    if (options._forbidReplace && !isModify) {\n      var e = new Error(\"Invalid modifier. Replacements are forbidden.\");\n      if (callback) {\n        return callback(e);\n      } else {\n        throw e;\n      }\n    }\n\n    if (options.upsert && !knownId && options.insertedId) {\n      // XXX If we know we're using Mongo 2.6 (and this isn't a replacement)\n      //     we should be able to just use $setOnInsert instead of this\n      //     simulated upsert thing. (We can't use $setOnInsert with\n      //     replacements because there's nowhere to write it, and $setOnInsert\n      //     can't set _id on Mongo 2.4.)\n      //\n      //     Also, in the future we could do a real upsert for the mongo id\n      //     generation case, if the the node mongo driver gives us back the id\n      //     of the upserted doc (which our current version does not).\n      //\n      //     For more context, see\n      //     https://github.com/meteor/meteor/issues/2278#issuecomment-64252706\n      simulateUpsertWithInsertedId(collection, mongoSelector, mongoMod, isModify, options,\n      // This callback does not need to be bindEnvironment'ed because\n      // simulateUpsertWithInsertedId() wraps it and then passes it through\n      function (err, result) {\n        // If we got here via a upsert() call, then options._returnObject will\n        // be set and we should return the whole object. Otherwise, we should\n        // just return the number of affected docs to match the mongo API.\n        if (result && !options._returnObject) callback(err, result.numberAffected);else callback(err, result);\n      });\n    } else {\n      collection.update(mongoSelector, mongoMod, mongoOpts, bindEnvironmentForWrite(function (err, result, extra) {\n        if (!err) {\n          if (result && options._returnObject) {\n            result = { numberAffected: result };\n            // If this was an upsert() call, and we ended up\n            // inserting a new doc and we know its id, then\n            // return that id as well.\n            if (options.upsert && knownId && !extra.updatedExisting) result.insertedId = knownId;\n          }\n        }\n        callback(err, result);\n      }));\n    }\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nvar isModificationMod = function (mod) {\n  var isReplace = false;\n  var isModify = false;\n  for (var k in babelHelpers.sanitizeForInObject(mod)) {\n    if (k.substr(0, 1) === '$') {\n      isModify = true;\n    } else {\n      isReplace = true;\n    }\n  }\n  if (isModify && isReplace) {\n    throw new Error(\"Update parameter cannot have both modifier and non-modifier fields.\");\n  }\n  return isModify;\n};\n\nvar NUM_OPTIMISTIC_TRIES = 3;\n\n// exposed for testing\nMongoConnection._isCannotChangeIdError = function (err) {\n  // First check for what this error looked like in Mongo 2.4.  Either of these\n  // checks should work, but just to be safe...\n  if (err.code === 13596) return true;\n  if (err.err.indexOf(\"cannot change _id of a document\") === 0) return true;\n\n  // Now look for what it looks like in Mongo 2.6.  We don't use the error code\n  // here, because the error code we observed it producing (16837) appears to be\n  // a far more generic error code based on examining the source.\n  if (err.err.indexOf(\"The _id field cannot be changed\") === 0) return true;\n\n  return false;\n};\n\nvar simulateUpsertWithInsertedId = function (collection, selector, mod, isModify, options, callback) {\n  // STRATEGY:  First try doing a plain update.  If it affected 0 documents,\n  // then without affecting the database, we know we should probably do an\n  // insert.  We then do a *conditional* insert that will fail in the case\n  // of a race condition.  This conditional insert is actually an\n  // upsert-replace with an _id, which will never successfully update an\n  // existing document.  If this upsert fails with an error saying it\n  // couldn't change an existing _id, then we know an intervening write has\n  // caused the query to match something.  We go back to step one and repeat.\n  // Like all \"optimistic write\" schemes, we rely on the fact that it's\n  // unlikely our writes will continue to be interfered with under normal\n  // circumstances (though sufficiently heavy contention with writers\n  // disagreeing on the existence of an object will cause writes to fail\n  // in theory).\n\n  var newDoc;\n  // Run this code up front so that it fails fast if someone uses\n  // a Mongo update operator we don't support.\n  if (isModify) {\n    // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n    // selector and mod.  We assume it doesn't matter, as far as\n    // the behavior of modifiers is concerned, whether `_modify`\n    // is run on EJSON or on mongo-converted EJSON.\n    var selectorDoc = LocalCollection._removeDollarOperators(selector);\n\n    newDoc = selectorDoc;\n\n    // Convert dotted keys into objects. (Resolves issue #4522).\n    _.each(newDoc, function (value, key) {\n      var trail = key.split(\".\");\n\n      if (trail.length > 1) {\n        //Key is dotted. Convert it into an object.\n        delete newDoc[key];\n\n        var obj = newDoc,\n            leaf = trail.pop();\n\n        // XXX It is not quite certain what should be done if there are clashing\n        // keys on the trail of the dotted key. For now we will just override it\n        // It wouldn't be a very sane query in the first place, but should look\n        // up what mongo does in this case.\n\n        while (key = trail.shift()) {\n          if (typeof obj[key] !== \"object\") {\n            obj[key] = {};\n          }\n\n          obj = obj[key];\n        }\n\n        obj[leaf] = value;\n      }\n    });\n\n    LocalCollection._modify(newDoc, mod, { isInsert: true });\n  } else {\n    newDoc = mod;\n  }\n\n  var insertedId = options.insertedId; // must exist\n  var mongoOptsForUpdate = {\n    safe: true,\n    multi: options.multi\n  };\n  var mongoOptsForInsert = {\n    safe: true,\n    upsert: true\n  };\n\n  var tries = NUM_OPTIMISTIC_TRIES;\n\n  var doUpdate = function () {\n    tries--;\n    if (!tries) {\n      callback(new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\"));\n    } else {\n      collection.update(selector, mod, mongoOptsForUpdate, bindEnvironmentForWrite(function (err, result) {\n        if (err) callback(err);else if (result) callback(null, {\n          numberAffected: result\n        });else doConditionalInsert();\n      }));\n    }\n  };\n\n  var doConditionalInsert = function () {\n    var replacementWithId = _.extend(replaceTypes({ _id: insertedId }, replaceMeteorAtomWithMongo), newDoc);\n    collection.update(selector, replacementWithId, mongoOptsForInsert, bindEnvironmentForWrite(function (err, result) {\n      if (err) {\n        // figure out if this is a\n        // \"cannot change _id of document\" error, and\n        // if so, try doUpdate() again, up to 3 times.\n        if (MongoConnection._isCannotChangeIdError(err)) {\n          doUpdate();\n        } else {\n          callback(err);\n        }\n      } else {\n        callback(null, {\n          numberAffected: result,\n          insertedId: insertedId\n        });\n      }\n    }));\n  };\n\n  doUpdate();\n};\n\n_.each([\"insert\", \"update\", \"remove\", \"dropCollection\", \"dropDatabase\"], function (method) {\n  MongoConnection.prototype[method] = function () /* arguments */{\n    var self = this;\n    return Meteor.wrapAsync(self[\"_\" + method]).apply(self, arguments);\n  };\n});\n\n// XXX MongoConnection.upsert() does not return the id of the inserted document\n// unless you set it explicitly in the selector or modifier (as a replacement\n// doc).\nMongoConnection.prototype.upsert = function (collectionName, selector, mod, options, callback) {\n  var self = this;\n  if (typeof options === \"function\" && !callback) {\n    callback = options;\n    options = {};\n  }\n\n  return self.update(collectionName, selector, mod, _.extend({}, options, {\n    upsert: true,\n    _returnObject: true\n  }), callback);\n};\n\nMongoConnection.prototype.find = function (collectionName, selector, options) {\n  var self = this;\n\n  if (arguments.length === 1) selector = {};\n\n  return new Cursor(self, new CursorDescription(collectionName, selector, options));\n};\n\nMongoConnection.prototype.findOne = function (collection_name, selector, options) {\n  var self = this;\n  if (arguments.length === 1) selector = {};\n\n  options = options || {};\n  options.limit = 1;\n  return self.find(collection_name, selector, options).fetch()[0];\n};\n\n// We'll actually design an index API later. For now, we just pass through to\n// Mongo's, but make it synchronous.\nMongoConnection.prototype._ensureIndex = function (collectionName, index, options) {\n  var self = this;\n\n  // We expect this function to be called at startup, not from within a method,\n  // so we don't interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var future = new Future();\n  var indexName = collection.ensureIndex(index, options, future.resolver());\n  future.wait();\n};\nMongoConnection.prototype._dropIndex = function (collectionName, index) {\n  var self = this;\n\n  // This function is only used by test code, not within a method, so we don't\n  // interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var future = new Future();\n  var indexName = collection.dropIndex(index, future.resolver());\n  future.wait();\n};\n\n// CURSORS\n\n// There are several classes which relate to cursors:\n//\n// CursorDescription represents the arguments used to construct a cursor:\n// collectionName, selector, and (find) options.  Because it is used as a key\n// for cursor de-dup, everything in it should either be JSON-stringifiable or\n// not affect observeChanges output (eg, options.transform functions are not\n// stringifiable but do not affect observeChanges).\n//\n// SynchronousCursor is a wrapper around a MongoDB cursor\n// which includes fully-synchronous versions of forEach, etc.\n//\n// Cursor is the cursor object returned from find(), which implements the\n// documented Mongo.Collection cursor API.  It wraps a CursorDescription and a\n// SynchronousCursor (lazily: it doesn't contact Mongo until you call a method\n// like fetch or forEach on it).\n//\n// ObserveHandle is the \"observe handle\" returned from observeChanges. It has a\n// reference to an ObserveMultiplexer.\n//\n// ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a\n// single observe driver.\n//\n// There are two \"observe drivers\" which drive ObserveMultiplexers:\n//   - PollingObserveDriver caches the results of a query and reruns it when\n//     necessary.\n//   - OplogObserveDriver follows the Mongo operation log to directly observe\n//     database changes.\n// Both implementations follow the same simple interface: when you create them,\n// they start sending observeChanges callbacks (and a ready() invocation) to\n// their ObserveMultiplexer, and you stop them by calling their stop() method.\n\nCursorDescription = function (collectionName, selector, options) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.selector = Mongo.Collection._rewriteSelector(selector);\n  self.options = options || {};\n};\n\nCursor = function (mongo, cursorDescription) {\n  var self = this;\n\n  self._mongo = mongo;\n  self._cursorDescription = cursorDescription;\n  self._synchronousCursor = null;\n};\n\n_.each(['forEach', 'map', 'fetch', 'count'], function (method) {\n  Cursor.prototype[method] = function () {\n    var self = this;\n\n    // You can only observe a tailable cursor.\n    if (self._cursorDescription.options.tailable) throw new Error(\"Cannot call \" + method + \" on a tailable cursor\");\n\n    if (!self._synchronousCursor) {\n      self._synchronousCursor = self._mongo._createSynchronousCursor(self._cursorDescription, {\n        // Make sure that the \"self\" argument to forEach/map callbacks is the\n        // Cursor, not the SynchronousCursor.\n        selfForIteration: self,\n        useTransform: true\n      });\n    }\n\n    return self._synchronousCursor[method].apply(self._synchronousCursor, arguments);\n  };\n});\n\n// Since we don't actually have a \"nextObject\" interface, there's really no\n// reason to have a \"rewind\" interface.  All it did was make multiple calls\n// to fetch/map/forEach return nothing the second time.\n// XXX COMPAT WITH 0.8.1\nCursor.prototype.rewind = function () {};\n\nCursor.prototype.getTransform = function () {\n  return this._cursorDescription.options.transform;\n};\n\n// When you call Meteor.publish() with a function that returns a Cursor, we need\n// to transmute it into the equivalent subscription.  This is the function that\n// does that.\n\nCursor.prototype._publishCursor = function (sub) {\n  var self = this;\n  var collection = self._cursorDescription.collectionName;\n  return Mongo.Collection._publishCursor(self, sub, collection);\n};\n\n// Used to guarantee that publish functions return at most one cursor per\n// collection. Private, because we might later have cursors that include\n// documents from multiple collections somehow.\nCursor.prototype._getCollectionName = function () {\n  var self = this;\n  return self._cursorDescription.collectionName;\n};\n\nCursor.prototype.observe = function (callbacks) {\n  var self = this;\n  return LocalCollection._observeFromObserveChanges(self, callbacks);\n};\n\nCursor.prototype.observeChanges = function (callbacks) {\n  var self = this;\n  var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks);\n  return self._mongo._observeChanges(self._cursorDescription, ordered, callbacks);\n};\n\nMongoConnection.prototype._createSynchronousCursor = function (cursorDescription, options) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n\n  var collection = self.rawCollection(cursorDescription.collectionName);\n  var cursorOptions = cursorDescription.options;\n  var mongoOptions = {\n    sort: cursorOptions.sort,\n    limit: cursorOptions.limit,\n    skip: cursorOptions.skip\n  };\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    // We want a tailable cursor...\n    mongoOptions.tailable = true;\n    // ... and for the server to wait a bit if any getMore has no data (rather\n    // than making us put the relevant sleeps in the client)...\n    mongoOptions.awaitdata = true;\n    // ... and to keep querying the server indefinitely rather than just 5 times\n    // if there's no more data.\n    mongoOptions.numberOfRetries = -1;\n    // And if this is on the oplog collection and the cursor specifies a 'ts',\n    // then set the undocumented oplog replay flag, which does a special scan to\n    // find the first document (instead of creating an index on ts). This is a\n    // very hard-coded Mongo flag which only works on the oplog collection and\n    // only works with the ts field.\n    if (cursorDescription.collectionName === OPLOG_COLLECTION && cursorDescription.selector.ts) {\n      mongoOptions.oplogReplay = true;\n    }\n  }\n\n  var dbCursor = collection.find(replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo), cursorOptions.fields, mongoOptions);\n\n  return new SynchronousCursor(dbCursor, cursorDescription, options);\n};\n\nvar SynchronousCursor = function (dbCursor, cursorDescription, options) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n\n  self._dbCursor = dbCursor;\n  self._cursorDescription = cursorDescription;\n  // The \"self\" argument passed to forEach/map callbacks. If we're wrapped\n  // inside a user-visible Cursor, we want to provide the outer cursor!\n  self._selfForIteration = options.selfForIteration || self;\n  if (options.useTransform && cursorDescription.options.transform) {\n    self._transform = LocalCollection.wrapTransform(cursorDescription.options.transform);\n  } else {\n    self._transform = null;\n  }\n\n  // Need to specify that the callback is the first argument to nextObject,\n  // since otherwise when we try to call it with no args the driver will\n  // interpret \"undefined\" first arg as an options hash and crash.\n  self._synchronousNextObject = Future.wrap(dbCursor.nextObject.bind(dbCursor), 0);\n  self._synchronousCount = Future.wrap(dbCursor.count.bind(dbCursor));\n  self._visitedIds = new LocalCollection._IdMap();\n};\n\n_.extend(SynchronousCursor.prototype, {\n  _nextObject: function () {\n    var self = this;\n\n    while (true) {\n      var doc = self._synchronousNextObject().wait();\n\n      if (!doc) return null;\n      doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n\n      if (!self._cursorDescription.options.tailable && _.has(doc, '_id')) {\n        // Did Mongo give us duplicate documents in the same cursor? If so,\n        // ignore this one. (Do this before the transform, since transform might\n        // return some unrelated value.) We don't do this for tailable cursors,\n        // because we want to maintain O(1) memory usage. And if there isn't _id\n        // for some reason (maybe it's the oplog), then we don't do this either.\n        // (Be careful to do this for falsey but existing _id, though.)\n        if (self._visitedIds.has(doc._id)) continue;\n        self._visitedIds.set(doc._id, true);\n      }\n\n      if (self._transform) doc = self._transform(doc);\n\n      return doc;\n    }\n  },\n\n  forEach: function (callback, thisArg) {\n    var self = this;\n\n    // Get back to the beginning.\n    self._rewind();\n\n    // We implement the loop ourself instead of using self._dbCursor.each,\n    // because \"each\" will call its callback outside of a fiber which makes it\n    // much more complex to make this function synchronous.\n    var index = 0;\n    while (true) {\n      var doc = self._nextObject();\n      if (!doc) return;\n      callback.call(thisArg, doc, index++, self._selfForIteration);\n    }\n  },\n\n  // XXX Allow overlapping callback executions if callback yields.\n  map: function (callback, thisArg) {\n    var self = this;\n    var res = [];\n    self.forEach(function (doc, index) {\n      res.push(callback.call(thisArg, doc, index, self._selfForIteration));\n    });\n    return res;\n  },\n\n  _rewind: function () {\n    var self = this;\n\n    // known to be synchronous\n    self._dbCursor.rewind();\n\n    self._visitedIds = new LocalCollection._IdMap();\n  },\n\n  // Mostly usable for tailable cursors.\n  close: function () {\n    var self = this;\n\n    self._dbCursor.close();\n  },\n\n  fetch: function () {\n    var self = this;\n    return self.map(_.identity);\n  },\n\n  count: function () {\n    var self = this;\n    return self._synchronousCount().wait();\n  },\n\n  // This method is NOT wrapped in Cursor.\n  getRawObjects: function (ordered) {\n    var self = this;\n    if (ordered) {\n      return self.fetch();\n    } else {\n      var results = new LocalCollection._IdMap();\n      self.forEach(function (doc) {\n        results.set(doc._id, doc);\n      });\n      return results;\n    }\n  }\n});\n\nMongoConnection.prototype.tail = function (cursorDescription, docCallback) {\n  var self = this;\n  if (!cursorDescription.options.tailable) throw new Error(\"Can only tail a tailable cursor\");\n\n  var cursor = self._createSynchronousCursor(cursorDescription);\n\n  var stopped = false;\n  var lastTS = undefined;\n  var loop = function () {\n    while (true) {\n      if (stopped) return;\n      try {\n        var doc = cursor._nextObject();\n      } catch (err) {\n        // There's no good way to figure out if this was actually an error\n        // from Mongo. Ah well. But either way, we need to retry the cursor\n        // (unless the failure was because the observe got stopped).\n        doc = null;\n      }\n      // Since cursor._nextObject can yield, we need to check again to see if\n      // we've been stopped before calling the callback.\n      if (stopped) return;\n      if (doc) {\n        // If a tailable cursor contains a \"ts\" field, use it to recreate the\n        // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n        // the oplog, and there's a special flag that lets you do binary search\n        // on it instead of needing to use an index.)\n        lastTS = doc.ts;\n        docCallback(doc);\n      } else {\n        var newSelector = _.clone(cursorDescription.selector);\n        if (lastTS) {\n          newSelector.ts = { $gt: lastTS };\n        }\n        cursor = self._createSynchronousCursor(new CursorDescription(cursorDescription.collectionName, newSelector, cursorDescription.options));\n        // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n        // setTimeout, we peg the CPU at 100% and never notice the actual\n        // failover.\n        Meteor.setTimeout(loop, 100);\n        break;\n      }\n    }\n  };\n\n  Meteor.defer(loop);\n\n  return {\n    stop: function () {\n      stopped = true;\n      cursor.close();\n    }\n  };\n};\n\nMongoConnection.prototype._observeChanges = function (cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  if (cursorDescription.options.tailable) {\n    return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n  }\n\n  // You may not filter out _id when observing changes, because the id is a core\n  // part of the observeChanges API.\n  if (cursorDescription.options.fields && (cursorDescription.options.fields._id === 0 || cursorDescription.options.fields._id === false)) {\n    throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n  }\n\n  var observeKey = JSON.stringify(_.extend({ ordered: ordered }, cursorDescription));\n\n  var multiplexer, observeDriver;\n  var firstHandle = false;\n\n  // Find a matching ObserveMultiplexer, or create a new one. This next block is\n  // guaranteed to not yield (and it doesn't call anything that can observe a\n  // new query), so no other calls to this function can interleave with it.\n  Meteor._noYieldsAllowed(function () {\n    if (_.has(self._observeMultiplexers, observeKey)) {\n      multiplexer = self._observeMultiplexers[observeKey];\n    } else {\n      firstHandle = true;\n      // Create a new ObserveMultiplexer.\n      multiplexer = new ObserveMultiplexer({\n        ordered: ordered,\n        onStop: function () {\n          delete self._observeMultiplexers[observeKey];\n          observeDriver.stop();\n        }\n      });\n      self._observeMultiplexers[observeKey] = multiplexer;\n    }\n  });\n\n  var observeHandle = new ObserveHandle(multiplexer, callbacks);\n\n  if (firstHandle) {\n    var matcher, sorter;\n    var canUseOplog = _.all([function () {\n      // At a bare minimum, using the oplog requires us to have an oplog, to\n      // want unordered callbacks, and to not want a callback on the polls\n      // that won't happen.\n      return self._oplogHandle && !ordered && !callbacks._testOnlyPollCallback;\n    }, function () {\n      // We need to be able to compile the selector. Fall back to polling for\n      // some newfangled $selector that minimongo doesn't support yet.\n      try {\n        matcher = new Minimongo.Matcher(cursorDescription.selector);\n        return true;\n      } catch (e) {\n        // XXX make all compilation errors MinimongoError or something\n        //     so that this doesn't ignore unrelated exceptions\n        return false;\n      }\n    }, function () {\n      // ... and the selector itself needs to support oplog.\n      return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n    }, function () {\n      // And we need to be able to compile the sort, if any.  eg, can't be\n      // {$natural: 1}.\n      if (!cursorDescription.options.sort) return true;\n      try {\n        sorter = new Minimongo.Sorter(cursorDescription.options.sort, { matcher: matcher });\n        return true;\n      } catch (e) {\n        // XXX make all compilation errors MinimongoError or something\n        //     so that this doesn't ignore unrelated exceptions\n        return false;\n      }\n    }], function (f) {\n      return f();\n    }); // invoke each function\n\n    var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n    observeDriver = new driverClass({\n      cursorDescription: cursorDescription,\n      mongoHandle: self,\n      multiplexer: multiplexer,\n      ordered: ordered,\n      matcher: matcher, // ignored by polling\n      sorter: sorter, // ignored by polling\n      _testOnlyPollCallback: callbacks._testOnlyPollCallback\n    });\n\n    // This field is only set for use in tests.\n    multiplexer._observeDriver = observeDriver;\n  }\n\n  // Blocks until the initial adds have been sent.\n  multiplexer.addHandleAndSendInitialAdds(observeHandle);\n\n  return observeHandle;\n};\n\n// Listen for the invalidation messages that will trigger us to poll the\n// database for changes. If this selector specifies specific IDs, specify them\n// here, so that updates to different specific IDs don't cause us to poll.\n// listenCallback is the same kind of (notification, complete) callback passed\n// to InvalidationCrossbar.listen.\n\nlistenAll = function (cursorDescription, listenCallback) {\n  var listeners = [];\n  forEachTrigger(cursorDescription, function (trigger) {\n    listeners.push(DDPServer._InvalidationCrossbar.listen(trigger, listenCallback));\n  });\n\n  return {\n    stop: function () {\n      _.each(listeners, function (listener) {\n        listener.stop();\n      });\n    }\n  };\n};\n\nforEachTrigger = function (cursorDescription, triggerCallback) {\n  var key = { collection: cursorDescription.collectionName };\n  var specificIds = LocalCollection._idsMatchedBySelector(cursorDescription.selector);\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      triggerCallback(_.extend({ id: id }, key));\n    });\n    triggerCallback(_.extend({ dropCollection: true, id: null }, key));\n  } else {\n    triggerCallback(key);\n  }\n  // Everyone cares about the database being dropped.\n  triggerCallback({ dropDatabase: true });\n};\n\n// observeChanges for tailable cursors on capped collections.\n//\n// Some differences from normal cursors:\n//   - Will never produce anything other than 'added' or 'addedBefore'. If you\n//     do update a document that has already been produced, this will not notice\n//     it.\n//   - If you disconnect and reconnect from Mongo, it will essentially restart\n//     the query, which will lead to duplicate results. This is pretty bad,\n//     but if you include a field called 'ts' which is inserted as\n//     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n//     current Mongo-style timestamp), we'll be able to find the place to\n//     restart properly. (This field is specifically understood by Mongo with an\n//     optimization which allows it to find the right place to start without\n//     an index on ts. It's how the oplog works.)\n//   - No callbacks are triggered synchronously with the call (there's no\n//     differentiation between \"initial data\" and \"later changes\"; everything\n//     that matches the query gets sent asynchronously).\n//   - De-duplication is not implemented.\n//   - Does not yet interact with the write fence. Probably, this should work by\n//     ignoring removes (which don't work on capped collections) and updates\n//     (which don't affect tailable cursors), and just keeping track of the ID\n//     of the inserted object, and closing the write fence once you get to that\n//     ID (or timestamp?).  This doesn't work well if the document doesn't match\n//     the query, though.  On the other hand, the write fence can close\n//     immediately if it does not match the query. So if we trust minimongo\n//     enough to accurately evaluate the query against the write fence, we\n//     should be able to do this...  Of course, minimongo doesn't even support\n//     Mongo Timestamps yet.\nMongoConnection.prototype._observeChangesTailable = function (cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n  // error if you didn't provide them.\n  if (ordered && !callbacks.addedBefore || !ordered && !callbacks.added) {\n    throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\") + \" tailable cursor without a \" + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n  }\n\n  return self.tail(cursorDescription, function (doc) {\n    var id = doc._id;\n    delete doc._id;\n    // The ts is an implementation detail. Hide it.\n    delete doc.ts;\n    if (ordered) {\n      callbacks.addedBefore(id, doc, null);\n    } else {\n      callbacks.added(id, doc);\n    }\n  });\n};\n\n// XXX We probably need to find a better way to expose this. Right now\n// it's only used by tests, but in fact you need it in normal\n// operation to interact with capped collections.\nMongoInternals.MongoTimestamp = MongoDB.Timestamp;\n\nMongoInternals.Connection = MongoConnection;\n// bindEnvironmentForWrite.","ast":null,"map":{"version":3,"sources":["/packages/mongo/mongo_driver.js"],"names":[],"mappings":"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","file":"/packages/mongo/mongo_driver.js.map","sourcesContent":["/**\n * Provide a synchronous Collection API using fibers, backed by\n * MongoDB.  This is only for use on the server, and mostly identical\n * to the client API.\n *\n * NOTE: the public API methods must be run within a fiber. If you call\n * these outside of a fiber they will explode!\n */\n\nvar path = Npm.require('path');\nvar MongoDB = NpmModuleMongodb;\nvar Fiber = Npm.require('fibers');\nvar Future = Npm.require(path.join('fibers', 'future'));\n\nMongoInternals = {};\nMongoTest = {};\n\nMongoInternals.NpmModules = {\n  mongodb: {\n    version: NpmModuleMongodbVersion,\n    module: MongoDB\n  }\n};\n\n// Older version of what is now available via\n// MongoInternals.NpmModules.mongodb.module.  It was never documented, but\n// people do use it.\n// XXX COMPAT WITH 1.0.3.2\nMongoInternals.NpmModule = MongoDB;\n\n// This is used to add or remove EJSON from the beginning of everything nested\n// inside an EJSON custom type. It should only be called on pure JSON!\nvar replaceNames = function (filter, thing) {\n  if (typeof thing === \"object\") {\n    if (_.isArray(thing)) {\n      return _.map(thing, _.bind(replaceNames, null, filter));\n    }\n    var ret = {};\n    _.each(thing, function (value, key) {\n      ret[filter(key)] = replaceNames(filter, value);\n    });\n    return ret;\n  }\n  return thing;\n};\n\n// Ensure that EJSON.clone keeps a Timestamp as a Timestamp (instead of just\n// doing a structural clone).\n// XXX how ok is this? what if there are multiple copies of MongoDB loaded?\nMongoDB.Timestamp.prototype.clone = function () {\n  // Timestamps should be immutable.\n  return this;\n};\n\nvar makeMongoLegal = function (name) { return \"EJSON\" + name; };\nvar unmakeMongoLegal = function (name) { return name.substr(5); };\n\nvar replaceMongoAtomWithMeteor = function (document) {\n  if (document instanceof MongoDB.Binary) {\n    var buffer = document.value(true);\n    return new Uint8Array(buffer);\n  }\n  if (document instanceof MongoDB.ObjectID) {\n    return new Mongo.ObjectID(document.toHexString());\n  }\n  if (document[\"EJSON$type\"] && document[\"EJSON$value\"]\n      && _.size(document) === 2) {\n    return EJSON.fromJSONValue(replaceNames(unmakeMongoLegal, document));\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  return undefined;\n};\n\nvar replaceMeteorAtomWithMongo = function (document) {\n  if (EJSON.isBinary(document)) {\n    // This does more copies than we'd like, but is necessary because\n    // MongoDB.BSON only looks like it takes a Uint8Array (and doesn't actually\n    // serialize it correctly).\n    return new MongoDB.Binary(new Buffer(document));\n  }\n  if (document instanceof Mongo.ObjectID) {\n    return new MongoDB.ObjectID(document.toHexString());\n  }\n  if (document instanceof MongoDB.Timestamp) {\n    // For now, the Meteor representation of a Mongo timestamp type (not a date!\n    // this is a weird internal thing used in the oplog!) is the same as the\n    // Mongo representation. We need to do this explicitly or else we would do a\n    // structural clone and lose the prototype.\n    return document;\n  }\n  if (EJSON._isCustomType(document)) {\n    return replaceNames(makeMongoLegal, EJSON.toJSONValue(document));\n  }\n  // It is not ordinarily possible to stick dollar-sign keys into mongo\n  // so we don't bother checking for things that need escaping at this time.\n  return undefined;\n};\n\nvar replaceTypes = function (document, atomTransformer) {\n  if (typeof document !== 'object' || document === null)\n    return document;\n\n  var replacedTopLevelAtom = atomTransformer(document);\n  if (replacedTopLevelAtom !== undefined)\n    return replacedTopLevelAtom;\n\n  var ret = document;\n  _.each(document, function (val, key) {\n    var valReplaced = replaceTypes(val, atomTransformer);\n    if (val !== valReplaced) {\n      // Lazy clone. Shallow copy.\n      if (ret === document)\n        ret = _.clone(document);\n      ret[key] = valReplaced;\n    }\n  });\n  return ret;\n};\n\n\nMongoConnection = function (url, options) {\n  var self = this;\n  options = options || {};\n  self._observeMultiplexers = {};\n  self._onFailoverHook = new Hook;\n\n  var mongoOptions = {db: {safe: true}, server: {}, replSet: {}};\n\n  // Set autoReconnect to true, unless passed on the URL. Why someone\n  // would want to set autoReconnect to false, I'm not really sure, but\n  // keeping this for backwards compatibility for now.\n  if (!(/[\\?&]auto_?[rR]econnect=/.test(url))) {\n    mongoOptions.server.auto_reconnect = true;\n  }\n\n  // Disable the native parser by default, unless specifically enabled\n  // in the mongo URL.\n  // - The native driver can cause errors which normally would be\n  //   thrown, caught, and handled into segfaults that take down the\n  //   whole app.\n  // - Binary modules don't yet work when you bundle and move the bundle\n  //   to a different platform (aka deploy)\n  // We should revisit this after binary npm module support lands.\n  if (!(/[\\?&]native_?[pP]arser=/.test(url))) {\n    mongoOptions.db.native_parser = false;\n  }\n\n  // XXX maybe we should have a better way of allowing users to configure the\n  // underlying Mongo driver\n  if (_.has(options, 'poolSize')) {\n    // If we just set this for \"server\", replSet will override it. If we just\n    // set it for replSet, it will be ignored if we're not using a replSet.\n    mongoOptions.server.poolSize = options.poolSize;\n    mongoOptions.replSet.poolSize = options.poolSize;\n  }\n\n  self.db = null;\n  // We keep track of the ReplSet's primary, so that we can trigger hooks when\n  // it changes.  The Node driver's joined callback seems to fire way too\n  // often, which is why we need to track it ourselves.\n  self._primary = null;\n  self._oplogHandle = null;\n  self._docFetcher = null;\n\n\n  var connectFuture = new Future;\n  MongoDB.connect(\n    url,\n    mongoOptions,\n    Meteor.bindEnvironment(\n      function (err, db) {\n        if (err) {\n          throw err;\n        }\n\n        // First, figure out what the current primary is, if any.\n        if (db.serverConfig._state.master)\n          self._primary = db.serverConfig._state.master.name;\n        db.serverConfig.on(\n          'joined', Meteor.bindEnvironment(function (kind, doc) {\n            if (kind === 'primary') {\n              if (doc.primary !== self._primary) {\n                self._primary = doc.primary;\n                self._onFailoverHook.each(function (callback) {\n                  callback();\n                  return true;\n                });\n              }\n            } else if (doc.me === self._primary) {\n              // The thing we thought was primary is now something other than\n              // primary.  Forget that we thought it was primary.  (This means\n              // that if a server stops being primary and then starts being\n              // primary again without another server becoming primary in the\n              // middle, we'll correctly count it as a failover.)\n              self._primary = null;\n            }\n          }));\n\n        // Allow the constructor to return.\n        connectFuture['return'](db);\n      },\n      connectFuture.resolver()  // onException\n    )\n  );\n\n  // Wait for the connection to be successful; throws on failure.\n  self.db = connectFuture.wait();\n\n  if (options.oplogUrl && ! Package['disable-oplog']) {\n    self._oplogHandle = new OplogHandle(options.oplogUrl, self.db.databaseName);\n    self._docFetcher = new DocFetcher(self);\n  }\n};\n\nMongoConnection.prototype.close = function() {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"close called before Connection created?\");\n\n  // XXX probably untested\n  var oplogHandle = self._oplogHandle;\n  self._oplogHandle = null;\n  if (oplogHandle)\n    oplogHandle.stop();\n\n  // Use Future.wrap so that errors get thrown. This happens to\n  // work even outside a fiber since the 'close' method is not\n  // actually asynchronous.\n  Future.wrap(_.bind(self.db.close, self.db))(true).wait();\n};\n\n// Returns the Mongo Collection object; may yield.\nMongoConnection.prototype.rawCollection = function (collectionName) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"rawCollection called before Connection created?\");\n\n  var future = new Future;\n  self.db.collection(collectionName, future.resolver());\n  return future.wait();\n};\n\nMongoConnection.prototype._createCappedCollection = function (\n    collectionName, byteSize, maxDocuments) {\n  var self = this;\n\n  if (! self.db)\n    throw Error(\"_createCappedCollection called before Connection created?\");\n\n  var future = new Future();\n  self.db.createCollection(\n    collectionName,\n    { capped: true, size: byteSize, max: maxDocuments },\n    future.resolver());\n  future.wait();\n};\n\n// This should be called synchronously with a write, to create a\n// transaction on the current write fence, if any. After we can read\n// the write, and after observers have been notified (or at least,\n// after the observer notifiers have added themselves to the write\n// fence), you should call 'committed()' on the object returned.\nMongoConnection.prototype._maybeBeginWrite = function () {\n  var self = this;\n  var fence = DDPServer._CurrentWriteFence.get();\n  if (fence)\n    return fence.beginWrite();\n  else\n    return {committed: function () {}};\n};\n\n// Internal interface: adds a callback which is called when the Mongo primary\n// changes. Returns a stop handle.\nMongoConnection.prototype._onFailover = function (callback) {\n  return this._onFailoverHook.register(callback);\n};\n\n\n//////////// Public API //////////\n\n// The write methods block until the database has confirmed the write (it may\n// not be replicated or stable on disk, but one server has confirmed it) if no\n// callback is provided. If a callback is provided, then they call the callback\n// when the write is confirmed. They return nothing on success, and raise an\n// exception on failure.\n//\n// After making a write (with insert, update, remove), observers are\n// notified asynchronously. If you want to receive a callback once all\n// of the observer notifications have landed for your write, do the\n// writes inside a write fence (set DDPServer._CurrentWriteFence to a new\n// _WriteFence, and then set a callback on the write fence.)\n//\n// Since our execution environment is single-threaded, this is\n// well-defined -- a write \"has been made\" if it's returned, and an\n// observer \"has been notified\" if its callback has returned.\n\nvar writeCallback = function (write, refresh, callback) {\n  return function (err, result) {\n    if (! err) {\n      // XXX We don't have to run this on error, right?\n      try {\n        refresh();\n      } catch (refreshErr) {\n        if (callback) {\n          callback(refreshErr);\n          return;\n        } else {\n          throw refreshErr;\n        }\n      }\n    }\n    write.committed();\n    if (callback)\n      callback(err, result);\n    else if (err)\n      throw err;\n  };\n};\n\nvar bindEnvironmentForWrite = function (callback) {\n  return Meteor.bindEnvironment(callback, \"Mongo write\");\n};\n\nMongoConnection.prototype._insert = function (collection_name, document,\n                                              callback) {\n  var self = this;\n\n  var sendError = function (e) {\n    if (callback)\n      return callback(e);\n    throw e;\n  };\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n    sendError(e);\n    return;\n  }\n\n  if (!(LocalCollection._isPlainObject(document) &&\n        !EJSON._isCustomType(document))) {\n    sendError(new Error(\n      \"Only plain objects may be inserted into MongoDB\"));\n    return;\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({collection: collection_name, id: document._id });\n  };\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n  try {\n    var collection = self.rawCollection(collection_name);\n    collection.insert(replaceTypes(document, replaceMeteorAtomWithMongo),\n                      {safe: true}, callback);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\n// Cause queries that may be affected by the selector to poll in this write\n// fence.\nMongoConnection.prototype._refresh = function (collectionName, selector) {\n  var self = this;\n  var refreshKey = {collection: collectionName};\n  // If we know which documents we're removing, don't poll queries that are\n  // specific to other documents. (Note that multiple notifications here should\n  // not cause multiple polls, since all our listener is doing is enqueueing a\n  // poll.)\n  var specificIds = LocalCollection._idsMatchedBySelector(selector);\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      Meteor.refresh(_.extend({id: id}, refreshKey));\n    });\n  } else {\n    Meteor.refresh(refreshKey);\n  }\n};\n\nMongoConnection.prototype._remove = function (collection_name, selector,\n                                              callback) {\n  var self = this;\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n    if (callback)\n      return callback(e);\n    else\n      throw e;\n  }\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n  callback = bindEnvironmentForWrite(writeCallback(write, refresh, callback));\n\n  try {\n    var collection = self.rawCollection(collection_name);\n    collection.remove(replaceTypes(selector, replaceMeteorAtomWithMongo),\n                      {safe: true}, callback);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nMongoConnection.prototype._dropCollection = function (collectionName, cb) {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({collection: collectionName, id: null,\n                    dropCollection: true});\n  };\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    var collection = self.rawCollection(collectionName);\n    collection.drop(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\n// For testing only.  Slightly better than `c.rawDatabase().dropDatabase()`\n// because it lets the test's fence wait for it to be complete.\nMongoConnection.prototype._dropDatabase = function (cb) {\n  var self = this;\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    Meteor.refresh({ dropDatabase: true });\n  };\n  cb = bindEnvironmentForWrite(writeCallback(write, refresh, cb));\n\n  try {\n    self.db.dropDatabase(cb);\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nMongoConnection.prototype._update = function (collection_name, selector, mod,\n                                              options, callback) {\n  var self = this;\n\n  if (! callback && options instanceof Function) {\n    callback = options;\n    options = null;\n  }\n\n  if (collection_name === \"___meteor_failure_test_collection\") {\n    var e = new Error(\"Failure test\");\n    e.expected = true;\n    if (callback)\n      return callback(e);\n    else\n      throw e;\n  }\n\n  // explicit safety check. null and undefined can crash the mongo\n  // driver. Although the node driver and minimongo do 'support'\n  // non-object modifier in that they don't crash, they are not\n  // meaningful operations and do not do anything. Defensively throw an\n  // error here.\n  if (!mod || typeof mod !== 'object')\n    throw new Error(\"Invalid modifier. Modifier must be an object.\");\n\n  if (!(LocalCollection._isPlainObject(mod) &&\n        !EJSON._isCustomType(mod))) {\n    throw new Error(\n      \"Only plain objects may be used as replacement\" +\n        \" documents in MongoDB\");\n    return;\n  }\n\n  if (!options) options = {};\n\n  var write = self._maybeBeginWrite();\n  var refresh = function () {\n    self._refresh(collection_name, selector);\n  };\n  callback = writeCallback(write, refresh, callback);\n  try {\n    var collection = self.rawCollection(collection_name);\n    var mongoOpts = {safe: true};\n    // explictly enumerate options that minimongo supports\n    if (options.upsert) mongoOpts.upsert = true;\n    if (options.multi) mongoOpts.multi = true;\n    // Lets you get a more more full result from MongoDB. Use with caution:\n    // might not work with C.upsert (as opposed to C.update({upsert:true}) or\n    // with simulated upsert.\n    if (options.fullResult) mongoOpts.fullResult = true;\n\n    var mongoSelector = replaceTypes(selector, replaceMeteorAtomWithMongo);\n    var mongoMod = replaceTypes(mod, replaceMeteorAtomWithMongo);\n\n    var isModify = isModificationMod(mongoMod);\n    var knownId = selector._id || mod._id;\n\n    if (options._forbidReplace && ! isModify) {\n      var e = new Error(\"Invalid modifier. Replacements are forbidden.\");\n      if (callback) {\n        return callback(e);\n      } else {\n        throw e;\n      }\n    }\n\n    if (options.upsert && (! knownId) && options.insertedId) {\n      // XXX If we know we're using Mongo 2.6 (and this isn't a replacement)\n      //     we should be able to just use $setOnInsert instead of this\n      //     simulated upsert thing. (We can't use $setOnInsert with\n      //     replacements because there's nowhere to write it, and $setOnInsert\n      //     can't set _id on Mongo 2.4.)\n      //\n      //     Also, in the future we could do a real upsert for the mongo id\n      //     generation case, if the the node mongo driver gives us back the id\n      //     of the upserted doc (which our current version does not).\n      //\n      //     For more context, see\n      //     https://github.com/meteor/meteor/issues/2278#issuecomment-64252706\n      simulateUpsertWithInsertedId(\n        collection, mongoSelector, mongoMod,\n        isModify, options,\n        // This callback does not need to be bindEnvironment'ed because\n        // simulateUpsertWithInsertedId() wraps it and then passes it through\n        // bindEnvironmentForWrite.\n        function (err, result) {\n          // If we got here via a upsert() call, then options._returnObject will\n          // be set and we should return the whole object. Otherwise, we should\n          // just return the number of affected docs to match the mongo API.\n          if (result && ! options._returnObject)\n            callback(err, result.numberAffected);\n          else\n            callback(err, result);\n        }\n      );\n    } else {\n      collection.update(\n        mongoSelector, mongoMod, mongoOpts,\n        bindEnvironmentForWrite(function (err, result, extra) {\n          if (! err) {\n            if (result && options._returnObject) {\n              result = { numberAffected: result };\n              // If this was an upsert() call, and we ended up\n              // inserting a new doc and we know its id, then\n              // return that id as well.\n              if (options.upsert && knownId &&\n                  ! extra.updatedExisting)\n                result.insertedId = knownId;\n            }\n          }\n          callback(err, result);\n        }));\n    }\n  } catch (e) {\n    write.committed();\n    throw e;\n  }\n};\n\nvar isModificationMod = function (mod) {\n  var isReplace = false;\n  var isModify = false;\n  for (var k in mod) {\n    if (k.substr(0, 1) === '$') {\n      isModify = true;\n    } else {\n      isReplace = true;\n    }\n  }\n  if (isModify && isReplace) {\n    throw new Error(\n      \"Update parameter cannot have both modifier and non-modifier fields.\");\n  }\n  return isModify;\n};\n\nvar NUM_OPTIMISTIC_TRIES = 3;\n\n// exposed for testing\nMongoConnection._isCannotChangeIdError = function (err) {\n  // First check for what this error looked like in Mongo 2.4.  Either of these\n  // checks should work, but just to be safe...\n  if (err.code === 13596)\n    return true;\n  if (err.err.indexOf(\"cannot change _id of a document\") === 0)\n    return true;\n\n  // Now look for what it looks like in Mongo 2.6.  We don't use the error code\n  // here, because the error code we observed it producing (16837) appears to be\n  // a far more generic error code based on examining the source.\n  if (err.err.indexOf(\"The _id field cannot be changed\") === 0)\n    return true;\n\n  return false;\n};\n\nvar simulateUpsertWithInsertedId = function (collection, selector, mod,\n                                             isModify, options, callback) {\n  // STRATEGY:  First try doing a plain update.  If it affected 0 documents,\n  // then without affecting the database, we know we should probably do an\n  // insert.  We then do a *conditional* insert that will fail in the case\n  // of a race condition.  This conditional insert is actually an\n  // upsert-replace with an _id, which will never successfully update an\n  // existing document.  If this upsert fails with an error saying it\n  // couldn't change an existing _id, then we know an intervening write has\n  // caused the query to match something.  We go back to step one and repeat.\n  // Like all \"optimistic write\" schemes, we rely on the fact that it's\n  // unlikely our writes will continue to be interfered with under normal\n  // circumstances (though sufficiently heavy contention with writers\n  // disagreeing on the existence of an object will cause writes to fail\n  // in theory).\n\n  var newDoc;\n  // Run this code up front so that it fails fast if someone uses\n  // a Mongo update operator we don't support.\n  if (isModify) {\n    // We've already run replaceTypes/replaceMeteorAtomWithMongo on\n    // selector and mod.  We assume it doesn't matter, as far as\n    // the behavior of modifiers is concerned, whether `_modify`\n    // is run on EJSON or on mongo-converted EJSON.\n    var selectorDoc = LocalCollection._removeDollarOperators(selector);\n\n    newDoc = selectorDoc;\n\n    // Convert dotted keys into objects. (Resolves issue #4522).\n    _.each(newDoc, function (value, key) {\n      var trail = key.split(\".\");\n\n      if (trail.length > 1) {\n        //Key is dotted. Convert it into an object.\n        delete newDoc[key];\n\n        var obj = newDoc,\n            leaf = trail.pop();\n\n        // XXX It is not quite certain what should be done if there are clashing\n        // keys on the trail of the dotted key. For now we will just override it\n        // It wouldn't be a very sane query in the first place, but should look\n        // up what mongo does in this case.\n\n        while ((key = trail.shift())) {\n          if (typeof obj[key] !== \"object\") {\n            obj[key] = {};\n          }\n\n          obj = obj[key];\n        }\n\n        obj[leaf] = value;\n      }\n    });\n\n    LocalCollection._modify(newDoc, mod, {isInsert: true});\n  } else {\n    newDoc = mod;\n  }\n\n  var insertedId = options.insertedId; // must exist\n  var mongoOptsForUpdate = {\n    safe: true,\n    multi: options.multi\n  };\n  var mongoOptsForInsert = {\n    safe: true,\n    upsert: true\n  };\n\n  var tries = NUM_OPTIMISTIC_TRIES;\n\n  var doUpdate = function () {\n    tries--;\n    if (! tries) {\n      callback(new Error(\"Upsert failed after \" + NUM_OPTIMISTIC_TRIES + \" tries.\"));\n    } else {\n      collection.update(selector, mod, mongoOptsForUpdate,\n                        bindEnvironmentForWrite(function (err, result) {\n                          if (err)\n                            callback(err);\n                          else if (result)\n                            callback(null, {\n                              numberAffected: result\n                            });\n                          else\n                            doConditionalInsert();\n                        }));\n    }\n  };\n\n  var doConditionalInsert = function () {\n    var replacementWithId = _.extend(\n      replaceTypes({_id: insertedId}, replaceMeteorAtomWithMongo),\n      newDoc);\n    collection.update(selector, replacementWithId, mongoOptsForInsert,\n                      bindEnvironmentForWrite(function (err, result) {\n                        if (err) {\n                          // figure out if this is a\n                          // \"cannot change _id of document\" error, and\n                          // if so, try doUpdate() again, up to 3 times.\n                          if (MongoConnection._isCannotChangeIdError(err)) {\n                            doUpdate();\n                          } else {\n                            callback(err);\n                          }\n                        } else {\n                          callback(null, {\n                            numberAffected: result,\n                            insertedId: insertedId\n                          });\n                        }\n                      }));\n  };\n\n  doUpdate();\n};\n\n_.each([\"insert\", \"update\", \"remove\", \"dropCollection\", \"dropDatabase\"], function (method) {\n  MongoConnection.prototype[method] = function (/* arguments */) {\n    var self = this;\n    return Meteor.wrapAsync(self[\"_\" + method]).apply(self, arguments);\n  };\n});\n\n// XXX MongoConnection.upsert() does not return the id of the inserted document\n// unless you set it explicitly in the selector or modifier (as a replacement\n// doc).\nMongoConnection.prototype.upsert = function (collectionName, selector, mod,\n                                             options, callback) {\n  var self = this;\n  if (typeof options === \"function\" && ! callback) {\n    callback = options;\n    options = {};\n  }\n\n  return self.update(collectionName, selector, mod,\n                     _.extend({}, options, {\n                       upsert: true,\n                       _returnObject: true\n                     }), callback);\n};\n\nMongoConnection.prototype.find = function (collectionName, selector, options) {\n  var self = this;\n\n  if (arguments.length === 1)\n    selector = {};\n\n  return new Cursor(\n    self, new CursorDescription(collectionName, selector, options));\n};\n\nMongoConnection.prototype.findOne = function (collection_name, selector,\n                                              options) {\n  var self = this;\n  if (arguments.length === 1)\n    selector = {};\n\n  options = options || {};\n  options.limit = 1;\n  return self.find(collection_name, selector, options).fetch()[0];\n};\n\n// We'll actually design an index API later. For now, we just pass through to\n// Mongo's, but make it synchronous.\nMongoConnection.prototype._ensureIndex = function (collectionName, index,\n                                                   options) {\n  var self = this;\n\n  // We expect this function to be called at startup, not from within a method,\n  // so we don't interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var future = new Future;\n  var indexName = collection.ensureIndex(index, options, future.resolver());\n  future.wait();\n};\nMongoConnection.prototype._dropIndex = function (collectionName, index) {\n  var self = this;\n\n  // This function is only used by test code, not within a method, so we don't\n  // interact with the write fence.\n  var collection = self.rawCollection(collectionName);\n  var future = new Future;\n  var indexName = collection.dropIndex(index, future.resolver());\n  future.wait();\n};\n\n// CURSORS\n\n// There are several classes which relate to cursors:\n//\n// CursorDescription represents the arguments used to construct a cursor:\n// collectionName, selector, and (find) options.  Because it is used as a key\n// for cursor de-dup, everything in it should either be JSON-stringifiable or\n// not affect observeChanges output (eg, options.transform functions are not\n// stringifiable but do not affect observeChanges).\n//\n// SynchronousCursor is a wrapper around a MongoDB cursor\n// which includes fully-synchronous versions of forEach, etc.\n//\n// Cursor is the cursor object returned from find(), which implements the\n// documented Mongo.Collection cursor API.  It wraps a CursorDescription and a\n// SynchronousCursor (lazily: it doesn't contact Mongo until you call a method\n// like fetch or forEach on it).\n//\n// ObserveHandle is the \"observe handle\" returned from observeChanges. It has a\n// reference to an ObserveMultiplexer.\n//\n// ObserveMultiplexer allows multiple identical ObserveHandles to be driven by a\n// single observe driver.\n//\n// There are two \"observe drivers\" which drive ObserveMultiplexers:\n//   - PollingObserveDriver caches the results of a query and reruns it when\n//     necessary.\n//   - OplogObserveDriver follows the Mongo operation log to directly observe\n//     database changes.\n// Both implementations follow the same simple interface: when you create them,\n// they start sending observeChanges callbacks (and a ready() invocation) to\n// their ObserveMultiplexer, and you stop them by calling their stop() method.\n\nCursorDescription = function (collectionName, selector, options) {\n  var self = this;\n  self.collectionName = collectionName;\n  self.selector = Mongo.Collection._rewriteSelector(selector);\n  self.options = options || {};\n};\n\nCursor = function (mongo, cursorDescription) {\n  var self = this;\n\n  self._mongo = mongo;\n  self._cursorDescription = cursorDescription;\n  self._synchronousCursor = null;\n};\n\n_.each(['forEach', 'map', 'fetch', 'count'], function (method) {\n  Cursor.prototype[method] = function () {\n    var self = this;\n\n    // You can only observe a tailable cursor.\n    if (self._cursorDescription.options.tailable)\n      throw new Error(\"Cannot call \" + method + \" on a tailable cursor\");\n\n    if (!self._synchronousCursor) {\n      self._synchronousCursor = self._mongo._createSynchronousCursor(\n        self._cursorDescription, {\n          // Make sure that the \"self\" argument to forEach/map callbacks is the\n          // Cursor, not the SynchronousCursor.\n          selfForIteration: self,\n          useTransform: true\n        });\n    }\n\n    return self._synchronousCursor[method].apply(\n      self._synchronousCursor, arguments);\n  };\n});\n\n// Since we don't actually have a \"nextObject\" interface, there's really no\n// reason to have a \"rewind\" interface.  All it did was make multiple calls\n// to fetch/map/forEach return nothing the second time.\n// XXX COMPAT WITH 0.8.1\nCursor.prototype.rewind = function () {\n};\n\nCursor.prototype.getTransform = function () {\n  return this._cursorDescription.options.transform;\n};\n\n// When you call Meteor.publish() with a function that returns a Cursor, we need\n// to transmute it into the equivalent subscription.  This is the function that\n// does that.\n\nCursor.prototype._publishCursor = function (sub) {\n  var self = this;\n  var collection = self._cursorDescription.collectionName;\n  return Mongo.Collection._publishCursor(self, sub, collection);\n};\n\n// Used to guarantee that publish functions return at most one cursor per\n// collection. Private, because we might later have cursors that include\n// documents from multiple collections somehow.\nCursor.prototype._getCollectionName = function () {\n  var self = this;\n  return self._cursorDescription.collectionName;\n}\n\nCursor.prototype.observe = function (callbacks) {\n  var self = this;\n  return LocalCollection._observeFromObserveChanges(self, callbacks);\n};\n\nCursor.prototype.observeChanges = function (callbacks) {\n  var self = this;\n  var ordered = LocalCollection._observeChangesCallbacksAreOrdered(callbacks);\n  return self._mongo._observeChanges(\n    self._cursorDescription, ordered, callbacks);\n};\n\nMongoConnection.prototype._createSynchronousCursor = function(\n    cursorDescription, options) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n\n  var collection = self.rawCollection(cursorDescription.collectionName);\n  var cursorOptions = cursorDescription.options;\n  var mongoOptions = {\n    sort: cursorOptions.sort,\n    limit: cursorOptions.limit,\n    skip: cursorOptions.skip\n  };\n\n  // Do we want a tailable cursor (which only works on capped collections)?\n  if (cursorOptions.tailable) {\n    // We want a tailable cursor...\n    mongoOptions.tailable = true;\n    // ... and for the server to wait a bit if any getMore has no data (rather\n    // than making us put the relevant sleeps in the client)...\n    mongoOptions.awaitdata = true;\n    // ... and to keep querying the server indefinitely rather than just 5 times\n    // if there's no more data.\n    mongoOptions.numberOfRetries = -1;\n    // And if this is on the oplog collection and the cursor specifies a 'ts',\n    // then set the undocumented oplog replay flag, which does a special scan to\n    // find the first document (instead of creating an index on ts). This is a\n    // very hard-coded Mongo flag which only works on the oplog collection and\n    // only works with the ts field.\n    if (cursorDescription.collectionName === OPLOG_COLLECTION &&\n        cursorDescription.selector.ts) {\n      mongoOptions.oplogReplay = true;\n    }\n  }\n\n  var dbCursor = collection.find(\n    replaceTypes(cursorDescription.selector, replaceMeteorAtomWithMongo),\n    cursorOptions.fields, mongoOptions);\n\n  return new SynchronousCursor(dbCursor, cursorDescription, options);\n};\n\nvar SynchronousCursor = function (dbCursor, cursorDescription, options) {\n  var self = this;\n  options = _.pick(options || {}, 'selfForIteration', 'useTransform');\n\n  self._dbCursor = dbCursor;\n  self._cursorDescription = cursorDescription;\n  // The \"self\" argument passed to forEach/map callbacks. If we're wrapped\n  // inside a user-visible Cursor, we want to provide the outer cursor!\n  self._selfForIteration = options.selfForIteration || self;\n  if (options.useTransform && cursorDescription.options.transform) {\n    self._transform = LocalCollection.wrapTransform(\n      cursorDescription.options.transform);\n  } else {\n    self._transform = null;\n  }\n\n  // Need to specify that the callback is the first argument to nextObject,\n  // since otherwise when we try to call it with no args the driver will\n  // interpret \"undefined\" first arg as an options hash and crash.\n  self._synchronousNextObject = Future.wrap(\n    dbCursor.nextObject.bind(dbCursor), 0);\n  self._synchronousCount = Future.wrap(dbCursor.count.bind(dbCursor));\n  self._visitedIds = new LocalCollection._IdMap;\n};\n\n_.extend(SynchronousCursor.prototype, {\n  _nextObject: function () {\n    var self = this;\n\n    while (true) {\n      var doc = self._synchronousNextObject().wait();\n\n      if (!doc) return null;\n      doc = replaceTypes(doc, replaceMongoAtomWithMeteor);\n\n      if (!self._cursorDescription.options.tailable && _.has(doc, '_id')) {\n        // Did Mongo give us duplicate documents in the same cursor? If so,\n        // ignore this one. (Do this before the transform, since transform might\n        // return some unrelated value.) We don't do this for tailable cursors,\n        // because we want to maintain O(1) memory usage. And if there isn't _id\n        // for some reason (maybe it's the oplog), then we don't do this either.\n        // (Be careful to do this for falsey but existing _id, though.)\n        if (self._visitedIds.has(doc._id)) continue;\n        self._visitedIds.set(doc._id, true);\n      }\n\n      if (self._transform)\n        doc = self._transform(doc);\n\n      return doc;\n    }\n  },\n\n  forEach: function (callback, thisArg) {\n    var self = this;\n\n    // Get back to the beginning.\n    self._rewind();\n\n    // We implement the loop ourself instead of using self._dbCursor.each,\n    // because \"each\" will call its callback outside of a fiber which makes it\n    // much more complex to make this function synchronous.\n    var index = 0;\n    while (true) {\n      var doc = self._nextObject();\n      if (!doc) return;\n      callback.call(thisArg, doc, index++, self._selfForIteration);\n    }\n  },\n\n  // XXX Allow overlapping callback executions if callback yields.\n  map: function (callback, thisArg) {\n    var self = this;\n    var res = [];\n    self.forEach(function (doc, index) {\n      res.push(callback.call(thisArg, doc, index, self._selfForIteration));\n    });\n    return res;\n  },\n\n  _rewind: function () {\n    var self = this;\n\n    // known to be synchronous\n    self._dbCursor.rewind();\n\n    self._visitedIds = new LocalCollection._IdMap;\n  },\n\n  // Mostly usable for tailable cursors.\n  close: function () {\n    var self = this;\n\n    self._dbCursor.close();\n  },\n\n  fetch: function () {\n    var self = this;\n    return self.map(_.identity);\n  },\n\n  count: function () {\n    var self = this;\n    return self._synchronousCount().wait();\n  },\n\n  // This method is NOT wrapped in Cursor.\n  getRawObjects: function (ordered) {\n    var self = this;\n    if (ordered) {\n      return self.fetch();\n    } else {\n      var results = new LocalCollection._IdMap;\n      self.forEach(function (doc) {\n        results.set(doc._id, doc);\n      });\n      return results;\n    }\n  }\n});\n\nMongoConnection.prototype.tail = function (cursorDescription, docCallback) {\n  var self = this;\n  if (!cursorDescription.options.tailable)\n    throw new Error(\"Can only tail a tailable cursor\");\n\n  var cursor = self._createSynchronousCursor(cursorDescription);\n\n  var stopped = false;\n  var lastTS = undefined;\n  var loop = function () {\n    while (true) {\n      if (stopped)\n        return;\n      try {\n        var doc = cursor._nextObject();\n      } catch (err) {\n        // There's no good way to figure out if this was actually an error\n        // from Mongo. Ah well. But either way, we need to retry the cursor\n        // (unless the failure was because the observe got stopped).\n        doc = null;\n      }\n      // Since cursor._nextObject can yield, we need to check again to see if\n      // we've been stopped before calling the callback.\n      if (stopped)\n        return;\n      if (doc) {\n        // If a tailable cursor contains a \"ts\" field, use it to recreate the\n        // cursor on error. (\"ts\" is a standard that Mongo uses internally for\n        // the oplog, and there's a special flag that lets you do binary search\n        // on it instead of needing to use an index.)\n        lastTS = doc.ts;\n        docCallback(doc);\n      } else {\n        var newSelector = _.clone(cursorDescription.selector);\n        if (lastTS) {\n          newSelector.ts = {$gt: lastTS};\n        }\n        cursor = self._createSynchronousCursor(new CursorDescription(\n          cursorDescription.collectionName,\n          newSelector,\n          cursorDescription.options));\n        // Mongo failover takes many seconds.  Retry in a bit.  (Without this\n        // setTimeout, we peg the CPU at 100% and never notice the actual\n        // failover.\n        Meteor.setTimeout(loop, 100);\n        break;\n      }\n    }\n  };\n\n  Meteor.defer(loop);\n\n  return {\n    stop: function () {\n      stopped = true;\n      cursor.close();\n    }\n  };\n};\n\nMongoConnection.prototype._observeChanges = function (\n    cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  if (cursorDescription.options.tailable) {\n    return self._observeChangesTailable(cursorDescription, ordered, callbacks);\n  }\n\n  // You may not filter out _id when observing changes, because the id is a core\n  // part of the observeChanges API.\n  if (cursorDescription.options.fields &&\n      (cursorDescription.options.fields._id === 0 ||\n       cursorDescription.options.fields._id === false)) {\n    throw Error(\"You may not observe a cursor with {fields: {_id: 0}}\");\n  }\n\n  var observeKey = JSON.stringify(\n    _.extend({ordered: ordered}, cursorDescription));\n\n  var multiplexer, observeDriver;\n  var firstHandle = false;\n\n  // Find a matching ObserveMultiplexer, or create a new one. This next block is\n  // guaranteed to not yield (and it doesn't call anything that can observe a\n  // new query), so no other calls to this function can interleave with it.\n  Meteor._noYieldsAllowed(function () {\n    if (_.has(self._observeMultiplexers, observeKey)) {\n      multiplexer = self._observeMultiplexers[observeKey];\n    } else {\n      firstHandle = true;\n      // Create a new ObserveMultiplexer.\n      multiplexer = new ObserveMultiplexer({\n        ordered: ordered,\n        onStop: function () {\n          delete self._observeMultiplexers[observeKey];\n          observeDriver.stop();\n        }\n      });\n      self._observeMultiplexers[observeKey] = multiplexer;\n    }\n  });\n\n  var observeHandle = new ObserveHandle(multiplexer, callbacks);\n\n  if (firstHandle) {\n    var matcher, sorter;\n    var canUseOplog = _.all([\n      function () {\n        // At a bare minimum, using the oplog requires us to have an oplog, to\n        // want unordered callbacks, and to not want a callback on the polls\n        // that won't happen.\n        return self._oplogHandle && !ordered &&\n          !callbacks._testOnlyPollCallback;\n      }, function () {\n        // We need to be able to compile the selector. Fall back to polling for\n        // some newfangled $selector that minimongo doesn't support yet.\n        try {\n          matcher = new Minimongo.Matcher(cursorDescription.selector);\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }, function () {\n        // ... and the selector itself needs to support oplog.\n        return OplogObserveDriver.cursorSupported(cursorDescription, matcher);\n      }, function () {\n        // And we need to be able to compile the sort, if any.  eg, can't be\n        // {$natural: 1}.\n        if (!cursorDescription.options.sort)\n          return true;\n        try {\n          sorter = new Minimongo.Sorter(cursorDescription.options.sort,\n                                        { matcher: matcher });\n          return true;\n        } catch (e) {\n          // XXX make all compilation errors MinimongoError or something\n          //     so that this doesn't ignore unrelated exceptions\n          return false;\n        }\n      }], function (f) { return f(); });  // invoke each function\n\n    var driverClass = canUseOplog ? OplogObserveDriver : PollingObserveDriver;\n    observeDriver = new driverClass({\n      cursorDescription: cursorDescription,\n      mongoHandle: self,\n      multiplexer: multiplexer,\n      ordered: ordered,\n      matcher: matcher,  // ignored by polling\n      sorter: sorter,  // ignored by polling\n      _testOnlyPollCallback: callbacks._testOnlyPollCallback\n    });\n\n    // This field is only set for use in tests.\n    multiplexer._observeDriver = observeDriver;\n  }\n\n  // Blocks until the initial adds have been sent.\n  multiplexer.addHandleAndSendInitialAdds(observeHandle);\n\n  return observeHandle;\n};\n\n// Listen for the invalidation messages that will trigger us to poll the\n// database for changes. If this selector specifies specific IDs, specify them\n// here, so that updates to different specific IDs don't cause us to poll.\n// listenCallback is the same kind of (notification, complete) callback passed\n// to InvalidationCrossbar.listen.\n\nlistenAll = function (cursorDescription, listenCallback) {\n  var listeners = [];\n  forEachTrigger(cursorDescription, function (trigger) {\n    listeners.push(DDPServer._InvalidationCrossbar.listen(\n      trigger, listenCallback));\n  });\n\n  return {\n    stop: function () {\n      _.each(listeners, function (listener) {\n        listener.stop();\n      });\n    }\n  };\n};\n\nforEachTrigger = function (cursorDescription, triggerCallback) {\n  var key = {collection: cursorDescription.collectionName};\n  var specificIds = LocalCollection._idsMatchedBySelector(\n    cursorDescription.selector);\n  if (specificIds) {\n    _.each(specificIds, function (id) {\n      triggerCallback(_.extend({id: id}, key));\n    });\n    triggerCallback(_.extend({dropCollection: true, id: null}, key));\n  } else {\n    triggerCallback(key);\n  }\n  // Everyone cares about the database being dropped.\n  triggerCallback({ dropDatabase: true });\n};\n\n// observeChanges for tailable cursors on capped collections.\n//\n// Some differences from normal cursors:\n//   - Will never produce anything other than 'added' or 'addedBefore'. If you\n//     do update a document that has already been produced, this will not notice\n//     it.\n//   - If you disconnect and reconnect from Mongo, it will essentially restart\n//     the query, which will lead to duplicate results. This is pretty bad,\n//     but if you include a field called 'ts' which is inserted as\n//     new MongoInternals.MongoTimestamp(0, 0) (which is initialized to the\n//     current Mongo-style timestamp), we'll be able to find the place to\n//     restart properly. (This field is specifically understood by Mongo with an\n//     optimization which allows it to find the right place to start without\n//     an index on ts. It's how the oplog works.)\n//   - No callbacks are triggered synchronously with the call (there's no\n//     differentiation between \"initial data\" and \"later changes\"; everything\n//     that matches the query gets sent asynchronously).\n//   - De-duplication is not implemented.\n//   - Does not yet interact with the write fence. Probably, this should work by\n//     ignoring removes (which don't work on capped collections) and updates\n//     (which don't affect tailable cursors), and just keeping track of the ID\n//     of the inserted object, and closing the write fence once you get to that\n//     ID (or timestamp?).  This doesn't work well if the document doesn't match\n//     the query, though.  On the other hand, the write fence can close\n//     immediately if it does not match the query. So if we trust minimongo\n//     enough to accurately evaluate the query against the write fence, we\n//     should be able to do this...  Of course, minimongo doesn't even support\n//     Mongo Timestamps yet.\nMongoConnection.prototype._observeChangesTailable = function (\n    cursorDescription, ordered, callbacks) {\n  var self = this;\n\n  // Tailable cursors only ever call added/addedBefore callbacks, so it's an\n  // error if you didn't provide them.\n  if ((ordered && !callbacks.addedBefore) ||\n      (!ordered && !callbacks.added)) {\n    throw new Error(\"Can't observe an \" + (ordered ? \"ordered\" : \"unordered\")\n                    + \" tailable cursor without a \"\n                    + (ordered ? \"addedBefore\" : \"added\") + \" callback\");\n  }\n\n  return self.tail(cursorDescription, function (doc) {\n    var id = doc._id;\n    delete doc._id;\n    // The ts is an implementation detail. Hide it.\n    delete doc.ts;\n    if (ordered) {\n      callbacks.addedBefore(id, doc, null);\n    } else {\n      callbacks.added(id, doc);\n    }\n  });\n};\n\n// XXX We probably need to find a better way to expose this. Right now\n// it's only used by tests, but in fact you need it in normal\n// operation to interact with capped collections.\nMongoInternals.MongoTimestamp = MongoDB.Timestamp;\n\nMongoInternals.Connection = MongoConnection;\n"]},"hash":"c4d57557c919b594ee21f2bf2ea3c2a681d60087"}
