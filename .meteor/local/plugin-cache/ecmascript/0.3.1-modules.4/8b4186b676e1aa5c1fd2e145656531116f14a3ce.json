{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"var Fiber = Npm.require('fibers');\n\nTinytest.addAsync(\"livedata server - connectionHandle.onClose()\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // On the server side, wait for the connection to be closed.\n    serverConn.onClose(function () {\n      test.isTrue(true);\n      // Add a new onClose after the connection is already\n      // closed. See that it fires.\n      serverConn.onClose(function () {\n        onComplete();\n      });\n    });\n    // Close the connection from the client.\n    clientConn.disconnect();\n  }, onComplete);\n});\n\nTinytest.addAsync(\"livedata server - connectionHandle.close()\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // Wait for the connection to be closed from the server side.\n    simplePoll(function () {\n      return !clientConn.status().connected;\n    }, onComplete, function () {\n      test.fail(\"timeout waiting for the connection to be closed on the server side\");\n      onComplete();\n    });\n\n    // Close the connection from the server.\n    serverConn.close();\n  }, onComplete);\n});\n\ntestAsyncMulti(\"livedata server - onConnection doesn't get callback after stop.\", [function (test, expect) {\n  var afterStop = false;\n  var expectStop1 = expect();\n  var stopHandle1 = Meteor.onConnection(function (conn) {\n    stopHandle2.stop();\n    stopHandle1.stop();\n    afterStop = true;\n    // yield to the event loop for a moment to see that no other calls\n    // to listener2 are called.\n    Meteor.setTimeout(expectStop1, 10);\n  });\n  var stopHandle2 = Meteor.onConnection(function (conn) {\n    test.isFalse(afterStop);\n  });\n\n  // trigger a connection\n  var expectConnection = expect();\n  makeTestConnection(test, function (clientConn, serverConn) {\n    // Close the connection from the client.\n    clientConn.disconnect();\n    expectConnection();\n  }, expectConnection);\n}]);\n\nMeteor.methods({\n  livedata_server_test_inner: function () {\n    return this.connection.id;\n  },\n\n  livedata_server_test_outer: function () {\n    return Meteor.call('livedata_server_test_inner');\n  }\n});\n\nTinytest.addAsync(\"livedata server - connection in method invocation\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var res = clientConn.call('livedata_server_test_inner');\n    test.equal(res, serverConn.id);\n    clientConn.disconnect();\n    onComplete();\n  }, onComplete);\n});\n\nTinytest.addAsync(\"livedata server - connection in nested method invocation\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    var res = clientConn.call('livedata_server_test_outer');\n    test.equal(res, serverConn.id);\n    clientConn.disconnect();\n    onComplete();\n  }, onComplete);\n});\n\n// connectionId -> callback\nvar onSubscription = {};\n\nMeteor.publish(\"livedata_server_test_sub\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback) callback(this);\n  this.stop();\n});\n\nTinytest.addAsync(\"livedata server - connection in publish function\", function (test, onComplete) {\n  makeTestConnection(test, function (clientConn, serverConn) {\n    onSubscription[serverConn.id] = function (subscription) {\n      delete onSubscription[serverConn.id];\n      test.equal(subscription.connection.id, serverConn.id);\n      clientConn.disconnect();\n      onComplete();\n    };\n    clientConn.subscribe(\"livedata_server_test_sub\", serverConn.id);\n  });\n});\n\nMeteor.methods({\n  testResolvedPromise: function (arg) {\n    var invocation1 = DDP._CurrentInvocation.get();\n    return new Promise.resolve(arg).then(function (result) {\n      var invocation2 = DDP._CurrentInvocation.get();\n      // This equality holds because Promise callbacks are bound to the\n      // dynamic environment where .then was called.\n      if (invocation1 !== invocation2) {\n        throw new Meteor.Error(\"invocation mismatch\");\n      }\n      return result + \" after waiting\";\n    });\n  },\n\n  testRejectedPromise: function (arg) {\n    return new Promise.resolve(arg).then(function (result) {\n      throw new Meteor.Error(result + \" raised Meteor.Error\");\n    });\n  }\n});\n\nTinytest.addAsync(\"livedata server - waiting for Promise\", function (test, onComplete) {\n  return makeTestConnection(test, function (clientConn, serverConn) {\n    test.equal(clientConn.call(\"testResolvedPromise\", \"clientConn.call\"), \"clientConn.call after waiting\");\n\n    var clientCallPromise = new Promise(function (resolve, reject) {\n      return clientConn.call(\"testResolvedPromise\", \"clientConn.call with callback\", function (error, result) {\n        return error ? reject(error) : resolve(result);\n      });\n    });\n\n    var clientCallRejectedPromise = new Promise(function (resolve) {\n      clientConn.call(\"testRejectedPromise\", \"with callback\", function (error, result) {\n        return resolve(error.message);\n      });\n    });\n\n    Promise.all([clientCallPromise, clientCallRejectedPromise]).then(function (results) {\n      return test.equal(results, [\"clientConn.call with callback after waiting\", \"[with callback raised Meteor.Error]\"]);\n    }, function (error) {\n      return test.fail(error);\n    }).then(onComplete);\n  });\n});","ast":null,"map":{"version":3,"sources":["/packages/ddp-server/livedata_server_tests.js"],"names":[],"mappings":"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","file":"/packages/ddp-server/livedata_server_tests.js.map","sourcesContent":["var Fiber = Npm.require('fibers');\n\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.onClose()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // On the server side, wait for the connection to be closed.\n        serverConn.onClose(function () {\n          test.isTrue(true);\n          // Add a new onClose after the connection is already\n          // closed. See that it fires.\n          serverConn.onClose(function () {\n            onComplete();\n          });\n        });\n        // Close the connection from the client.\n        clientConn.disconnect();\n      },\n      onComplete\n    );\n  }\n);\n\nTinytest.addAsync(\n  \"livedata server - connectionHandle.close()\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Wait for the connection to be closed from the server side.\n        simplePoll(\n          function () {\n            return ! clientConn.status().connected;\n          },\n          onComplete,\n          function () {\n            test.fail(\"timeout waiting for the connection to be closed on the server side\");\n            onComplete();\n          }\n        );\n\n        // Close the connection from the server.\n        serverConn.close();\n      },\n      onComplete\n    );\n  }\n);\n\n\ntestAsyncMulti(\n  \"livedata server - onConnection doesn't get callback after stop.\",\n  [function (test, expect) {\n    var afterStop = false;\n    var expectStop1 = expect();\n    var stopHandle1 = Meteor.onConnection(function (conn) {\n      stopHandle2.stop();\n      stopHandle1.stop();\n      afterStop = true;\n      // yield to the event loop for a moment to see that no other calls\n      // to listener2 are called.\n      Meteor.setTimeout(expectStop1, 10);\n    });\n    var stopHandle2 = Meteor.onConnection(function (conn) {\n      test.isFalse(afterStop);\n    });\n\n    // trigger a connection\n    var expectConnection = expect();\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        // Close the connection from the client.\n        clientConn.disconnect();\n        expectConnection();\n      },\n      expectConnection\n    );\n  }]\n);\n\n\nMeteor.methods({\n  livedata_server_test_inner: function () {\n    return this.connection.id;\n  },\n\n  livedata_server_test_outer: function () {\n    return Meteor.call('livedata_server_test_inner');\n  }\n});\n\n\nTinytest.addAsync(\n  \"livedata server - connection in method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_inner');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\nTinytest.addAsync(\n  \"livedata server - connection in nested method invocation\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        var res = clientConn.call('livedata_server_test_outer');\n        test.equal(res, serverConn.id);\n        clientConn.disconnect();\n        onComplete();\n      },\n      onComplete\n    );\n  }\n);\n\n\n// connectionId -> callback\nvar onSubscription = {};\n\nMeteor.publish(\"livedata_server_test_sub\", function (connectionId) {\n  var callback = onSubscription[connectionId];\n  if (callback)\n    callback(this);\n  this.stop();\n});\n\n\nTinytest.addAsync(\n  \"livedata server - connection in publish function\",\n  function (test, onComplete) {\n    makeTestConnection(\n      test,\n      function (clientConn, serverConn) {\n        onSubscription[serverConn.id] = function (subscription) {\n          delete onSubscription[serverConn.id];\n          test.equal(subscription.connection.id, serverConn.id);\n          clientConn.disconnect();\n          onComplete();\n        };\n        clientConn.subscribe(\"livedata_server_test_sub\", serverConn.id);\n      }\n    );\n  }\n);\n\nMeteor.methods({\n  testResolvedPromise(arg) {\n    const invocation1 = DDP._CurrentInvocation.get();\n    return new Promise.resolve(arg).then(result => {\n      const invocation2 = DDP._CurrentInvocation.get();\n      // This equality holds because Promise callbacks are bound to the\n      // dynamic environment where .then was called.\n      if (invocation1 !== invocation2) {\n        throw new Meteor.Error(\"invocation mismatch\");\n      }\n      return result + \" after waiting\";\n    });\n  },\n\n  testRejectedPromise(arg) {\n    return new Promise.resolve(arg).then(result => {\n      throw new Meteor.Error(result + \" raised Meteor.Error\");\n    });\n  }\n});\n\nTinytest.addAsync(\n  \"livedata server - waiting for Promise\",\n  (test, onComplete) => makeTestConnection(test, (clientConn, serverConn) => {\n    test.equal(\n      clientConn.call(\"testResolvedPromise\", \"clientConn.call\"),\n      \"clientConn.call after waiting\"\n    );\n\n    const clientCallPromise = new Promise(\n      (resolve, reject) => clientConn.call(\n        \"testResolvedPromise\",\n        \"clientConn.call with callback\",\n        (error, result) => error ? reject(error) : resolve(result)\n      )\n    );\n\n    const clientCallRejectedPromise = new Promise(resolve => {\n      clientConn.call(\n        \"testRejectedPromise\",\n        \"with callback\",\n        (error, result) => resolve(error.message)\n      );\n    });\n\n    Promise.all([\n      clientCallPromise,\n      clientCallRejectedPromise,\n    ]).then(results => test.equal(results, [\n      \"clientConn.call with callback after waiting\",\n      \"[with callback raised Meteor.Error]\",\n    ]), error => test.fail(error))\n      .then(onComplete);\n  })\n);\n"]},"hash":"8b4186b676e1aa5c1fd2e145656531116f14a3ce"}
