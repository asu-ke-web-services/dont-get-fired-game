{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"var Future = Npm.require('fibers/future');\n\nObserveMultiplexer = function (options) {\n  var self = this;\n\n  if (!options || !_.has(options, 'ordered')) throw Error(\"must specified ordered\");\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", 1);\n\n  self._ordered = options.ordered;\n  self._onStop = options.onStop || function () {};\n  self._queue = new Meteor._SynchronousQueue();\n  self._handles = {};\n  self._readyFuture = new Future();\n  self._cache = new LocalCollection._CachingChangeObserver({\n    ordered: options.ordered });\n  // Number of addHandleAndSendInitialAdds tasks scheduled but not yet\n  // running. removeHandle uses this to know if it's time to call the onStop\n  // callback.\n  self._addHandleTasksScheduledButNotPerformed = 0;\n\n  _.each(self.callbackNames(), function (callbackName) {\n    self[callbackName] = function () /* ... */{\n      self._applyCallback(callbackName, _.toArray(arguments));\n    };\n  });\n};\n\n_.extend(ObserveMultiplexer.prototype, {\n  addHandleAndSendInitialAdds: function (handle) {\n    var self = this;\n\n    // Check this before calling runTask (even though runTask does the same\n    // check) so that we don't leak an ObserveMultiplexer on error by\n    // incrementing _addHandleTasksScheduledButNotPerformed and never\n    // decrementing it.\n    if (!self._queue.safeToRunTask()) throw new Error(\"Can't call observeChanges from an observe callback on the same query\");\n    ++self._addHandleTasksScheduledButNotPerformed;\n\n    Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", 1);\n\n    self._queue.runTask(function () {\n      self._handles[handle._id] = handle;\n      // Send out whatever adds we have so far (whether or not we the\n      // multiplexer is ready).\n      self._sendAdds(handle);\n      --self._addHandleTasksScheduledButNotPerformed;\n    });\n    // *outside* the task, since otherwise we'd deadlock\n    self._readyFuture.wait();\n  },\n\n  // Remove an observe handle. If it was the last observe handle, call the\n  // onStop callback; you cannot add any more observe handles after this.\n  //\n  // This is not synchronized with polls and handle additions: this means that\n  // you can safely call it from within an observe callback, but it also means\n  // that we have to be careful when we iterate over _handles.\n  removeHandle: function (id) {\n    var self = this;\n\n    // This should not be possible: you can only call removeHandle by having\n    // access to the ObserveHandle, which isn't returned to user code until the\n    // multiplex is ready.\n    if (!self._ready()) throw new Error(\"Can't remove handles until the multiplex is ready\");\n\n    delete self._handles[id];\n\n    Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-handles\", -1);\n\n    if (_.isEmpty(self._handles) && self._addHandleTasksScheduledButNotPerformed === 0) {\n      self._stop();\n    }\n  },\n  _stop: function (options) {\n    var self = this;\n    options = options || {};\n\n    // It shouldn't be possible for us to stop when all our handles still\n    // haven't been returned from observeChanges!\n    if (!self._ready() && !options.fromQueryError) throw Error(\"surprising _stop: not ready\");\n\n    // Call stop callback (which kills the underlying process which sends us\n    // callbacks and removes us from the connection's dictionary).\n    self._onStop();\n    Package.facts && Package.facts.Facts.incrementServerFact(\"mongo-livedata\", \"observe-multiplexers\", -1);\n\n    // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop\n    // callback should make our connection forget about us).\n    self._handles = null;\n  },\n\n  // Allows all addHandleAndSendInitialAdds calls to return, once all preceding\n  // adds have been processed. Does not block.\n  ready: function () {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (self._ready()) throw Error(\"can't make ObserveMultiplex ready twice!\");\n      self._readyFuture['return']();\n    });\n  },\n\n  // If trying to execute the query results in an error, call this. This is\n  // intended for permanent errors, not transient network errors that could be\n  // fixed. It should only be called before ready(), because if you called ready\n  // that meant that you managed to run the query once. It will stop this\n  // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus\n  // observeChanges calls) to throw the error.\n  queryError: function (err) {\n    var self = this;\n    self._queue.runTask(function () {\n      if (self._ready()) throw Error(\"can't claim query has an error after it worked!\");\n      self._stop({ fromQueryError: true });\n      self._readyFuture['throw'](err);\n    });\n  },\n\n  // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"\n  // and observe callbacks which came before this call have been propagated to\n  // all handles. \"ready\" must have already been called on this multiplexer.\n  onFlush: function (cb) {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (!self._ready()) throw Error(\"only call onFlush on a multiplexer that will be ready\");\n      cb();\n    });\n  },\n  callbackNames: function () {\n    var self = this;\n    if (self._ordered) return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];else return [\"added\", \"changed\", \"removed\"];\n  },\n  _ready: function () {\n    return this._readyFuture.isResolved();\n  },\n  _applyCallback: function (callbackName, args) {\n    var self = this;\n    self._queue.queueTask(function () {\n      // If we stopped in the meantime, do nothing.\n      if (!self._handles) return;\n\n      // First, apply the change to the cache.\n      // XXX We could make applyChange callbacks promise not to hang on to any\n      // state from their arguments (assuming that their supplied callbacks\n      // don't) and skip this clone. Currently 'changed' hangs on to state\n      // though.\n      self._cache.applyChange[callbackName].apply(null, EJSON.clone(args));\n\n      // If we haven't finished the initial adds, then we should only be getting\n      // adds.\n      if (!self._ready() && (callbackName !== 'added' && callbackName !== 'addedBefore')) {\n        throw new Error(\"Got \" + callbackName + \" during initial adds\");\n      }\n\n      // Now multiplex the callbacks out to all observe handles. It's OK if\n      // these calls yield; since we're inside a task, no other use of our queue\n      // can continue until these are done. (But we do have to be careful to not\n      // use a handle that got removed, because removeHandle does not use the\n      // queue; thus, we iterate over an array of keys that we control.)\n      _.each(_.keys(self._handles), function (handleId) {\n        var handle = self._handles && self._handles[handleId];\n        if (!handle) return;\n        var callback = handle['_' + callbackName];\n        // clone arguments so that callbacks can mutate their arguments\n        callback && callback.apply(null, EJSON.clone(args));\n      });\n    });\n  },\n\n  // Sends initial adds to a handle. It should only be called from within a task\n  // (the task that is processing the addHandleAndSendInitialAdds call). It\n  // synchronously invokes the handle's added or addedBefore; there's no need to\n  // flush the queue afterwards to ensure that the callbacks get out.\n  _sendAdds: function (handle) {\n    var self = this;\n    if (self._queue.safeToRunTask()) throw Error(\"_sendAdds may only be called from within a task!\");\n    var add = self._ordered ? handle._addedBefore : handle._added;\n    if (!add) return;\n    // note: docs may be an _IdMap or an OrderedDict\n    self._cache.docs.forEach(function (doc, id) {\n      if (!_.has(self._handles, handle._id)) throw Error(\"handle got removed before sending initial adds!\");\n      var fields = EJSON.clone(doc);\n      delete fields._id;\n      if (self._ordered) add(id, fields, null); // we're going in order, so add at end\n      else add(id, fields);\n    });\n  }\n});\n\nvar nextObserveHandleId = 1;\nObserveHandle = function (multiplexer, callbacks) {\n  var self = this;\n  // The end user is only supposed to call stop().  The other fields are\n  // accessible to the multiplexer, though.\n  self._multiplexer = multiplexer;\n  _.each(multiplexer.callbackNames(), function (name) {\n    if (callbacks[name]) {\n      self['_' + name] = callbacks[name];\n    } else if (name === \"addedBefore\" && callbacks.added) {\n      // Special case: if you specify \"added\" and \"movedBefore\", you get an\n      // ordered observe where for some reason you don't get ordering data on\n      // the adds.  I dunno, we wrote tests for it, there must have been a\n      // reason.\n      self._addedBefore = function (id, fields, before) {\n        callbacks.added(id, fields);\n      };\n    }\n  });\n  self._stopped = false;\n  self._id = nextObserveHandleId++;\n};\nObserveHandle.prototype.stop = function () {\n  var self = this;\n  if (self._stopped) return;\n  self._stopped = true;\n  self._multiplexer.removeHandle(self._id);\n};","ast":null,"map":{"version":3,"sources":["/packages/mongo/observe_multiplex.js"],"names":[],"mappings":"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","file":"/packages/mongo/observe_multiplex.js.map","sourcesContent":["var Future = Npm.require('fibers/future');\n\nObserveMultiplexer = function (options) {\n  var self = this;\n\n  if (!options || !_.has(options, 'ordered'))\n    throw Error(\"must specified ordered\");\n\n  Package.facts && Package.facts.Facts.incrementServerFact(\n    \"mongo-livedata\", \"observe-multiplexers\", 1);\n\n  self._ordered = options.ordered;\n  self._onStop = options.onStop || function () {};\n  self._queue = new Meteor._SynchronousQueue();\n  self._handles = {};\n  self._readyFuture = new Future;\n  self._cache = new LocalCollection._CachingChangeObserver({\n    ordered: options.ordered});\n  // Number of addHandleAndSendInitialAdds tasks scheduled but not yet\n  // running. removeHandle uses this to know if it's time to call the onStop\n  // callback.\n  self._addHandleTasksScheduledButNotPerformed = 0;\n\n  _.each(self.callbackNames(), function (callbackName) {\n    self[callbackName] = function (/* ... */) {\n      self._applyCallback(callbackName, _.toArray(arguments));\n    };\n  });\n};\n\n_.extend(ObserveMultiplexer.prototype, {\n  addHandleAndSendInitialAdds: function (handle) {\n    var self = this;\n\n    // Check this before calling runTask (even though runTask does the same\n    // check) so that we don't leak an ObserveMultiplexer on error by\n    // incrementing _addHandleTasksScheduledButNotPerformed and never\n    // decrementing it.\n    if (!self._queue.safeToRunTask())\n      throw new Error(\n        \"Can't call observeChanges from an observe callback on the same query\");\n    ++self._addHandleTasksScheduledButNotPerformed;\n\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-handles\", 1);\n\n    self._queue.runTask(function () {\n      self._handles[handle._id] = handle;\n      // Send out whatever adds we have so far (whether or not we the\n      // multiplexer is ready).\n      self._sendAdds(handle);\n      --self._addHandleTasksScheduledButNotPerformed;\n    });\n    // *outside* the task, since otherwise we'd deadlock\n    self._readyFuture.wait();\n  },\n\n  // Remove an observe handle. If it was the last observe handle, call the\n  // onStop callback; you cannot add any more observe handles after this.\n  //\n  // This is not synchronized with polls and handle additions: this means that\n  // you can safely call it from within an observe callback, but it also means\n  // that we have to be careful when we iterate over _handles.\n  removeHandle: function (id) {\n    var self = this;\n\n    // This should not be possible: you can only call removeHandle by having\n    // access to the ObserveHandle, which isn't returned to user code until the\n    // multiplex is ready.\n    if (!self._ready())\n      throw new Error(\"Can't remove handles until the multiplex is ready\");\n\n    delete self._handles[id];\n\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-handles\", -1);\n\n    if (_.isEmpty(self._handles) &&\n        self._addHandleTasksScheduledButNotPerformed === 0) {\n      self._stop();\n    }\n  },\n  _stop: function (options) {\n    var self = this;\n    options = options || {};\n\n    // It shouldn't be possible for us to stop when all our handles still\n    // haven't been returned from observeChanges!\n    if (! self._ready() && ! options.fromQueryError)\n      throw Error(\"surprising _stop: not ready\");\n\n    // Call stop callback (which kills the underlying process which sends us\n    // callbacks and removes us from the connection's dictionary).\n    self._onStop();\n    Package.facts && Package.facts.Facts.incrementServerFact(\n      \"mongo-livedata\", \"observe-multiplexers\", -1);\n\n    // Cause future addHandleAndSendInitialAdds calls to throw (but the onStop\n    // callback should make our connection forget about us).\n    self._handles = null;\n  },\n\n  // Allows all addHandleAndSendInitialAdds calls to return, once all preceding\n  // adds have been processed. Does not block.\n  ready: function () {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (self._ready())\n        throw Error(\"can't make ObserveMultiplex ready twice!\");\n      self._readyFuture.return();\n    });\n  },\n\n  // If trying to execute the query results in an error, call this. This is\n  // intended for permanent errors, not transient network errors that could be\n  // fixed. It should only be called before ready(), because if you called ready\n  // that meant that you managed to run the query once. It will stop this\n  // ObserveMultiplex and cause addHandleAndSendInitialAdds calls (and thus\n  // observeChanges calls) to throw the error.\n  queryError: function (err) {\n    var self = this;\n    self._queue.runTask(function () {\n      if (self._ready())\n        throw Error(\"can't claim query has an error after it worked!\");\n      self._stop({fromQueryError: true});\n      self._readyFuture.throw(err);\n    });\n  },\n\n  // Calls \"cb\" once the effects of all \"ready\", \"addHandleAndSendInitialAdds\"\n  // and observe callbacks which came before this call have been propagated to\n  // all handles. \"ready\" must have already been called on this multiplexer.\n  onFlush: function (cb) {\n    var self = this;\n    self._queue.queueTask(function () {\n      if (!self._ready())\n        throw Error(\"only call onFlush on a multiplexer that will be ready\");\n      cb();\n    });\n  },\n  callbackNames: function () {\n    var self = this;\n    if (self._ordered)\n      return [\"addedBefore\", \"changed\", \"movedBefore\", \"removed\"];\n    else\n      return [\"added\", \"changed\", \"removed\"];\n  },\n  _ready: function () {\n    return this._readyFuture.isResolved();\n  },\n  _applyCallback: function (callbackName, args) {\n    var self = this;\n    self._queue.queueTask(function () {\n      // If we stopped in the meantime, do nothing.\n      if (!self._handles)\n        return;\n\n      // First, apply the change to the cache.\n      // XXX We could make applyChange callbacks promise not to hang on to any\n      // state from their arguments (assuming that their supplied callbacks\n      // don't) and skip this clone. Currently 'changed' hangs on to state\n      // though.\n      self._cache.applyChange[callbackName].apply(null, EJSON.clone(args));\n\n      // If we haven't finished the initial adds, then we should only be getting\n      // adds.\n      if (!self._ready() &&\n          (callbackName !== 'added' && callbackName !== 'addedBefore')) {\n        throw new Error(\"Got \" + callbackName + \" during initial adds\");\n      }\n\n      // Now multiplex the callbacks out to all observe handles. It's OK if\n      // these calls yield; since we're inside a task, no other use of our queue\n      // can continue until these are done. (But we do have to be careful to not\n      // use a handle that got removed, because removeHandle does not use the\n      // queue; thus, we iterate over an array of keys that we control.)\n      _.each(_.keys(self._handles), function (handleId) {\n        var handle = self._handles && self._handles[handleId];\n        if (!handle)\n          return;\n        var callback = handle['_' + callbackName];\n        // clone arguments so that callbacks can mutate their arguments\n        callback && callback.apply(null, EJSON.clone(args));\n      });\n    });\n  },\n\n  // Sends initial adds to a handle. It should only be called from within a task\n  // (the task that is processing the addHandleAndSendInitialAdds call). It\n  // synchronously invokes the handle's added or addedBefore; there's no need to\n  // flush the queue afterwards to ensure that the callbacks get out.\n  _sendAdds: function (handle) {\n    var self = this;\n    if (self._queue.safeToRunTask())\n      throw Error(\"_sendAdds may only be called from within a task!\");\n    var add = self._ordered ? handle._addedBefore : handle._added;\n    if (!add)\n      return;\n    // note: docs may be an _IdMap or an OrderedDict\n    self._cache.docs.forEach(function (doc, id) {\n      if (!_.has(self._handles, handle._id))\n        throw Error(\"handle got removed before sending initial adds!\");\n      var fields = EJSON.clone(doc);\n      delete fields._id;\n      if (self._ordered)\n        add(id, fields, null); // we're going in order, so add at end\n      else\n        add(id, fields);\n    });\n  }\n});\n\n\nvar nextObserveHandleId = 1;\nObserveHandle = function (multiplexer, callbacks) {\n  var self = this;\n  // The end user is only supposed to call stop().  The other fields are\n  // accessible to the multiplexer, though.\n  self._multiplexer = multiplexer;\n  _.each(multiplexer.callbackNames(), function (name) {\n    if (callbacks[name]) {\n      self['_' + name] = callbacks[name];\n    } else if (name === \"addedBefore\" && callbacks.added) {\n      // Special case: if you specify \"added\" and \"movedBefore\", you get an\n      // ordered observe where for some reason you don't get ordering data on\n      // the adds.  I dunno, we wrote tests for it, there must have been a\n      // reason.\n      self._addedBefore = function (id, fields, before) {\n        callbacks.added(id, fields);\n      };\n    }\n  });\n  self._stopped = false;\n  self._id = nextObserveHandleId++;\n};\nObserveHandle.prototype.stop = function () {\n  var self = this;\n  if (self._stopped)\n    return;\n  self._stopped = true;\n  self._multiplexer.removeHandle(self._id);\n};\n"]},"hash":"71ea05aa0f4b8f26548e1908b2d1c47bc66c01fd"}
