{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"var Future = Npm.require('fibers/future');\n\nOPLOG_COLLECTION = 'oplog.rs';\n\nvar TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\n\nvar showTS = function (ts) {\n  return \"Timestamp(\" + ts.getHighBits() + \", \" + ts.getLowBits() + \")\";\n};\n\nidForOp = function (op) {\n  if (op.op === 'd') return op.o._id;else if (op.op === 'i') return op.o._id;else if (op.op === 'u') return op.o2._id;else if (op.op === 'c') throw Error(\"Operator 'c' doesn't supply an object with id: \" + EJSON.stringify(op));else throw Error(\"Unknown op: \" + EJSON.stringify(op));\n};\n\nOplogHandle = function (oplogUrl, dbName) {\n  var self = this;\n  self._oplogUrl = oplogUrl;\n  self._dbName = dbName;\n\n  self._oplogLastEntryConnection = null;\n  self._oplogTailConnection = null;\n  self._stopped = false;\n  self._tailHandle = null;\n  self._readyFuture = new Future();\n  self._crossbar = new DDPServer._Crossbar({\n    factPackage: \"mongo-livedata\", factName: \"oplog-watchers\"\n  });\n  self._baseOplogSelector = {\n    ns: new RegExp('^' + Meteor._escapeRegExp(self._dbName) + '\\\\.'),\n    $or: [{ op: { $in: ['i', 'u', 'd'] } },\n    // drop collection\n    { op: 'c', 'o.drop': { $exists: true } }, { op: 'c', 'o.dropDatabase': 1 }]\n  };\n\n  // Data structures to support waitUntilCaughtUp(). Each oplog entry has a\n  // MongoTimestamp object on it (which is not the same as a Date --- it's a\n  // combination of time and an incrementing counter; see\n  // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).\n  //\n  // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}\n  // objects, sorted by ascending timestamp. _lastProcessedTS is the\n  // MongoTimestamp of the last oplog entry we've processed.\n  //\n  // Each time we call waitUntilCaughtUp, we take a peek at the final oplog\n  // entry in the db.  If we've already processed it (ie, it is not greater than\n  // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,\n  // waitUntilCaughtUp makes a new Future and inserts it along with the final\n  // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp\n  // then waits on that future, which is resolved once _lastProcessedTS is\n  // incremented to be past its timestamp by the worker fiber.\n  //\n  // XXX use a priority queue or something else that's faster than an array\n  self._catchingUpFutures = [];\n  self._lastProcessedTS = null;\n\n  self._onSkippedEntriesHook = new Hook({\n    debugPrintExceptions: \"onSkippedEntries callback\"\n  });\n\n  self._entryQueue = new Meteor._DoubleEndedQueue();\n  self._workerActive = false;\n\n  self._startTailing();\n};\n\n_.extend(OplogHandle.prototype, {\n  stop: function () {\n    var self = this;\n    if (self._stopped) return;\n    self._stopped = true;\n    if (self._tailHandle) self._tailHandle.stop();\n    // XXX should close connections too\n  },\n  onOplogEntry: function (trigger, callback) {\n    var self = this;\n    if (self._stopped) throw new Error(\"Called onOplogEntry on stopped handle!\");\n\n    // Calling onOplogEntry requires us to wait for the tailing to be ready.\n    self._readyFuture.wait();\n\n    var originalCallback = callback;\n    callback = Meteor.bindEnvironment(function (notification) {\n      // XXX can we avoid this clone by making oplog.js careful?\n      originalCallback(EJSON.clone(notification));\n    }, function (err) {\n      Meteor._debug(\"Error in oplog callback\", err.stack);\n    });\n    var listenHandle = self._crossbar.listen(trigger, callback);\n    return {\n      stop: function () {\n        listenHandle.stop();\n      }\n    };\n  },\n  // Register a callback to be invoked any time we skip oplog entries (eg,\n  // because we are too far behind).\n  onSkippedEntries: function (callback) {\n    var self = this;\n    if (self._stopped) throw new Error(\"Called onSkippedEntries on stopped handle!\");\n    return self._onSkippedEntriesHook.register(callback);\n  },\n  // Calls `callback` once the oplog has been processed up to a point that is\n  // roughly \"now\": specifically, once we've processed all ops that are\n  // currently visible.\n  // XXX become convinced that this is actually safe even if oplogConnection\n  // is some kind of pool\n  waitUntilCaughtUp: function () {\n    var self = this;\n    if (self._stopped) throw new Error(\"Called waitUntilCaughtUp on stopped handle!\");\n\n    // Calling waitUntilCaughtUp requries us to wait for the oplog connection to\n    // be ready.\n    self._readyFuture.wait();\n\n    while (!self._stopped) {\n      // We need to make the selector at least as restrictive as the actual\n      // tailing selector (ie, we need to specify the DB name) or else we might\n      // find a TS that won't show up in the actual tail stream.\n      try {\n        var lastEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, self._baseOplogSelector, { fields: { ts: 1 }, sort: { $natural: -1 } });\n        break;\n      } catch (e) {\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while reading last entry: \" + e);\n        Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped) return;\n\n    if (!lastEntry) {\n      // Really, nothing in the oplog? Well, we've processed everything.\n      return;\n    }\n\n    var ts = lastEntry.ts;\n    if (!ts) throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry));\n\n    if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {\n      // We've already caught up to here.\n      return;\n    }\n\n    // Insert the future into our list. Almost always, this will be at the end,\n    // but it's conceivable that if we fail over from one primary to another,\n    // the oplog entries we see will go backwards.\n    var insertAfter = self._catchingUpFutures.length;\n    while (insertAfter - 1 > 0 && self._catchingUpFutures[insertAfter - 1].ts.greaterThan(ts)) {\n      insertAfter--;\n    }\n    var f = new Future();\n    self._catchingUpFutures.splice(insertAfter, 0, { ts: ts, future: f });\n    f.wait();\n  },\n  _startTailing: function () {\n    var self = this;\n    // First, make sure that we're talking to the local database.\n    var mongodbUri = Npm.require('mongodb-uri');\n    if (mongodbUri.parse(self._oplogUrl).database !== 'local') {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");\n    }\n\n    // We make two separate connections to Mongo. The Node Mongo driver\n    // implements a naive round-robin connection pool: each \"connection\" is a\n    // pool of several (5 by default) TCP connections, and each request is\n    // rotated through the pools. Tailable cursor queries block on the server\n    // until there is some data to return (or until a few seconds have\n    // passed). So if the connection pool used for tailing cursors is the same\n    // pool used for other queries, the other queries will be delayed by seconds\n    // 1/5 of the time.\n    //\n    // The tail connection will only ever be running a single tail command, so\n    // it only needs to make one underlying TCP connection.\n    self._oplogTailConnection = new MongoConnection(self._oplogUrl, { poolSize: 1 });\n    // XXX better docs, but: it's to get monotonic results\n    // XXX is it safe to say \"if there's an in flight query, just use its\n    //     results\"? I don't think so but should consider that\n    self._oplogLastEntryConnection = new MongoConnection(self._oplogUrl, { poolSize: 1 });\n\n    // Now, make sure that there actually is a repl set here. If not, oplog\n    // tailing won't ever find anything!\n    var f = new Future();\n    self._oplogLastEntryConnection.db.admin().command({ ismaster: 1 }, f.resolver());\n    var isMasterDoc = f.wait();\n    if (!(isMasterDoc && isMasterDoc.documents && isMasterDoc.documents[0] && isMasterDoc.documents[0].setName)) {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" + \"a Mongo replica set\");\n    }\n\n    // Find the last oplog entry.\n    var lastOplogEntry = self._oplogLastEntryConnection.findOne(OPLOG_COLLECTION, {}, { sort: { $natural: -1 }, fields: { ts: 1 } });\n\n    var oplogSelector = _.clone(self._baseOplogSelector);\n    if (lastOplogEntry) {\n      // Start after the last entry that currently exists.\n      oplogSelector.ts = { $gt: lastOplogEntry.ts };\n      // If there are any calls to callWhenProcessedLatest before any other\n      // oplog entries show up, allow callWhenProcessedLatest to call its\n      // callback immediately.\n      self._lastProcessedTS = lastOplogEntry.ts;\n    }\n\n    var cursorDescription = new CursorDescription(OPLOG_COLLECTION, oplogSelector, { tailable: true });\n\n    self._tailHandle = self._oplogTailConnection.tail(cursorDescription, function (doc) {\n      self._entryQueue.push(doc);\n      self._maybeStartWorker();\n    });\n    self._readyFuture['return']();\n  },\n\n  _maybeStartWorker: function () {\n    var self = this;\n    if (self._workerActive) return;\n    self._workerActive = true;\n    Meteor.defer(function () {\n      try {\n        while (!self._stopped && !self._entryQueue.isEmpty()) {\n          // Are we too far behind? Just tell our observers that they need to\n          // repoll, and drop our queue.\n          if (self._entryQueue.length > TOO_FAR_BEHIND) {\n            var lastEntry = self._entryQueue.pop();\n            self._entryQueue.clear();\n\n            self._onSkippedEntriesHook.each(function (callback) {\n              callback();\n              return true;\n            });\n\n            // Free any waitUntilCaughtUp() calls that were waiting for us to\n            // pass something that we just skipped.\n            self._setLastProcessedTS(lastEntry.ts);\n            continue;\n          }\n\n          var doc = self._entryQueue.shift();\n\n          if (!(doc.ns && doc.ns.length > self._dbName.length + 1 && doc.ns.substr(0, self._dbName.length + 1) === self._dbName + '.')) {\n            throw new Error(\"Unexpected ns\");\n          }\n\n          var trigger = { collection: doc.ns.substr(self._dbName.length + 1),\n            dropCollection: false,\n            dropDatabase: false,\n            op: doc };\n\n          // Is it a special command and the collection name is hidden somewhere\n          // in operator?\n          if (trigger.collection === \"$cmd\") {\n            if (doc.o.dropDatabase) {\n              delete trigger.collection;\n              trigger.dropDatabase = true;\n            } else if (_.has(doc.o, 'drop')) {\n              trigger.collection = doc.o.drop;\n              trigger.dropCollection = true;\n              trigger.id = null;\n            } else {\n              throw Error(\"Unknown command \" + JSON.stringify(doc));\n            }\n          } else {\n            // All other ops have an id.\n            trigger.id = idForOp(doc);\n          }\n\n          self._crossbar.fire(trigger);\n\n          // Now that we've processed this operation, process pending\n          // sequencers.\n          if (!doc.ts) throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc));\n          self._setLastProcessedTS(doc.ts);\n        }\n      } finally {\n        self._workerActive = false;\n      }\n    });\n  },\n  _setLastProcessedTS: function (ts) {\n    var self = this;\n    self._lastProcessedTS = ts;\n    while (!_.isEmpty(self._catchingUpFutures) && self._catchingUpFutures[0].ts.lessThanOrEqual(self._lastProcessedTS)) {\n      var sequencer = self._catchingUpFutures.shift();\n      sequencer.future['return']();\n    }\n  }\n});","ast":null,"map":{"version":3,"sources":["/packages/mongo/oplog_tailing.js"],"names":[],"mappings":"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","file":"/packages/mongo/oplog_tailing.js.map","sourcesContent":["var Future = Npm.require('fibers/future');\n\nOPLOG_COLLECTION = 'oplog.rs';\n\nvar TOO_FAR_BEHIND = process.env.METEOR_OPLOG_TOO_FAR_BEHIND || 2000;\n\nvar showTS = function (ts) {\n  return \"Timestamp(\" + ts.getHighBits() + \", \" + ts.getLowBits() + \")\";\n};\n\nidForOp = function (op) {\n  if (op.op === 'd')\n    return op.o._id;\n  else if (op.op === 'i')\n    return op.o._id;\n  else if (op.op === 'u')\n    return op.o2._id;\n  else if (op.op === 'c')\n    throw Error(\"Operator 'c' doesn't supply an object with id: \" +\n                EJSON.stringify(op));\n  else\n    throw Error(\"Unknown op: \" + EJSON.stringify(op));\n};\n\nOplogHandle = function (oplogUrl, dbName) {\n  var self = this;\n  self._oplogUrl = oplogUrl;\n  self._dbName = dbName;\n\n  self._oplogLastEntryConnection = null;\n  self._oplogTailConnection = null;\n  self._stopped = false;\n  self._tailHandle = null;\n  self._readyFuture = new Future();\n  self._crossbar = new DDPServer._Crossbar({\n    factPackage: \"mongo-livedata\", factName: \"oplog-watchers\"\n  });\n  self._baseOplogSelector = {\n    ns: new RegExp('^' + Meteor._escapeRegExp(self._dbName) + '\\\\.'),\n    $or: [\n      { op: {$in: ['i', 'u', 'd']} },\n      // drop collection\n      { op: 'c', 'o.drop': { $exists: true } },\n      { op: 'c', 'o.dropDatabase': 1 },\n    ]\n  };\n\n  // Data structures to support waitUntilCaughtUp(). Each oplog entry has a\n  // MongoTimestamp object on it (which is not the same as a Date --- it's a\n  // combination of time and an incrementing counter; see\n  // http://docs.mongodb.org/manual/reference/bson-types/#timestamps).\n  //\n  // _catchingUpFutures is an array of {ts: MongoTimestamp, future: Future}\n  // objects, sorted by ascending timestamp. _lastProcessedTS is the\n  // MongoTimestamp of the last oplog entry we've processed.\n  //\n  // Each time we call waitUntilCaughtUp, we take a peek at the final oplog\n  // entry in the db.  If we've already processed it (ie, it is not greater than\n  // _lastProcessedTS), waitUntilCaughtUp immediately returns. Otherwise,\n  // waitUntilCaughtUp makes a new Future and inserts it along with the final\n  // timestamp entry that it read, into _catchingUpFutures. waitUntilCaughtUp\n  // then waits on that future, which is resolved once _lastProcessedTS is\n  // incremented to be past its timestamp by the worker fiber.\n  //\n  // XXX use a priority queue or something else that's faster than an array\n  self._catchingUpFutures = [];\n  self._lastProcessedTS = null;\n\n  self._onSkippedEntriesHook = new Hook({\n    debugPrintExceptions: \"onSkippedEntries callback\"\n  });\n\n  self._entryQueue = new Meteor._DoubleEndedQueue();\n  self._workerActive = false;\n\n  self._startTailing();\n};\n\n_.extend(OplogHandle.prototype, {\n  stop: function () {\n    var self = this;\n    if (self._stopped)\n      return;\n    self._stopped = true;\n    if (self._tailHandle)\n      self._tailHandle.stop();\n    // XXX should close connections too\n  },\n  onOplogEntry: function (trigger, callback) {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called onOplogEntry on stopped handle!\");\n\n    // Calling onOplogEntry requires us to wait for the tailing to be ready.\n    self._readyFuture.wait();\n\n    var originalCallback = callback;\n    callback = Meteor.bindEnvironment(function (notification) {\n      // XXX can we avoid this clone by making oplog.js careful?\n      originalCallback(EJSON.clone(notification));\n    }, function (err) {\n      Meteor._debug(\"Error in oplog callback\", err.stack);\n    });\n    var listenHandle = self._crossbar.listen(trigger, callback);\n    return {\n      stop: function () {\n        listenHandle.stop();\n      }\n    };\n  },\n  // Register a callback to be invoked any time we skip oplog entries (eg,\n  // because we are too far behind).\n  onSkippedEntries: function (callback) {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called onSkippedEntries on stopped handle!\");\n    return self._onSkippedEntriesHook.register(callback);\n  },\n  // Calls `callback` once the oplog has been processed up to a point that is\n  // roughly \"now\": specifically, once we've processed all ops that are\n  // currently visible.\n  // XXX become convinced that this is actually safe even if oplogConnection\n  // is some kind of pool\n  waitUntilCaughtUp: function () {\n    var self = this;\n    if (self._stopped)\n      throw new Error(\"Called waitUntilCaughtUp on stopped handle!\");\n\n    // Calling waitUntilCaughtUp requries us to wait for the oplog connection to\n    // be ready.\n    self._readyFuture.wait();\n\n    while (!self._stopped) {\n      // We need to make the selector at least as restrictive as the actual\n      // tailing selector (ie, we need to specify the DB name) or else we might\n      // find a TS that won't show up in the actual tail stream.\n      try {\n        var lastEntry = self._oplogLastEntryConnection.findOne(\n          OPLOG_COLLECTION, self._baseOplogSelector,\n          {fields: {ts: 1}, sort: {$natural: -1}});\n        break;\n      } catch (e) {\n        // During failover (eg) if we get an exception we should log and retry\n        // instead of crashing.\n        Meteor._debug(\"Got exception while reading last entry: \" + e);\n        Meteor._sleepForMs(100);\n      }\n    }\n\n    if (self._stopped)\n      return;\n\n    if (!lastEntry) {\n      // Really, nothing in the oplog? Well, we've processed everything.\n      return;\n    }\n\n    var ts = lastEntry.ts;\n    if (!ts)\n      throw Error(\"oplog entry without ts: \" + EJSON.stringify(lastEntry));\n\n    if (self._lastProcessedTS && ts.lessThanOrEqual(self._lastProcessedTS)) {\n      // We've already caught up to here.\n      return;\n    }\n\n\n    // Insert the future into our list. Almost always, this will be at the end,\n    // but it's conceivable that if we fail over from one primary to another,\n    // the oplog entries we see will go backwards.\n    var insertAfter = self._catchingUpFutures.length;\n    while (insertAfter - 1 > 0\n           && self._catchingUpFutures[insertAfter - 1].ts.greaterThan(ts)) {\n      insertAfter--;\n    }\n    var f = new Future;\n    self._catchingUpFutures.splice(insertAfter, 0, {ts: ts, future: f});\n    f.wait();\n  },\n  _startTailing: function () {\n    var self = this;\n    // First, make sure that we're talking to the local database.\n    var mongodbUri = Npm.require('mongodb-uri');\n    if (mongodbUri.parse(self._oplogUrl).database !== 'local') {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" +\n                  \"a Mongo replica set\");\n    }\n\n    // We make two separate connections to Mongo. The Node Mongo driver\n    // implements a naive round-robin connection pool: each \"connection\" is a\n    // pool of several (5 by default) TCP connections, and each request is\n    // rotated through the pools. Tailable cursor queries block on the server\n    // until there is some data to return (or until a few seconds have\n    // passed). So if the connection pool used for tailing cursors is the same\n    // pool used for other queries, the other queries will be delayed by seconds\n    // 1/5 of the time.\n    //\n    // The tail connection will only ever be running a single tail command, so\n    // it only needs to make one underlying TCP connection.\n    self._oplogTailConnection = new MongoConnection(\n      self._oplogUrl, {poolSize: 1});\n    // XXX better docs, but: it's to get monotonic results\n    // XXX is it safe to say \"if there's an in flight query, just use its\n    //     results\"? I don't think so but should consider that\n    self._oplogLastEntryConnection = new MongoConnection(\n      self._oplogUrl, {poolSize: 1});\n\n    // Now, make sure that there actually is a repl set here. If not, oplog\n    // tailing won't ever find anything!\n    var f = new Future;\n    self._oplogLastEntryConnection.db.admin().command(\n      { ismaster: 1 }, f.resolver());\n    var isMasterDoc = f.wait();\n    if (!(isMasterDoc && isMasterDoc.documents && isMasterDoc.documents[0] &&\n          isMasterDoc.documents[0].setName)) {\n      throw Error(\"$MONGO_OPLOG_URL must be set to the 'local' database of \" +\n                  \"a Mongo replica set\");\n    }\n\n    // Find the last oplog entry.\n    var lastOplogEntry = self._oplogLastEntryConnection.findOne(\n      OPLOG_COLLECTION, {}, {sort: {$natural: -1}, fields: {ts: 1}});\n\n    var oplogSelector = _.clone(self._baseOplogSelector);\n    if (lastOplogEntry) {\n      // Start after the last entry that currently exists.\n      oplogSelector.ts = {$gt: lastOplogEntry.ts};\n      // If there are any calls to callWhenProcessedLatest before any other\n      // oplog entries show up, allow callWhenProcessedLatest to call its\n      // callback immediately.\n      self._lastProcessedTS = lastOplogEntry.ts;\n    }\n\n    var cursorDescription = new CursorDescription(\n      OPLOG_COLLECTION, oplogSelector, {tailable: true});\n\n    self._tailHandle = self._oplogTailConnection.tail(\n      cursorDescription, function (doc) {\n        self._entryQueue.push(doc);\n        self._maybeStartWorker();\n      }\n    );\n    self._readyFuture.return();\n  },\n\n  _maybeStartWorker: function () {\n    var self = this;\n    if (self._workerActive)\n      return;\n    self._workerActive = true;\n    Meteor.defer(function () {\n      try {\n        while (! self._stopped && ! self._entryQueue.isEmpty()) {\n          // Are we too far behind? Just tell our observers that they need to\n          // repoll, and drop our queue.\n          if (self._entryQueue.length > TOO_FAR_BEHIND) {\n            var lastEntry = self._entryQueue.pop();\n            self._entryQueue.clear();\n\n            self._onSkippedEntriesHook.each(function (callback) {\n              callback();\n              return true;\n            });\n\n            // Free any waitUntilCaughtUp() calls that were waiting for us to\n            // pass something that we just skipped.\n            self._setLastProcessedTS(lastEntry.ts);\n            continue;\n          }\n\n          var doc = self._entryQueue.shift();\n\n          if (!(doc.ns && doc.ns.length > self._dbName.length + 1 &&\n                doc.ns.substr(0, self._dbName.length + 1) ===\n                (self._dbName + '.'))) {\n            throw new Error(\"Unexpected ns\");\n          }\n\n          var trigger = {collection: doc.ns.substr(self._dbName.length + 1),\n                         dropCollection: false,\n                         dropDatabase: false,\n                         op: doc};\n\n          // Is it a special command and the collection name is hidden somewhere\n          // in operator?\n          if (trigger.collection === \"$cmd\") {\n            if (doc.o.dropDatabase) {\n              delete trigger.collection;\n              trigger.dropDatabase = true;\n            } else if (_.has(doc.o, 'drop')) {\n              trigger.collection = doc.o.drop;\n              trigger.dropCollection = true;\n              trigger.id = null;\n            } else {\n              throw Error(\"Unknown command \" + JSON.stringify(doc));\n            }\n          } else {\n            // All other ops have an id.\n            trigger.id = idForOp(doc);\n          }\n\n          self._crossbar.fire(trigger);\n\n          // Now that we've processed this operation, process pending\n          // sequencers.\n          if (!doc.ts)\n            throw Error(\"oplog entry without ts: \" + EJSON.stringify(doc));\n          self._setLastProcessedTS(doc.ts);\n        }\n      } finally {\n        self._workerActive = false;\n      }\n    });\n  },\n  _setLastProcessedTS: function (ts) {\n    var self = this;\n    self._lastProcessedTS = ts;\n    while (!_.isEmpty(self._catchingUpFutures)\n           && self._catchingUpFutures[0].ts.lessThanOrEqual(\n             self._lastProcessedTS)) {\n      var sequencer = self._catchingUpFutures.shift();\n      sequencer.future.return();\n    }\n  }\n});\n"]},"hash":"a45293274a36f31cc3ba5cd8933e4dafc845eb97"}
