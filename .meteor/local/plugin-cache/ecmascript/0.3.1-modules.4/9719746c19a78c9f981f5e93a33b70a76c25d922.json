{"metadata":{"modules":{"imports":[],"exports":{"exported":[],"specifiers":[]}},"usedHelpers":[]},"ignored":false,"code":"if (Meteor.isServer) {\n  // Set up allow/deny rules for test collections\n\n  var allowCollections = {};\n\n  // We create the collections in the publisher (instead of using a method or\n  // something) because if we made them with a method, we'd need to follow the\n  // method with some subscribes, and it's possible that the method call would\n  // be delayed by a wait method and the subscribe messages would be sent before\n  // it and fail due to the collection not yet existing. So we are very hacky\n  // and use a publish.\n  Meteor.publish(\"allowTests\", function (nonce, idGeneration) {\n    check(nonce, String);\n    check(idGeneration, String);\n    var cursors = [];\n    var needToConfigure = undefined;\n\n    // helper for defining a collection. we are careful to create just one\n    // Mongo.Collection even if the sub body is rerun, by caching them.\n    var defineCollection = function (name, insecure, transform) {\n      var fullName = name + idGeneration + nonce;\n\n      var collection;\n      if (_.has(allowCollections, fullName)) {\n        collection = allowCollections[fullName];\n        if (needToConfigure === true) throw new Error(\"collections inconsistently exist\");\n        needToConfigure = false;\n      } else {\n        collection = new Mongo.Collection(fullName, { idGeneration: idGeneration, transform: transform });\n        allowCollections[fullName] = collection;\n        if (needToConfigure === false) throw new Error(\"collections inconsistently don't exist\");\n        needToConfigure = true;\n        collection._insecure = insecure;\n        var m = {};\n        m[\"clear-collection-\" + fullName] = function () {\n          collection.remove({});\n        };\n        Meteor.methods(m);\n      }\n\n      cursors.push(collection.find());\n      return collection;\n    };\n\n    var insecureCollection = defineCollection(\"collection-insecure\", true /*insecure*/);\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\", false /*insecure*/);\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\"collection-restrictedDefaultSecure\", false /*insecure*/);\n    var restrictedCollectionDefaultInsecure = defineCollection(\"collection-restrictedDefaultInsecure\", true /*insecure*/);\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\"collection-restrictedForUpdateOptionsTest\", true /*insecure*/);\n    var restrictedCollectionForPartialAllowTest = defineCollection(\"collection-restrictedForPartialAllowTest\", true /*insecure*/);\n    var restrictedCollectionForPartialDenyTest = defineCollection(\"collection-restrictedForPartialDenyTest\", true /*insecure*/);\n    var restrictedCollectionForFetchTest = defineCollection(\"collection-restrictedForFetchTest\", true /*insecure*/);\n    var restrictedCollectionForFetchAllTest = defineCollection(\"collection-restrictedForFetchAllTest\", true /*insecure*/);\n    var restrictedCollectionWithTransform = defineCollection(\"withTransform\", false, function (doc) {\n      return doc.a;\n    });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\"collection-restrictedForInvalidTransform\", false /*insecure*/);\n    var restrictedCollectionForClientIdTest = defineCollection(\"collection-restrictedForClientIdTest\", false /*insecure*/);\n\n    if (needToConfigure) {\n      restrictedCollectionWithTransform.allow({\n        insert: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        update: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        remove: function (userId, doc) {\n          return doc.bar === \"bar\";\n        }\n      });\n      restrictedCollectionWithTransform.allow({\n        // transform: null means that doc here is the top level, not the 'a'\n        // element.\n        transform: null,\n        insert: function (userId, doc) {\n          return !!doc.topLevelField;\n        },\n        update: function (userId, doc) {\n          return !!doc.topLevelField;\n        }\n      });\n      restrictedCollectionForInvalidTransformTest.allow({\n        // transform must return an object which is not a mongo id\n        transform: function (doc) {\n          return doc._id;\n        },\n        insert: function () {\n          return true;\n        }\n      });\n      restrictedCollectionForClientIdTest.allow({\n        // This test just requires the collection to trigger the restricted\n        // case.\n        insert: function () {\n          return true;\n        }\n      });\n\n      // two calls to allow to verify that either validator is sufficient.\n      var allows = [{\n        insert: function (userId, doc) {\n          return doc.canInsert;\n        },\n        update: function (userId, doc) {\n          return doc.canUpdate;\n        },\n        remove: function (userId, doc) {\n          return doc.canRemove;\n        }\n      }, {\n        insert: function (userId, doc) {\n          return doc.canInsert2;\n        },\n        update: function (userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'canUpdate2');\n        },\n        remove: function (userId, doc) {\n          return doc.canRemove2;\n        }\n      }];\n\n      // two calls to deny to verify that either one blocks the change.\n      var denies = [{\n        insert: function (userId, doc) {\n          return doc.cantInsert;\n        },\n        remove: function (userId, doc) {\n          return doc.cantRemove;\n        }\n      }, {\n        insert: function (userId, doc) {\n          // Don't allow explicit ID to be set by the client.\n          return _.has(doc, '_id');\n        },\n        update: function (userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'verySecret');\n        }\n      }];\n\n      _.each([restrictedCollectionDefaultSecure, restrictedCollectionDefaultInsecure, restrictedCollectionForUpdateOptionsTest], function (collection) {\n        _.each(allows, function (allow) {\n          collection.allow(allow);\n        });\n        _.each(denies, function (deny) {\n          collection.deny(deny);\n        });\n      });\n\n      // just restrict one operation so that we can verify that others\n      // fail\n      restrictedCollectionForPartialAllowTest.allow({\n        insert: function () {}\n      });\n      restrictedCollectionForPartialDenyTest.deny({\n        insert: function () {}\n      });\n\n      // verify that we only fetch the fields specified - we should\n      // be fetching just field1, field2, and field3.\n      restrictedCollectionForFetchTest.allow({\n        insert: function () {\n          return true;\n        },\n        update: function (userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function (userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchTest.allow({\n        fetch: ['field2']\n      });\n      restrictedCollectionForFetchTest.deny({\n        fetch: ['field3']\n      });\n\n      // verify that not passing fetch to one of the calls to allow\n      // causes all fields to be fetched\n      restrictedCollectionForFetchAllTest.allow({\n        insert: function () {\n          return true;\n        },\n        update: function (userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function (userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchAllTest.allow({\n        update: function () {\n          return true;\n        }\n      });\n    }\n\n    return cursors;\n  });\n}\n\nif (Meteor.isClient) {\n  _.each(['STRING', 'MONGO'], function (idGeneration) {\n    // Set up a bunch of test collections... on the client! They match the ones\n    // created by setUpAllowTestsCollections.\n\n    var nonce = Random.id();\n    // Tell the server to make, configure, and publish a set of collections unique\n    // to our test run. Since the method does not unblock, this will complete\n    // running on the server before anything else happens.\n    Meteor.subscribe('allowTests', nonce, idGeneration);\n\n    // helper for defining a collection, subscribing to it, and defining\n    // a method to clear it\n    var defineCollection = function (name, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection = new Mongo.Collection(fullName, { idGeneration: idGeneration, transform: transform });\n\n      collection.callClearMethod = function (callback) {\n        Meteor.call(\"clear-collection-\" + fullName, callback);\n      };\n      collection.unnoncedName = name + idGeneration;\n      return collection;\n    };\n\n    // totally insecure collection\n    var insecureCollection = defineCollection(\"collection-insecure\");\n\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\");\n\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\"collection-restrictedDefaultSecure\");\n    var restrictedCollectionDefaultInsecure = defineCollection(\"collection-restrictedDefaultInsecure\");\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\"collection-restrictedForUpdateOptionsTest\");\n    var restrictedCollectionForPartialAllowTest = defineCollection(\"collection-restrictedForPartialAllowTest\");\n    var restrictedCollectionForPartialDenyTest = defineCollection(\"collection-restrictedForPartialDenyTest\");\n    var restrictedCollectionForFetchTest = defineCollection(\"collection-restrictedForFetchTest\");\n    var restrictedCollectionForFetchAllTest = defineCollection(\"collection-restrictedForFetchAllTest\");\n    var restrictedCollectionWithTransform = defineCollection(\"withTransform\", function (doc) {\n      return doc.a;\n    });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\"collection-restrictedForInvalidTransform\");\n    var restrictedCollectionForClientIdTest = defineCollection(\"collection-restrictedForClientIdTest\");\n\n    // test that if allow is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial allow, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForPartialAllowTest.update('foo', { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.error, 403);\n      }));\n    }]);\n\n    // test that if deny is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial deny, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForPartialDenyTest.update('foo', { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.error, 403);\n      }));\n    }]);\n\n    // test that we only fetch the fields specified\n    testAsyncMulti(\"collection - fetch, \" + idGeneration, [function (test, expect) {\n      var fetchId = restrictedCollectionForFetchTest.insert({ field1: 1, field2: 1, field3: 1, field4: 1 });\n      var fetchAllId = restrictedCollectionForFetchAllTest.insert({ field1: 1, field2: 1, field3: 1, field4: 1 });\n      restrictedCollectionForFetchTest.update(fetchId, { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3\");\n      }));\n      restrictedCollectionForFetchTest.remove(fetchId, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3\");\n      }));\n\n      restrictedCollectionForFetchAllTest.update(fetchAllId, { $set: { updated: true } }, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n      }));\n      restrictedCollectionForFetchAllTest.remove(fetchAllId, expect(function (err, res) {\n        test.equal(err.reason, \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n      }));\n    }]);\n\n    (function () {\n      testAsyncMulti(\"collection - restricted factories \" + idGeneration, [function (test, expect) {\n        restrictedCollectionWithTransform.callClearMethod(expect(function () {\n          test.equal(restrictedCollectionWithTransform.find().count(), 0);\n        }));\n      }, function (test, expect) {\n        var self = this;\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"foo\", bar: \"bar\", baz: \"baz\" }\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item1 = res;\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"foo\", bar: \"quux\", baz: \"quux\" },\n          b: \"potato\"\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item2 = res;\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"adsfadf\", bar: \"quux\", baz: \"quux\" },\n          b: \"potato\"\n        }, expect(function (e, res) {\n          test.isTrue(e);\n        }));\n        restrictedCollectionWithTransform.insert({\n          a: { foo: \"bar\" },\n          topLevelField: true\n        }, expect(function (e, res) {\n          test.isFalse(e);\n          test.isTrue(res);\n          self.item3 = res;\n        }));\n      }, function (test, expect) {\n        var self = this;\n        // This should work, because there is an update allow for things with\n        // topLevelField.\n        restrictedCollectionWithTransform.update(self.item3, { $set: { xxx: true } }, expect(function (e, res) {\n          test.isFalse(e);\n          test.equal(1, res);\n        }));\n      }, function (test, expect) {\n        var self = this;\n        test.equal(restrictedCollectionWithTransform.findOne(self.item1), { _id: self.item1, foo: \"foo\", bar: \"bar\", baz: \"baz\" });\n        restrictedCollectionWithTransform.remove(self.item1, expect(function (e, res) {\n          test.isFalse(e);\n        }));\n        restrictedCollectionWithTransform.remove(self.item2, expect(function (e, res) {\n          test.isTrue(e);\n        }));\n      }]);\n    })();\n\n    testAsyncMulti(\"collection - insecure, \" + idGeneration, [function (test, expect) {\n      insecureCollection.callClearMethod(expect(function () {\n        test.equal(insecureCollection.find().count(), 0);\n      }));\n    }, function (test, expect) {\n      var id = insecureCollection.insert({ foo: 'bar' }, expect(function (err, res) {\n        test.equal(res, id);\n        test.equal(insecureCollection.find(id).count(), 1);\n        test.equal(insecureCollection.findOne(id).foo, 'bar');\n      }));\n      test.equal(insecureCollection.find(id).count(), 1);\n      test.equal(insecureCollection.findOne(id).foo, 'bar');\n    }]);\n\n    testAsyncMulti(\"collection - locked down, \" + idGeneration, [function (test, expect) {\n      lockedDownCollection.callClearMethod(expect(function () {\n        test.equal(lockedDownCollection.find().count(), 0);\n      }));\n    }, function (test, expect) {\n      lockedDownCollection.insert({ foo: 'bar' }, expect(function (err, res) {\n        test.equal(err.error, 403);\n        test.equal(lockedDownCollection.find().count(), 0);\n      }));\n    }]);\n\n    (function () {\n      var collection = restrictedCollectionForUpdateOptionsTest;\n      var id1, id2;\n      testAsyncMulti(\"collection - update options, \" + idGeneration, [\n      // init\n      function (test, expect) {\n        collection.callClearMethod(expect(function () {\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // put a few objects\n      function (test, expect) {\n        var doc = { canInsert: true, canUpdate: true };\n        id1 = collection.insert(doc);\n        id2 = collection.insert(doc);\n        collection.insert(doc);\n        collection.insert(doc, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 4);\n        }));\n      },\n      // update by id\n      function (test, expect) {\n        collection.update(id1, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 1);\n        }));\n      },\n      // update by id in an object\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // update with replacement operator not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { _id: id2, updated: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /In a restricted/);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // upsert not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $set: { upserted: true } }, { upsert: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /in a restricted/);\n          test.equal(collection.find({ upserted: true }).count(), 0);\n        }));\n      },\n      // update with rename operator not allowed, and has nice error.\n      function (test, expect) {\n        collection.update({ _id: id2 }, { $rename: { updated: 'asdf' } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.matches(err.reason, /not allowed/);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // update method with a non-ID selector is not allowed\n      function (test, expect) {\n        // We shouldn't even send the method...\n        test.throws(function () {\n          collection.update({ updated: { $exists: false } }, { $set: { updated: true } });\n        });\n        // ... but if we did, the server would reject it too.\n        Meteor.call('/' + collection._name + '/update', { updated: { $exists: false } }, { $set: { updated: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      },\n      // make sure it doesn't think that {_id: 'foo', something: else} is ok.\n      function (test, expect) {\n        test.throws(function () {\n          collection.update({ _id: id1, updated: { $exists: false } }, { $set: { updated: true } });\n        });\n      },\n      // remove method with a non-ID selector is not allowed\n      function (test, expect) {\n        // We shouldn't even send the method...\n        test.throws(function () {\n          collection.remove({ updated: true });\n        });\n        // ... but if we did, the server would reject it too.\n        Meteor.call('/' + collection._name + '/remove', { updated: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // unchanged\n          test.equal(collection.find({ updated: true }).count(), 2);\n        }));\n      }]);\n    })();\n\n    _.each([restrictedCollectionDefaultInsecure, restrictedCollectionDefaultSecure], function (collection) {\n      var canUpdateId, canRemoveId;\n\n      testAsyncMulti(\"collection - \" + collection.unnoncedName, [\n      // init\n      function (test, expect) {\n        collection.callClearMethod(expect(function () {\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n\n      // insert with no allows passing. request is denied.\n      function (test, expect) {\n        collection.insert({}, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert with one allow and one deny. denied.\n      function (test, expect) {\n        collection.insert({ canInsert: true, cantInsert: true }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert with one allow and other deny. denied.\n      function (test, expect) {\n        collection.insert({ canInsert: true, _id: Random.id() }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 0);\n        }));\n      },\n      // insert one allow passes. allowed.\n      function (test, expect) {\n        collection.insert({ canInsert: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 1);\n        }));\n      },\n      // insert other allow passes. allowed.\n      function (test, expect) {\n        canUpdateId = collection.insert({ canInsert2: true, canUpdate: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n      // yet a third insert executes. this one has canRemove and\n      function (test, expect) {\n        canRemoveId = collection.insert({ canInsert: true, canRemove: true, cantRemove: true }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // can't update with a non-operator mutation\n      function (test, expect) {\n        collection.update(canUpdateId, { newObject: 1 }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // updating dotted fields works as if we are changing their\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { \"dotted.field\": 1 } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.findOne(canUpdateId).dotted.field, 1);\n        }));\n      }, function (test, expect) {\n        collection.update(canUpdateId, { $set: { \"verySecret.field\": 1 } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(collection.find({ verySecret: { $exists: true } }).count(), 0);\n        }));\n      },\n\n      // update doesn't do anything if no docs match\n      function (test, expect) {\n        collection.update(\"doesn't exist\", { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 0);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when access is denied trying to set `verySecret`\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { verySecret: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when trying to set two fields, one of which is\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { updated: true, verySecret: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update fails when trying to modify docs that don't\n      function (test, expect) {\n        collection.update(canRemoveId, { $set: { updated: true } }, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n          test.equal(collection.find({ updated: true }).count(), 0);\n        }));\n      },\n      // update executes when it should\n      function (test, expect) {\n        collection.update(canUpdateId, { $set: { updated: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ updated: true }).count(), 1);\n        }));\n      },\n\n      // remove fails when trying to modify a doc with no `canRemove` set\n      function (test, expect) {\n        collection.remove(canUpdateId, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n      // remove fails when trying to modify an doc with `cantRemove`\n      function (test, expect) {\n        collection.remove(canRemoveId, expect(function (err, res) {\n          test.equal(err.error, 403);\n          // nothing has changed\n          test.equal(collection.find().count(), 3);\n        }));\n      },\n\n      // update the doc to remove cantRemove.\n      function (test, expect) {\n        collection.update(canRemoveId, { $set: { cantRemove: false, canUpdate2: true } }, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          test.equal(collection.find({ cantRemove: true }).count(), 0);\n        }));\n      },\n\n      // now remove can remove it.\n      function (test, expect) {\n        collection.remove(canRemoveId, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 1);\n          // successfully removed\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n\n      // try to remove a doc that doesn't exist. see we remove no docs.\n      function (test, expect) {\n        collection.remove('some-random-id-that-never-matches', expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, 0);\n          // nothing removed\n          test.equal(collection.find().count(), 2);\n        }));\n      },\n\n      // methods can still bypass restrictions\n      function (test, expect) {\n        collection.callClearMethod(expect(function (err, res) {\n          test.isFalse(err);\n          // successfully removed\n          test.equal(collection.find().count(), 0);\n        }));\n      }]);\n    });\n    testAsyncMulti(\"collection - allow/deny transform must return object, \" + idGeneration, [function (test, expect) {\n      restrictedCollectionForInvalidTransformTest.insert({}, expect(function (err, res) {\n        test.isTrue(err);\n      }));\n    }]);\n    testAsyncMulti(\"collection - restricted collection allows client-side id, \" + idGeneration, [function (test, expect) {\n      var self = this;\n      self.id = Random.id();\n      restrictedCollectionForClientIdTest.insert({ _id: self.id }, expect(function (err, res) {\n        test.isFalse(err);\n        test.equal(res, self.id);\n        test.equal(restrictedCollectionForClientIdTest.findOne(self.id), { _id: self.id });\n      }));\n    }]);\n  }); // end idGeneration loop\n} // end if isClient\n\n// A few simple server-only tests which don't need to coordinate collections\n// with the client..\nif (Meteor.isServer) {\n  Tinytest.add(\"collection - allow and deny validate options\", function (test) {\n    var collection = new Mongo.Collection(null);\n\n    test.throws(function () {\n      collection.allow({ invalidOption: true });\n    });\n    test.throws(function () {\n      collection.deny({ invalidOption: true });\n    });\n\n    _.each(['insert', 'update', 'remove', 'fetch'], function (key) {\n      var options = {};\n      options[key] = true;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = false;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = undefined;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = ['an array']; // this should be a function, not an array\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    test.throws(function () {\n      collection.allow({ fetch: function () {} }); // this should be an array\n    });\n  });\n\n  Tinytest.add(\"collection - calling allow restricts\", function (test) {\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._restricted, false);\n    collection.allow({\n      insert: function () {}\n    });\n    test.equal(collection._restricted, true);\n  });\n\n  Tinytest.add(\"collection - global insecure\", function (test) {\n    // note: This test alters the global insecure status, by sneakily hacking\n    // the global Package object!\n    var insecurePackage = Package.insecure;\n\n    Package.insecure = {};\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._isInsecure(), true);\n\n    Package.insecure = undefined;\n    test.equal(collection._isInsecure(), false);\n\n    delete Package.insecure;\n    test.equal(collection._isInsecure(), false);\n\n    collection._insecure = true;\n    test.equal(collection._isInsecure(), true);\n\n    if (insecurePackage) Package.insecure = insecurePackage;else delete Package.insecure;\n  });\n}\n// includes canUpdate for later.\n// cantRemove set for later.\n// top part\n// `verySecret`\n// have `canUpdate` set\n// set","ast":null,"map":{"version":3,"sources":["/packages/mongo/allow_tests.js"],"names":[],"mappings":"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","file":"/packages/mongo/allow_tests.js.map","sourcesContent":["if (Meteor.isServer) {\n  // Set up allow/deny rules for test collections\n\n  var allowCollections = {};\n\n  // We create the collections in the publisher (instead of using a method or\n  // something) because if we made them with a method, we'd need to follow the\n  // method with some subscribes, and it's possible that the method call would\n  // be delayed by a wait method and the subscribe messages would be sent before\n  // it and fail due to the collection not yet existing. So we are very hacky\n  // and use a publish.\n  Meteor.publish(\"allowTests\", function (nonce, idGeneration) {\n    check(nonce, String);\n    check(idGeneration, String);\n    var cursors = [];\n    var needToConfigure = undefined;\n\n    // helper for defining a collection. we are careful to create just one\n    // Mongo.Collection even if the sub body is rerun, by caching them.\n    var defineCollection = function(name, insecure, transform) {\n      var fullName = name + idGeneration + nonce;\n\n      var collection;\n      if (_.has(allowCollections, fullName)) {\n        collection = allowCollections[fullName];\n        if (needToConfigure === true)\n          throw new Error(\"collections inconsistently exist\");\n        needToConfigure = false;\n      } else {\n        collection = new Mongo.Collection(\n          fullName, {idGeneration: idGeneration, transform: transform});\n        allowCollections[fullName] = collection;\n        if (needToConfigure === false)\n          throw new Error(\"collections inconsistently don't exist\");\n        needToConfigure = true;\n        collection._insecure = insecure;\n        var m = {};\n        m[\"clear-collection-\" + fullName] = function() {\n          collection.remove({});\n        };\n        Meteor.methods(m);\n      }\n\n      cursors.push(collection.find());\n      return collection;\n    };\n\n    var insecureCollection = defineCollection(\n      \"collection-insecure\", true /*insecure*/);\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\n      \"collection-locked-down\", false /*insecure*/);\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\", false /*insecure*/);\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\", true /*insecure*/);\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\", true /*insecure*/);\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\", true /*insecure*/);\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\", true /*insecure*/);\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\", true /*insecure*/);\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\", true /*insecure*/);\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", false, function (doc) {\n        return doc.a;\n      });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\n      \"collection-restrictedForInvalidTransform\", false /*insecure*/);\n    var restrictedCollectionForClientIdTest = defineCollection(\n      \"collection-restrictedForClientIdTest\", false /*insecure*/);\n\n    if (needToConfigure) {\n      restrictedCollectionWithTransform.allow({\n        insert: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        update: function (userId, doc) {\n          return doc.foo === \"foo\";\n        },\n        remove: function (userId, doc) {\n          return doc.bar === \"bar\";\n        }\n      });\n      restrictedCollectionWithTransform.allow({\n        // transform: null means that doc here is the top level, not the 'a'\n        // element.\n        transform: null,\n        insert: function (userId, doc) {\n          return !!doc.topLevelField;\n        },\n        update: function (userId, doc) {\n          return !!doc.topLevelField;\n        }\n      });\n      restrictedCollectionForInvalidTransformTest.allow({\n        // transform must return an object which is not a mongo id\n        transform: function (doc) { return doc._id; },\n        insert: function () { return true; }\n      });\n      restrictedCollectionForClientIdTest.allow({\n        // This test just requires the collection to trigger the restricted\n        // case.\n        insert: function () { return true; }\n      });\n\n      // two calls to allow to verify that either validator is sufficient.\n      var allows = [{\n        insert: function(userId, doc) {\n          return doc.canInsert;\n        },\n        update: function(userId, doc) {\n          return doc.canUpdate;\n        },\n        remove: function (userId, doc) {\n          return doc.canRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          return doc.canInsert2;\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'canUpdate2');\n        },\n        remove: function(userId, doc) {\n          return doc.canRemove2;\n        }\n      }];\n\n      // two calls to deny to verify that either one blocks the change.\n      var denies = [{\n        insert: function(userId, doc) {\n          return doc.cantInsert;\n        },\n        remove: function (userId, doc) {\n          return doc.cantRemove;\n        }\n      }, {\n        insert: function(userId, doc) {\n          // Don't allow explicit ID to be set by the client.\n          return _.has(doc, '_id');\n        },\n        update: function(userId, doc, fields, modifier) {\n          return -1 !== _.indexOf(fields, 'verySecret');\n        }\n      }];\n\n      _.each([\n        restrictedCollectionDefaultSecure,\n        restrictedCollectionDefaultInsecure,\n        restrictedCollectionForUpdateOptionsTest\n      ], function (collection) {\n        _.each(allows, function (allow) {\n          collection.allow(allow);\n        });\n        _.each(denies, function (deny) {\n          collection.deny(deny);\n        });\n      });\n\n      // just restrict one operation so that we can verify that others\n      // fail\n      restrictedCollectionForPartialAllowTest.allow({\n        insert: function() {}\n      });\n      restrictedCollectionForPartialDenyTest.deny({\n        insert: function() {}\n      });\n\n      // verify that we only fetch the fields specified - we should\n      // be fetching just field1, field2, and field3.\n      restrictedCollectionForFetchTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchTest.allow({\n        fetch: ['field2']\n      });\n      restrictedCollectionForFetchTest.deny({\n        fetch: ['field3']\n      });\n\n      // verify that not passing fetch to one of the calls to allow\n      // causes all fields to be fetched\n      restrictedCollectionForFetchAllTest.allow({\n        insert: function() { return true; },\n        update: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        remove: function(userId, doc) {\n          // throw fields in doc so that we can inspect them in test\n          throw new Meteor.Error(\n            999, \"Test: Fields in doc: \" + _.keys(doc).sort().join(','));\n        },\n        fetch: ['field1']\n      });\n      restrictedCollectionForFetchAllTest.allow({\n        update: function() { return true; }\n      });\n    }\n\n    return cursors;\n  });\n}\n\nif (Meteor.isClient) {\n  _.each(['STRING', 'MONGO'], function (idGeneration) {\n    // Set up a bunch of test collections... on the client! They match the ones\n    // created by setUpAllowTestsCollections.\n\n    var nonce = Random.id();\n    // Tell the server to make, configure, and publish a set of collections unique\n    // to our test run. Since the method does not unblock, this will complete\n    // running on the server before anything else happens.\n    Meteor.subscribe('allowTests', nonce, idGeneration);\n\n    // helper for defining a collection, subscribing to it, and defining\n    // a method to clear it\n    var defineCollection = function(name, transform) {\n      var fullName = name + idGeneration + nonce;\n      var collection = new Mongo.Collection(\n        fullName, {idGeneration: idGeneration, transform: transform});\n\n      collection.callClearMethod = function (callback) {\n        Meteor.call(\"clear-collection-\" + fullName, callback);\n      };\n      collection.unnoncedName = name + idGeneration;\n      return collection;\n    };\n\n    // totally insecure collection\n    var insecureCollection = defineCollection(\"collection-insecure\");\n\n    // totally locked down collection\n    var lockedDownCollection = defineCollection(\"collection-locked-down\");\n\n    // restricted collection with same allowed modifications, both with and\n    // without the `insecure` package\n    var restrictedCollectionDefaultSecure = defineCollection(\n      \"collection-restrictedDefaultSecure\");\n    var restrictedCollectionDefaultInsecure = defineCollection(\n      \"collection-restrictedDefaultInsecure\");\n    var restrictedCollectionForUpdateOptionsTest = defineCollection(\n      \"collection-restrictedForUpdateOptionsTest\");\n    var restrictedCollectionForPartialAllowTest = defineCollection(\n      \"collection-restrictedForPartialAllowTest\");\n    var restrictedCollectionForPartialDenyTest = defineCollection(\n      \"collection-restrictedForPartialDenyTest\");\n    var restrictedCollectionForFetchTest = defineCollection(\n      \"collection-restrictedForFetchTest\");\n    var restrictedCollectionForFetchAllTest = defineCollection(\n      \"collection-restrictedForFetchAllTest\");\n    var restrictedCollectionWithTransform = defineCollection(\n      \"withTransform\", function (doc) {\n        return doc.a;\n      });\n    var restrictedCollectionForInvalidTransformTest = defineCollection(\n      \"collection-restrictedForInvalidTransform\");\n    var restrictedCollectionForClientIdTest = defineCollection(\n      \"collection-restrictedForClientIdTest\");\n\n    // test that if allow is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial allow, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialAllowTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n    // test that if deny is called once then the collection is\n    // restricted, and that other mutations aren't allowed\n    testAsyncMulti(\"collection - partial deny, \" + idGeneration, [\n      function (test, expect) {\n        restrictedCollectionForPartialDenyTest.update(\n          'foo', {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.error, 403);\n          }));\n      }\n    ]);\n\n\n    // test that we only fetch the fields specified\n    testAsyncMulti(\"collection - fetch, \" + idGeneration, [\n      function (test, expect) {\n        var fetchId = restrictedCollectionForFetchTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        var fetchAllId = restrictedCollectionForFetchAllTest.insert(\n          {field1: 1, field2: 1, field3: 1, field4: 1});\n        restrictedCollectionForFetchTest.update(\n          fetchId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3\");\n          }));\n        restrictedCollectionForFetchTest.remove(\n          fetchId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3\");\n          }));\n\n        restrictedCollectionForFetchAllTest.update(\n          fetchAllId, {$set: {updated: true}}, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n          }));\n        restrictedCollectionForFetchAllTest.remove(\n          fetchAllId, expect(function (err, res) {\n            test.equal(err.reason,\n                       \"Test: Fields in doc: _id,field1,field2,field3,field4\");\n          }));\n      }\n    ]);\n\n    (function(){\n      testAsyncMulti(\"collection - restricted factories \" + idGeneration, [\n        function (test, expect) {\n          restrictedCollectionWithTransform.callClearMethod(expect(function () {\n            test.equal(restrictedCollectionWithTransform.find().count(), 0);\n          }));\n        },\n        function (test, expect) {\n          var self = this;\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"bar\", baz: \"baz\"}\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item1 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"foo\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item2 = res;\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"adsfadf\", bar: \"quux\", baz: \"quux\"},\n            b: \"potato\"\n          }, expect(function (e, res) {\n            test.isTrue(e);\n          }));\n          restrictedCollectionWithTransform.insert({\n            a: {foo: \"bar\"},\n            topLevelField: true\n          }, expect(function (e, res) {\n            test.isFalse(e);\n            test.isTrue(res);\n            self.item3 = res;\n          }));\n        },\n        function (test, expect) {\n          var self = this;\n          // This should work, because there is an update allow for things with\n          // topLevelField.\n          restrictedCollectionWithTransform.update(\n            self.item3, { $set: { xxx: true } }, expect(function (e, res) {\n              test.isFalse(e);\n              test.equal(1, res);\n            }));\n        },\n        function (test, expect) {\n          var self = this;\n          test.equal(\n            restrictedCollectionWithTransform.findOne(self.item1),\n            {_id: self.item1, foo: \"foo\", bar: \"bar\", baz: \"baz\"});\n          restrictedCollectionWithTransform.remove(\n            self.item1, expect(function (e, res) {\n              test.isFalse(e);\n            }));\n          restrictedCollectionWithTransform.remove(\n            self.item2, expect(function (e, res) {\n              test.isTrue(e);\n            }));\n        }\n      ]);\n    })();\n\n    testAsyncMulti(\"collection - insecure, \" + idGeneration, [\n      function (test, expect) {\n        insecureCollection.callClearMethod(expect(function () {\n          test.equal(insecureCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        var id = insecureCollection.insert({foo: 'bar'}, expect(function(err, res) {\n          test.equal(res, id);\n          test.equal(insecureCollection.find(id).count(), 1);\n          test.equal(insecureCollection.findOne(id).foo, 'bar');\n        }));\n        test.equal(insecureCollection.find(id).count(), 1);\n        test.equal(insecureCollection.findOne(id).foo, 'bar');\n      }\n    ]);\n\n    testAsyncMulti(\"collection - locked down, \" + idGeneration, [\n      function (test, expect) {\n        lockedDownCollection.callClearMethod(expect(function() {\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      },\n      function (test, expect) {\n        lockedDownCollection.insert({foo: 'bar'}, expect(function (err, res) {\n          test.equal(err.error, 403);\n          test.equal(lockedDownCollection.find().count(), 0);\n        }));\n      }\n    ]);\n\n    (function () {\n      var collection = restrictedCollectionForUpdateOptionsTest;\n      var id1, id2;\n      testAsyncMulti(\"collection - update options, \" + idGeneration, [\n        // init\n        function (test, expect) {\n          collection.callClearMethod(expect(function () {\n            test.equal(collection.find().count(), 0);\n          }));\n        },\n        // put a few objects\n        function (test, expect) {\n          var doc = {canInsert: true, canUpdate: true};\n          id1 = collection.insert(doc);\n          id2 = collection.insert(doc);\n          collection.insert(doc);\n          collection.insert(doc, expect(function (err, res) {\n            test.isFalse(err);\n            test.equal(collection.find().count(), 4);\n          }));\n        },\n        // update by id\n        function (test, expect) {\n          collection.update(\n            id1,\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              test.equal(collection.find({updated: true}).count(), 1);\n            }));\n        },\n        // update by id in an object\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update with replacement operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {_id: id2, updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /In a restricted/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // upsert not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$set: { upserted: true }},\n            { upsert: true },\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /in a restricted/);\n              test.equal(collection.find({ upserted: true }).count(), 0);\n            }));\n        },\n        // update with rename operator not allowed, and has nice error.\n        function (test, expect) {\n          collection.update(\n            {_id: id2},\n            {$rename: {updated: 'asdf'}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              test.matches(err.reason, /not allowed/);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // update method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.update(\n              {updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/update',\n            {updated: {$exists: false}},\n            {$set: {updated: true}},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        },\n        // make sure it doesn't think that {_id: 'foo', something: else} is ok.\n        function (test, expect) {\n          test.throws(function () {\n            collection.update(\n              {_id: id1, updated: {$exists: false}},\n              {$set: {updated: true}});\n          });\n        },\n        // remove method with a non-ID selector is not allowed\n        function (test, expect) {\n          // We shouldn't even send the method...\n          test.throws(function () {\n            collection.remove({updated: true});\n          });\n          // ... but if we did, the server would reject it too.\n          Meteor.call(\n            '/' + collection._name + '/remove',\n            {updated: true},\n            expect(function (err, res) {\n              test.equal(err.error, 403);\n              // unchanged\n              test.equal(collection.find({updated: true}).count(), 2);\n            }));\n        }\n      ]);\n    }) ();\n\n    _.each(\n      [restrictedCollectionDefaultInsecure, restrictedCollectionDefaultSecure],\n      function(collection) {\n        var canUpdateId, canRemoveId;\n\n        testAsyncMulti(\"collection - \" + collection.unnoncedName, [\n          // init\n          function (test, expect) {\n            collection.callClearMethod(expect(function () {\n              test.equal(collection.find().count(), 0);\n            }));\n          },\n\n          // insert with no allows passing. request is denied.\n          function (test, expect) {\n            collection.insert(\n              {},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and one deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, cantInsert: true},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert with one allow and other deny. denied.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true, _id: Random.id()},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 0);\n              }));\n          },\n          // insert one allow passes. allowed.\n          function (test, expect) {\n            collection.insert(\n              {canInsert: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 1);\n              }));\n          },\n          // insert other allow passes. allowed.\n          // includes canUpdate for later.\n          function (test, expect) {\n            canUpdateId = collection.insert(\n              {canInsert2: true, canUpdate: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 2);\n              }));\n          },\n          // yet a third insert executes. this one has canRemove and\n          // cantRemove set for later.\n          function (test, expect) {\n            canRemoveId = collection.insert(\n              {canInsert: true, canRemove: true, cantRemove: true},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // can't update with a non-operator mutation\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {newObject: 1},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find().count(), 3);\n              }));\n          },\n\n          // updating dotted fields works as if we are changing their\n          // top part\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"dotted.field\": 1}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.findOne(canUpdateId).dotted.field, 1);\n              }));\n          },\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {\"verySecret.field\": 1}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                test.equal(collection.find({verySecret: {$exists: true}}).count(), 0);\n              }));\n          },\n\n          // update doesn't do anything if no docs match\n          function (test, expect) {\n            collection.update(\n              \"doesn't exist\",\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 0);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when access is denied trying to set `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to set two fields, one of which is\n          // `verySecret`\n          function (test, expect) {\n            collection.update(\n              canUpdateId, {$set: {updated: true, verySecret: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update fails when trying to modify docs that don't\n          // have `canUpdate` set\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.equal(err.error, 403);\n                // nothing has changed\n                test.equal(collection.find().count(), 3);\n                test.equal(collection.find({updated: true}).count(), 0);\n              }));\n          },\n          // update executes when it should\n          function (test, expect) {\n            collection.update(\n              canUpdateId,\n              {$set: {updated: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.find({updated: true}).count(), 1);\n              }));\n          },\n\n          // remove fails when trying to modify a doc with no `canRemove` set\n          function (test, expect) {\n            collection.remove(canUpdateId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n          // remove fails when trying to modify an doc with `cantRemove`\n          // set\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.equal(err.error, 403);\n              // nothing has changed\n              test.equal(collection.find().count(), 3);\n            }));\n          },\n\n          // update the doc to remove cantRemove.\n          function (test, expect) {\n            collection.update(\n              canRemoveId,\n              {$set: {cantRemove: false, canUpdate2: true}},\n              expect(function (err, res) {\n                test.isFalse(err);\n                test.equal(res, 1);\n                test.equal(collection.find({cantRemove: true}).count(), 0);\n              }));\n          },\n\n          // now remove can remove it.\n          function (test, expect) {\n            collection.remove(canRemoveId,\n                              expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 1);\n              // successfully removed\n              test.equal(collection.find().count(), 2);\n            }));\n          },\n\n          // try to remove a doc that doesn't exist. see we remove no docs.\n          function (test, expect) {\n            collection.remove('some-random-id-that-never-matches',\n                              expect(function (err, res) {\n              test.isFalse(err);\n              test.equal(res, 0);\n              // nothing removed\n              test.equal(collection.find().count(), 2);\n            }));\n          },\n\n          // methods can still bypass restrictions\n          function (test, expect) {\n            collection.callClearMethod(\n              expect(function (err, res) {\n                test.isFalse(err);\n                // successfully removed\n                test.equal(collection.find().count(), 0);\n            }));\n          }\n        ]);\n      });\n    testAsyncMulti(\n      \"collection - allow/deny transform must return object, \" + idGeneration,\n      [function (test, expect) {\n        restrictedCollectionForInvalidTransformTest.insert({}, expect(function (err, res) {\n          test.isTrue(err);\n        }));\n      }]);\n    testAsyncMulti(\n      \"collection - restricted collection allows client-side id, \" + idGeneration,\n      [function (test, expect) {\n        var self = this;\n        self.id = Random.id();\n        restrictedCollectionForClientIdTest.insert({_id: self.id}, expect(function (err, res) {\n          test.isFalse(err);\n          test.equal(res, self.id);\n          test.equal(restrictedCollectionForClientIdTest.findOne(self.id),\n                     {_id: self.id});\n        }));\n      }]);\n  });  // end idGeneration loop\n}  // end if isClient\n\n\n\n// A few simple server-only tests which don't need to coordinate collections\n// with the client..\nif (Meteor.isServer) {\n  Tinytest.add(\"collection - allow and deny validate options\", function (test) {\n    var collection = new Mongo.Collection(null);\n\n    test.throws(function () {\n      collection.allow({invalidOption: true});\n    });\n    test.throws(function () {\n      collection.deny({invalidOption: true});\n    });\n\n    _.each(['insert', 'update', 'remove', 'fetch'], function (key) {\n      var options = {};\n      options[key] = true;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = false;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = undefined;\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    _.each(['insert', 'update', 'remove'], function (key) {\n      var options = {};\n      options[key] = ['an array']; // this should be a function, not an array\n      test.throws(function () {\n        collection.allow(options);\n      });\n      test.throws(function () {\n        collection.deny(options);\n      });\n    });\n\n    test.throws(function () {\n      collection.allow({fetch: function () {}}); // this should be an array\n    });\n  });\n\n  Tinytest.add(\"collection - calling allow restricts\", function (test) {\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._restricted, false);\n    collection.allow({\n      insert: function() {}\n    });\n    test.equal(collection._restricted, true);\n  });\n\n  Tinytest.add(\"collection - global insecure\", function (test) {\n    // note: This test alters the global insecure status, by sneakily hacking\n    // the global Package object!\n    var insecurePackage = Package.insecure;\n\n    Package.insecure = {};\n    var collection = new Mongo.Collection(null);\n    test.equal(collection._isInsecure(), true);\n\n    Package.insecure = undefined;\n    test.equal(collection._isInsecure(), false);\n\n    delete Package.insecure;\n    test.equal(collection._isInsecure(), false);\n\n    collection._insecure = true;\n    test.equal(collection._isInsecure(), true);\n\n    if (insecurePackage)\n      Package.insecure = insecurePackage;\n    else\n      delete Package.insecure;\n  });\n}\n"]},"hash":"9719746c19a78c9f981f5e93a33b70a76c25d922"}
